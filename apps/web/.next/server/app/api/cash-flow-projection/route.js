"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/cash-flow-projection/route";
exports.ids = ["app/api/cash-flow-projection/route"];
exports.modules = {

/***/ "../../client/components/action-async-storage.external":
/*!*******************************************************************************!*\
  !*** external "next/dist/client/components/action-async-storage.external.js" ***!
  \*******************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/client/components/action-async-storage.external.js");

/***/ }),

/***/ "../../client/components/request-async-storage.external":
/*!********************************************************************************!*\
  !*** external "next/dist/client/components/request-async-storage.external.js" ***!
  \********************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/client/components/request-async-storage.external.js");

/***/ }),

/***/ "../../client/components/static-generation-async-storage.external":
/*!******************************************************************************************!*\
  !*** external "next/dist/client/components/static-generation-async-storage.external.js" ***!
  \******************************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/client/components/static-generation-async-storage.external.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "(rsc)/../../node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fcash-flow-projection%2Froute&page=%2Fapi%2Fcash-flow-projection%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fcash-flow-projection%2Froute.ts&appDir=%2FUsers%2Ftrunghuynh%2FDeveloper%2FFinanceapp%2Fapps%2Fweb%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Ftrunghuynh%2FDeveloper%2FFinanceapp%2Fapps%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fcash-flow-projection%2Froute&page=%2Fapi%2Fcash-flow-projection%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fcash-flow-projection%2Froute.ts&appDir=%2FUsers%2Ftrunghuynh%2FDeveloper%2FFinanceapp%2Fapps%2Fweb%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Ftrunghuynh%2FDeveloper%2FFinanceapp%2Fapps%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/../../node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/../../node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/../../node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Users_trunghuynh_Developer_Financeapp_apps_web_app_api_cash_flow_projection_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/cash-flow-projection/route.ts */ \"(rsc)/./app/api/cash-flow-projection/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/cash-flow-projection/route\",\n        pathname: \"/api/cash-flow-projection\",\n        filename: \"route\",\n        bundlePath: \"app/api/cash-flow-projection/route\"\n    },\n    resolvedPagePath: \"/Users/trunghuynh/Developer/Financeapp/apps/web/app/api/cash-flow-projection/route.ts\",\n    nextConfigOutput,\n    userland: _Users_trunghuynh_Developer_Financeapp_apps_web_app_api_cash_flow_projection_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/cash-flow-projection/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1hcHAtbG9hZGVyLmpzP25hbWU9YXBwJTJGYXBpJTJGY2FzaC1mbG93LXByb2plY3Rpb24lMkZyb3V0ZSZwYWdlPSUyRmFwaSUyRmNhc2gtZmxvdy1wcm9qZWN0aW9uJTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGY2FzaC1mbG93LXByb2plY3Rpb24lMkZyb3V0ZS50cyZhcHBEaXI9JTJGVXNlcnMlMkZ0cnVuZ2h1eW5oJTJGRGV2ZWxvcGVyJTJGRmluYW5jZWFwcCUyRmFwcHMlMkZ3ZWIlMkZhcHAmcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyZyb290RGlyPSUyRlVzZXJzJTJGdHJ1bmdodXluaCUyRkRldmVsb3BlciUyRkZpbmFuY2VhcHAlMkZhcHBzJTJGd2ViJmlzRGV2PXRydWUmdHNjb25maWdQYXRoPXRzY29uZmlnLmpzb24mYmFzZVBhdGg9JmFzc2V0UHJlZml4PSZuZXh0Q29uZmlnT3V0cHV0PSZwcmVmZXJyZWRSZWdpb249Jm1pZGRsZXdhcmVDb25maWc9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBc0c7QUFDdkM7QUFDYztBQUNxQztBQUNsSDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0hBQW1CO0FBQzNDO0FBQ0EsY0FBYyx5RUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWTtBQUNaLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFpRTtBQUN6RTtBQUNBO0FBQ0EsV0FBVyw0RUFBVztBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ3VIOztBQUV2SCIsInNvdXJjZXMiOlsid2VicGFjazovL0BmaW5hbmNlYXBwL3dlYi8/YzA2MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcHBSb3V0ZVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvYXBwLXJvdXRlL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IHBhdGNoRmV0Y2ggYXMgX3BhdGNoRmV0Y2ggfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvcGF0Y2gtZmV0Y2hcIjtcbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCIvVXNlcnMvdHJ1bmdodXluaC9EZXZlbG9wZXIvRmluYW5jZWFwcC9hcHBzL3dlYi9hcHAvYXBpL2Nhc2gtZmxvdy1wcm9qZWN0aW9uL3JvdXRlLnRzXCI7XG4vLyBXZSBpbmplY3QgdGhlIG5leHRDb25maWdPdXRwdXQgaGVyZSBzbyB0aGF0IHdlIGNhbiB1c2UgdGhlbSBpbiB0aGUgcm91dGVcbi8vIG1vZHVsZS5cbmNvbnN0IG5leHRDb25maWdPdXRwdXQgPSBcIlwiXG5jb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBBcHBSb3V0ZVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9jYXNoLWZsb3ctcHJvamVjdGlvbi9yb3V0ZVwiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL2Nhc2gtZmxvdy1wcm9qZWN0aW9uXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS9jYXNoLWZsb3ctcHJvamVjdGlvbi9yb3V0ZVwiXG4gICAgfSxcbiAgICByZXNvbHZlZFBhZ2VQYXRoOiBcIi9Vc2Vycy90cnVuZ2h1eW5oL0RldmVsb3Blci9GaW5hbmNlYXBwL2FwcHMvd2ViL2FwcC9hcGkvY2FzaC1mbG93LXByb2plY3Rpb24vcm91dGUudHNcIixcbiAgICBuZXh0Q29uZmlnT3V0cHV0LFxuICAgIHVzZXJsYW5kXG59KTtcbi8vIFB1bGwgb3V0IHRoZSBleHBvcnRzIHRoYXQgd2UgbmVlZCB0byBleHBvc2UgZnJvbSB0aGUgbW9kdWxlLiBUaGlzIHNob3VsZFxuLy8gYmUgZWxpbWluYXRlZCB3aGVuIHdlJ3ZlIG1vdmVkIHRoZSBvdGhlciByb3V0ZXMgdG8gdGhlIG5ldyBmb3JtYXQuIFRoZXNlXG4vLyBhcmUgdXNlZCB0byBob29rIGludG8gdGhlIHJvdXRlLlxuY29uc3QgeyByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcyB9ID0gcm91dGVNb2R1bGU7XG5jb25zdCBvcmlnaW5hbFBhdGhuYW1lID0gXCIvYXBpL2Nhc2gtZmxvdy1wcm9qZWN0aW9uL3JvdXRlXCI7XG5mdW5jdGlvbiBwYXRjaEZldGNoKCkge1xuICAgIHJldHVybiBfcGF0Y2hGZXRjaCh7XG4gICAgICAgIHNlcnZlckhvb2tzLFxuICAgICAgICBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlXG4gICAgfSk7XG59XG5leHBvcnQgeyByb3V0ZU1vZHVsZSwgcmVxdWVzdEFzeW5jU3RvcmFnZSwgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MsIG9yaWdpbmFsUGF0aG5hbWUsIHBhdGNoRmV0Y2gsICB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtcm91dGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fcash-flow-projection%2Froute&page=%2Fapi%2Fcash-flow-projection%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fcash-flow-projection%2Froute.ts&appDir=%2FUsers%2Ftrunghuynh%2FDeveloper%2FFinanceapp%2Fapps%2Fweb%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Ftrunghuynh%2FDeveloper%2FFinanceapp%2Fapps%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./app/api/cash-flow-projection/route.ts":
/*!***********************************************!*\
  !*** ./app/api/cash-flow-projection/route.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/../../node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_supabase_server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/supabase-server */ \"(rsc)/./lib/supabase-server.ts\");\n/* harmony import */ var _barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=addMonths,eachMonthOfInterval,endOfMonth,format,parseISO,startOfMonth!=!date-fns */ \"(rsc)/../../node_modules/date-fns/parseISO.js\");\n/* harmony import */ var _barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=addMonths,eachMonthOfInterval,endOfMonth,format,parseISO,startOfMonth!=!date-fns */ \"(rsc)/../../node_modules/date-fns/format.js\");\n/* harmony import */ var _barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=addMonths,eachMonthOfInterval,endOfMonth,format,parseISO,startOfMonth!=!date-fns */ \"(rsc)/../../node_modules/date-fns/startOfMonth.js\");\n/* harmony import */ var _barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! __barrel_optimize__?names=addMonths,eachMonthOfInterval,endOfMonth,format,parseISO,startOfMonth!=!date-fns */ \"(rsc)/../../node_modules/date-fns/endOfMonth.js\");\n/* harmony import */ var _barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! __barrel_optimize__?names=addMonths,eachMonthOfInterval,endOfMonth,format,parseISO,startOfMonth!=!date-fns */ \"(rsc)/../../node_modules/date-fns/addMonths.js\");\n/* harmony import */ var _barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! __barrel_optimize__?names=addMonths,eachMonthOfInterval,endOfMonth,format,parseISO,startOfMonth!=!date-fns */ \"(rsc)/../../node_modules/date-fns/eachMonthOfInterval.js\");\n/* harmony import */ var _lib_cash_flow_analyzer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/cash-flow-analyzer */ \"(rsc)/./lib/cash-flow-analyzer.ts\");\n/**\n * Cash Flow Projection API - Version 3.0\n *\n * Implements intelligent predictive forecasting with hierarchical priority system\n * to prevent double-counting of expenses, plus liquidity & solvency analysis.\n *\n * @see docs/CASHFLOW_SYSTEM_2.0.md for v2.0 documentation\n * @see docs/CASHFLOW_SYSTEM_3.0.md for v3.0 liquidity features\n */ \n\n\n\n// Apply scenario adjustments to a monthly projection\nfunction applyScenarioAdjustments(monthKey, baseIncome, basePredictedExpenses, adjustments) {\n    let adjustedIncome = baseIncome;\n    let adjustedPredicted = basePredictedExpenses;\n    let scenarioDebtDrawdown = 0 // Track debt drawdowns separately\n    ;\n    let scenarioDebtRepayment = 0 // Track debt repayments separately\n    ;\n    let scenarioIncome = 0 // Track scenario income additions\n    ;\n    let scenarioExpense = 0 // Track scenario expense additions\n    ;\n    const scenarioItems = [];\n    const monthDate = (0,_barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_3__.parseISO)(`${monthKey}-01`);\n    for (const adj of adjustments){\n        // Check if adjustment applies to this month\n        const startMonth = adj.start_month ? (0,_barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_3__.parseISO)(adj.start_month) : null;\n        const endMonth = adj.end_month ? (0,_barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_3__.parseISO)(adj.end_month) : null;\n        const startsBeforeOrOn = !startMonth || startMonth <= monthDate;\n        const endsAfterOrOn = !endMonth || endMonth >= monthDate;\n        // For one-time items, only apply if start_month matches\n        // debt_drawdown is also a one-time event (single loan disbursement)\n        const isOneTime = adj.adjustment_type.startsWith(\"one_time\") || adj.adjustment_type === \"debt_drawdown\";\n        const matchesMonth = isOneTime ? startMonth && (0,_barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)(startMonth, \"yyyy-MM\") === monthKey : startsBeforeOrOn && endsAfterOrOn;\n        // Check for debt repayment in this month (from debt_drawdown metadata)\n        if (adj.adjustment_type === \"debt_drawdown\" && adj.amount && adj.metadata?.repayment_month) {\n            const repaymentMonth = adj.metadata.repayment_month;\n            if (repaymentMonth === monthKey) {\n                // Add debt repayment as an expense in the repayment month\n                adjustedPredicted += adj.amount;\n                scenarioDebtRepayment += adj.amount;\n                scenarioItems.push({\n                    name: `${adj.name} (Repayment)`,\n                    amount: -adj.amount,\n                    type: \"debt_repayment\"\n                });\n                console.log(`[Scenario Debug] Added debt_repayment: ${adj.amount} to month ${monthKey}`);\n            }\n        }\n        if (!matchesMonth) continue;\n        console.log(`[Scenario Debug] Applying ${adj.adjustment_type} \"${adj.name}\" to month ${monthKey}`);\n        switch(adj.adjustment_type){\n            case \"one_time_income\":\n            case \"recurring_income\":\n                if (adj.amount) {\n                    adjustedIncome += adj.amount;\n                    scenarioIncome += adj.amount;\n                    scenarioItems.push({\n                        name: adj.name,\n                        amount: adj.amount,\n                        type: \"income\"\n                    });\n                }\n                break;\n            case \"one_time_expense\":\n            case \"recurring_expense\":\n                if (adj.amount) {\n                    adjustedPredicted += adj.amount;\n                    scenarioExpense += adj.amount;\n                    scenarioItems.push({\n                        name: adj.name,\n                        amount: -adj.amount,\n                        type: \"expense\"\n                    });\n                }\n                break;\n            case \"debt_drawdown\":\n                // Add debt as income (cash inflow) but track it separately for display\n                if (adj.amount) {\n                    adjustedIncome += adj.amount;\n                    scenarioDebtDrawdown += adj.amount // Track separately!\n                    ;\n                    scenarioItems.push({\n                        name: adj.name,\n                        amount: adj.amount,\n                        type: \"debt\"\n                    });\n                    console.log(`[Scenario Debug] Added debt_drawdown: ${adj.amount} to month ${monthKey}`);\n                }\n                break;\n            case \"modify_predicted\":\n                // Apply percentage change to predicted expenses\n                if (adj.percentage !== null) {\n                    const change = basePredictedExpenses * (adj.percentage / 100);\n                    adjustedPredicted += change;\n                    scenarioExpense += change;\n                    scenarioItems.push({\n                        name: adj.name,\n                        amount: change,\n                        type: \"modification\"\n                    });\n                }\n                break;\n            case \"modify_income\":\n                // Apply percentage change to income\n                if (adj.percentage !== null) {\n                    const change = baseIncome * (adj.percentage / 100);\n                    adjustedIncome += change;\n                    scenarioIncome += change;\n                    scenarioItems.push({\n                        name: adj.name,\n                        amount: change,\n                        type: \"modification\"\n                    });\n                }\n                break;\n        }\n    }\n    return {\n        adjustedIncome,\n        adjustedPredicted,\n        scenarioDebtDrawdown,\n        scenarioDebtRepayment,\n        scenarioIncome,\n        scenarioExpense,\n        scenarioItems\n    };\n}\nasync function GET(request) {\n    const supabase = (0,_lib_supabase_server__WEBPACK_IMPORTED_MODULE_1__.createSupabaseServerClient)();\n    const searchParams = request.nextUrl.searchParams;\n    const entityId = searchParams.get(\"entity_id\");\n    const monthsAhead = parseInt(searchParams.get(\"months_ahead\") || \"6\");\n    const scenarioId = searchParams.get(\"scenario_id\") // NEW: Optional scenario\n    ;\n    if (!entityId) {\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: \"entity_id is required\"\n        }, {\n            status: 400\n        });\n    }\n    try {\n        // Verify user has permission to view cash flow\n        const { data: { user }, error: authError } = await supabase.auth.getUser();\n        if (authError || !user) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Unauthorized\"\n            }, {\n                status: 401\n            });\n        }\n        // Get user's role for this entity\n        const { data: entityUser, error: roleError } = await supabase.from(\"entity_users\").select(\"role\").eq(\"entity_id\", entityId).eq(\"user_id\", user.id).single();\n        if (roleError || !entityUser) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"You do not have access to this entity\"\n            }, {\n                status: 403\n            });\n        }\n        // Check for custom permission override\n        const { data: customPermission } = await supabase.from(\"role_permissions\").select(\"can_view_cash_flow\").eq(\"entity_id\", entityId).eq(\"role\", entityUser.role).single();\n        // Determine if user can view cash flow\n        // Default: only editor and above can view\n        const roleHierarchy = {\n            \"owner\": 5,\n            \"admin\": 4,\n            \"editor\": 3,\n            \"data_entry\": 2,\n            \"viewer\": 1\n        };\n        const userRoleLevel = roleHierarchy[entityUser.role] || 0;\n        const defaultCanViewCashFlow = userRoleLevel >= 3 // editor level\n        ;\n        // Use custom permission if set, otherwise use default\n        const canViewCashFlow = customPermission?.can_view_cash_flow !== null && customPermission?.can_view_cash_flow !== undefined ? customPermission.can_view_cash_flow : defaultCanViewCashFlow;\n        if (!canViewCashFlow) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"You do not have permission to view cash flow projections\"\n            }, {\n                status: 403\n            });\n        }\n        const startDate = (0,_barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_5__.startOfMonth)(new Date());\n        const endDate = (0,_barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_6__.endOfMonth)((0,_barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_7__.addMonths)(startDate, monthsAhead - 1));\n        // Fetch scenario adjustments if scenario_id provided\n        let scenarioAdjustments = [];\n        let scenarioInfo = null;\n        if (scenarioId) {\n            console.log(`[Scenario Debug] Fetching scenario ${scenarioId} for entity ${entityId}`);\n            const { data: scenario, error: scenarioError } = await supabase.from(\"cashflow_scenarios\").select(`\n          name,\n          color,\n          adjustments:scenario_adjustments(*)\n        `).eq(\"scenario_id\", scenarioId).eq(\"entity_id\", entityId).single();\n            if (scenarioError) {\n                console.error(\"[Scenario Debug] Error fetching scenario:\", scenarioError);\n            }\n            if (!scenarioError && scenario) {\n                scenarioInfo = {\n                    name: scenario.name,\n                    color: scenario.color\n                };\n                scenarioAdjustments = scenario.adjustments || [];\n                console.log(`[Scenario Debug] Found scenario: ${scenario.name}, adjustments: ${scenarioAdjustments.length}`);\n                console.log(\"[Scenario Debug] Adjustments:\", JSON.stringify(scenarioAdjustments, null, 2));\n            }\n        }\n        // Generate list of months\n        const months = (0,_barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_8__.eachMonthOfInterval)({\n            start: startDate,\n            end: endDate\n        });\n        // Fetch debt drawdowns (money we borrowed and need to pay back)\n        // These are from credit_line/term_loan accounts with due dates\n        const { data: debtDrawdowns, error: debtDrawdownError } = await supabase.from(\"debt_drawdown\").select(`\n        *,\n        accounts!inner (\n          entity_id,\n          account_name,\n          account_type\n        )\n      `).eq(\"accounts.entity_id\", entityId).eq(\"status\", \"active\").not(\"due_date\", \"is\", null).gte(\"due_date\", (0,_barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)(startDate, \"yyyy-MM-dd\")).lte(\"due_date\", (0,_barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)(endDate, \"yyyy-MM-dd\")).order(\"due_date\", {\n            ascending: true\n        });\n        if (debtDrawdownError) {\n            console.error(\"Error fetching debt drawdowns:\", debtDrawdownError);\n        }\n        // Also fetch loan disbursements (loans we gave out - receivables with due dates)\n        const { data: loanReceivables, error: loanError } = await supabase.from(\"loan_disbursement\").select(`\n        *,\n        accounts!inner (\n          entity_id,\n          account_name\n        )\n      `).eq(\"accounts.entity_id\", entityId).eq(\"status\", \"active\").not(\"due_date\", \"is\", null).gte(\"due_date\", (0,_barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)(startDate, \"yyyy-MM-dd\")).lte(\"due_date\", (0,_barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)(endDate, \"yyyy-MM-dd\")).order(\"due_date\", {\n            ascending: true\n        });\n        if (loanError) {\n            console.error(\"Error fetching loan receivables:\", loanError);\n        }\n        // Fetch scheduled payment instances (only unpaid)\n        const { data: scheduledInstances, error: scheduledError } = await supabase.from(\"scheduled_payment_instances\").select(`\n        *,\n        scheduled_payments:scheduled_payment_id!inner (\n          contract_name,\n          payment_type,\n          payee_name,\n          category_id,\n          entity_id,\n          categories:category_id (\n            category_name\n          )\n        )\n      `).eq(\"scheduled_payments.entity_id\", entityId).in(\"status\", [\n            \"pending\",\n            \"overdue\"\n        ]) // Only include unpaid instances\n        .gte(\"due_date\", (0,_barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)(startDate, \"yyyy-MM-dd\")).lte(\"due_date\", (0,_barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)(endDate, \"yyyy-MM-dd\")).order(\"due_date\", {\n            ascending: true\n        });\n        // DEBUG: Also fetch ALL instances to compare\n        const { data: allInstances } = await supabase.from(\"scheduled_payment_instances\").select(`\n        *,\n        scheduled_payments:scheduled_payment_id!inner (\n          contract_name,\n          payment_type,\n          payee_name,\n          category_id,\n          entity_id,\n          categories:category_id (\n            category_name\n          )\n        )\n      `).eq(\"scheduled_payments.entity_id\", entityId).gte(\"due_date\", (0,_barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)(startDate, \"yyyy-MM-dd\")).lte(\"due_date\", (0,_barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)(endDate, \"yyyy-MM-dd\"));\n        const totalAllInstances = allInstances?.reduce((sum, i)=>sum + (i.amount || 0), 0) || 0;\n        const totalUnpaidInstances = scheduledInstances?.reduce((sum, i)=>sum + (i.amount || 0), 0) || 0;\n        console.log(`[DEBUG] Total all instances (${allInstances?.length}): ${totalAllInstances.toLocaleString()} VND`);\n        console.log(`[DEBUG] Total unpaid instances (${scheduledInstances?.length}): ${totalUnpaidInstances.toLocaleString()} VND`);\n        console.log(`[DEBUG] Difference: ${(totalAllInstances - totalUnpaidInstances).toLocaleString()} VND`);\n        if (scheduledError) {\n            console.error(\"Error fetching scheduled payments:\", scheduledError);\n        }\n        // Fetch active budgets\n        const { data: budgets, error: budgetsError } = await supabase.from(\"category_budgets\").select(`\n        *,\n        categories:category_id (\n          category_name\n        )\n      `).eq(\"entity_id\", entityId).eq(\"is_active\", true).gte(\"end_date\", (0,_barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)(startDate, \"yyyy-MM-dd\")).order(\"start_date\", {\n            ascending: true\n        });\n        if (budgetsError) {\n            console.error(\"Error fetching budgets:\", budgetsError);\n        }\n        // Get current cash balance (sum of cash/bank account balances only)\n        // Excludes debt accounts (credit_card, credit_line, term_loan) and loan_receivable\n        const { data: accounts, error: accountsError } = await supabase.from(\"accounts\").select(\"account_id, account_name, account_type\").eq(\"entity_id\", entityId).eq(\"is_active\", true).in(\"account_type\", [\n            \"bank\",\n            \"cash\",\n            \"investment\"\n        ]) // Only liquid asset accounts\n        ;\n        if (accountsError) {\n            console.error(\"Error fetching accounts:\", accountsError);\n        }\n        // Fetch credit line accounts with their limits and usage\n        const { data: creditLineAccounts, error: creditLineError } = await supabase.from(\"accounts\").select(\"account_id, account_name, credit_limit, bank_name\").eq(\"entity_id\", entityId).eq(\"is_active\", true).in(\"account_type\", [\n            \"credit_line\",\n            \"term_loan\"\n        ]).not(\"credit_limit\", \"is\", null);\n        if (creditLineError) {\n            console.error(\"Error fetching credit lines:\", creditLineError);\n        }\n        // Calculate used amount for each credit line from active debt drawdowns\n        const creditLines = await Promise.all((creditLineAccounts || []).map(async (account)=>{\n            const { data: drawdowns } = await supabase.from(\"debt_drawdown\").select(\"remaining_balance\").eq(\"account_id\", account.account_id).in(\"status\", [\n                \"active\",\n                \"overdue\"\n            ]);\n            const usedAmount = drawdowns?.reduce((sum, d)=>sum + (d.remaining_balance || 0), 0) || 0;\n            const creditLimit = account.credit_limit || 0;\n            const availableCredit = creditLimit - usedAmount;\n            return {\n                account_id: account.account_id,\n                account_name: account.account_name,\n                bank_name: account.bank_name,\n                credit_limit: creditLimit,\n                used_amount: usedAmount,\n                available_credit: availableCredit,\n                utilization_percent: creditLimit > 0 ? usedAmount / creditLimit * 100 : 0\n            };\n        }));\n        // Calculate total credit line availability\n        const totalCreditLimit = creditLines.reduce((sum, cl)=>sum + cl.credit_limit, 0);\n        const totalCreditUsed = creditLines.reduce((sum, cl)=>sum + cl.used_amount, 0);\n        const totalCreditAvailable = totalCreditLimit - totalCreditUsed;\n        console.log(`[Cash Flow] Found ${accounts?.length || 0} cash/bank/investment accounts for entity ${entityId}`);\n        console.log(`[Cash Flow] Accounts: ${accounts?.map((a)=>`${a.account_name}(${a.account_type})`).join(\", \")}`);\n        const accountIds = accounts?.map((a)=>a.account_id) || [];\n        // Get current balances by calculating from transactions\n        let currentBalance = 0;\n        if (accountIds.length > 0) {\n            // Calculate balance for each account up to today\n            const today = new Date();\n            for (const account of accounts || []){\n                const { data: balance, error: balanceError } = await supabase.rpc(\"calculate_balance_up_to_date\", {\n                    p_account_id: account.account_id,\n                    p_up_to_date: today.toISOString().split(\"T\")[0]\n                });\n                if (balanceError) {\n                    console.error(`[Cash Flow] Error calculating balance for ${account.account_name}:`, JSON.stringify(balanceError));\n                }\n                console.log(`[Cash Flow] ${account.account_name} (${account.account_type}) balance: ${balance || 0}`);\n                currentBalance += balance || 0;\n            }\n        }\n        console.log(`[Cash Flow] Total current balance (cash/bank/investment only): ${currentBalance}`);\n        // === CASH FLOW SYSTEM 2.0: Calculate predicted income (once for all months) ===\n        const { total: predictedMonthlyIncome, breakdown: incomeBreakdown } = await (0,_lib_cash_flow_analyzer__WEBPACK_IMPORTED_MODULE_2__.calculatePredictedIncome)(entityId);\n        console.log(`[Cash Flow 2.0] Predicted monthly income: ${predictedMonthlyIncome.toLocaleString()} VND`);\n        console.log(`[Cash Flow 2.0] Income sources: ${incomeBreakdown.length}`);\n        // Build monthly projections\n        const projections = await Promise.all(months.map(async (month)=>{\n            const monthKey = (0,_barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)(month, \"yyyy-MM\");\n            const monthStart = (0,_barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_5__.startOfMonth)(month);\n            const monthEnd = (0,_barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_6__.endOfMonth)(month);\n            // === PRIORITY 1: DEBT PAYMENTS (Drawdowns we need to repay) ===\n            const monthDebtPayments = (debtDrawdowns || []).filter((drawdown)=>{\n                const dueDate = (0,_barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_3__.parseISO)(drawdown.due_date);\n                return dueDate >= monthStart && dueDate <= monthEnd;\n            }).map((drawdown)=>({\n                    type: \"Debt Repayment\",\n                    loan_name: drawdown.accounts?.account_name || \"Debt Account\",\n                    drawdown_reference: drawdown.drawdown_reference || \"Unknown\",\n                    amount: drawdown.remaining_balance || 0,\n                    due_date: drawdown.due_date,\n                    status: drawdown.status,\n                    account_type: drawdown.accounts?.account_type || \"unknown\"\n                }));\n            // === PRIORITY 1: SCHEDULED PAYMENTS ===\n            const monthScheduledPayments = (scheduledInstances || []).filter((instance)=>{\n                const dueDate = (0,_barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_3__.parseISO)(instance.due_date);\n                return dueDate >= monthStart && dueDate <= monthEnd;\n            }).map((instance)=>({\n                    contract_name: instance.scheduled_payments?.contract_name || \"Unknown\",\n                    payment_type: instance.scheduled_payments?.payment_type,\n                    payee_name: instance.scheduled_payments?.payee_name || \"Unknown\",\n                    amount: instance.amount || 0,\n                    due_date: instance.due_date,\n                    status: instance.status,\n                    category_id: instance.scheduled_payments?.category_id,\n                    category_name: instance.scheduled_payments?.categories?.category_name || \"Uncategorized\"\n                }));\n            // === PRIORITY 2: PREDICTED EXPENSES (Cash Flow 2.0) ===\n            // Only predict for categories NOT covered by scheduled payments\n            const predictedExpenses = await (0,_lib_cash_flow_analyzer__WEBPACK_IMPORTED_MODULE_2__.calculatePredictedExpenses)(entityId, monthKey);\n            const totalPredicted = predictedExpenses.reduce((sum, exp)=>sum + exp.amount, 0);\n            // === PRIORITY 3: BUDGETS (only for categories with no schedule AND no history) ===\n            // Get categories already covered\n            const scheduledCategoryIds = await (0,_lib_cash_flow_analyzer__WEBPACK_IMPORTED_MODULE_2__.getCategoriesWithScheduledPayments)(entityId, monthKey);\n            const predictedCategoryNames = new Set(predictedExpenses.map((exp)=>exp.category_name));\n            const monthBudgets = (budgets || []).filter((budget)=>{\n                const budgetStart = (0,_barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_3__.parseISO)(budget.start_date);\n                const budgetEnd = (0,_barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_3__.parseISO)(budget.end_date);\n                const categoryId = budget.category_id;\n                const categoryName = budget.categories?.category_name || \"Unknown\";\n                // Only include budget if:\n                // 1. It's active this month\n                // 2. NOT in scheduled payments (Priority 1)\n                // 3. NOT in predicted expenses (Priority 2)\n                return budgetStart <= monthEnd && budgetEnd >= monthStart && !scheduledCategoryIds.has(categoryId) && !predictedCategoryNames.has(categoryName);\n            }).map((budget)=>({\n                    category_name: budget.categories?.category_name || \"Unknown\",\n                    budget_amount: budget.budget_amount || 0,\n                    estimated_spend: budget.budget_amount || 0\n                }));\n            // === BUDGET WARNINGS (Cash Flow 2.0) ===\n            const allBudgets = (budgets || []).filter((budget)=>{\n                const budgetStart = (0,_barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_3__.parseISO)(budget.start_date);\n                const budgetEnd = (0,_barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_3__.parseISO)(budget.end_date);\n                return budgetStart <= monthEnd && budgetEnd >= monthStart;\n            }).map((budget)=>({\n                    category_name: budget.categories?.category_name || \"Unknown\",\n                    budget_amount: budget.budget_amount || 0\n                }));\n            const budgetWarnings = (0,_lib_cash_flow_analyzer__WEBPACK_IMPORTED_MODULE_2__.compareBudgets)(predictedExpenses, allBudgets);\n            // Calculate totals\n            const totalDebt = monthDebtPayments.reduce((sum, p)=>sum + p.amount, 0);\n            const totalScheduled = monthScheduledPayments.reduce((sum, p)=>sum + p.amount, 0);\n            const totalBudgets = monthBudgets.reduce((sum, b)=>sum + b.estimated_spend, 0);\n            const totalObligations = totalDebt + totalScheduled + totalPredicted + totalBudgets;\n            return {\n                month: monthKey,\n                month_label: (0,_barrel_optimize_names_addMonths_eachMonthOfInterval_endOfMonth_format_parseISO_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)(month, \"MMMM yyyy\"),\n                debt_payments: monthDebtPayments,\n                scheduled_payments: monthScheduledPayments,\n                predicted_expenses: predictedExpenses,\n                budgets: monthBudgets,\n                total_debt: totalDebt,\n                total_scheduled: totalScheduled,\n                total_predicted: totalPredicted,\n                total_budgets: totalBudgets,\n                total_obligations: totalObligations,\n                income_breakdown: incomeBreakdown,\n                budget_warnings: budgetWarnings\n            };\n        }));\n        // === CASH FLOW 2.0: Calculate running balances WITH predicted income ===\n        // === CASH FLOW 3.1: Apply scenario adjustments if provided ===\n        let runningBalance = currentBalance;\n        const projectionsWithBalance = projections.map((proj)=>{\n            const openingBalance = runningBalance;\n            let projectedIncome = predictedMonthlyIncome // Use predicted income from historical data\n            ;\n            let totalPredictedWithScenario = proj.total_predicted;\n            // Apply scenario adjustments\n            let scenarioItems = [];\n            let scenarioDebtDrawdown = 0;\n            let scenarioDebtRepayment = 0;\n            let scenarioIncome = 0;\n            let scenarioExpense = 0;\n            if (scenarioAdjustments.length > 0) {\n                const adjusted = applyScenarioAdjustments(proj.month, projectedIncome, proj.total_predicted, scenarioAdjustments);\n                projectedIncome = adjusted.adjustedIncome;\n                totalPredictedWithScenario = adjusted.adjustedPredicted;\n                scenarioItems = adjusted.scenarioItems;\n                scenarioDebtDrawdown = adjusted.scenarioDebtDrawdown;\n                scenarioDebtRepayment = adjusted.scenarioDebtRepayment;\n                scenarioIncome = adjusted.scenarioIncome;\n                scenarioExpense = adjusted.scenarioExpense;\n            }\n            // Recalculate total obligations with scenario adjustments\n            const totalObligationsWithScenario = proj.total_debt + proj.total_scheduled + totalPredictedWithScenario + proj.total_budgets;\n            const closingBalance = openingBalance + projectedIncome - totalObligationsWithScenario;\n            runningBalance = closingBalance;\n            // Determine health status\n            let health;\n            if (closingBalance < 0) {\n                health = \"deficit\";\n            } else if (closingBalance < openingBalance * 0.2) {\n                health = \"tight\";\n            } else {\n                health = \"surplus\";\n            }\n            // Calculate base income (without scenario adjustments) for chart display\n            const baseIncome = predictedMonthlyIncome;\n            return {\n                ...proj,\n                opening_balance: openingBalance,\n                projected_income: projectedIncome,\n                base_income: baseIncome,\n                scenario_debt_drawdown: scenarioDebtDrawdown,\n                scenario_debt_repayment: scenarioDebtRepayment,\n                scenario_income: scenarioIncome,\n                scenario_expense: scenarioExpense,\n                total_predicted: totalPredictedWithScenario,\n                total_obligations: totalObligationsWithScenario,\n                closing_balance: closingBalance,\n                health,\n                scenario_items: scenarioItems // NEW: Items from scenario adjustments\n            };\n        });\n        // === CASH FLOW 2.0: Enhanced summary statistics ===\n        const totalObligations = projections.reduce((sum, p)=>sum + p.total_obligations, 0);\n        const totalProjectedIncome = predictedMonthlyIncome * monthsAhead;\n        const lowestBalance = Math.min(...projectionsWithBalance.map((p)=>p.closing_balance));\n        const monthsUntilNegative = projectionsWithBalance.findIndex((p)=>p.closing_balance < 0);\n        console.log(`[Cash Flow 2.0] Total obligations (${monthsAhead} months): ${totalObligations.toLocaleString()} VND`);\n        console.log(`[Cash Flow 2.0] Total projected income (${monthsAhead} months): ${totalProjectedIncome.toLocaleString()} VND`);\n        console.log(`[Cash Flow 2.0] Net change: ${(totalProjectedIncome - totalObligations).toLocaleString()} VND`);\n        console.log(`[Cash Flow 2.0] Lowest projected balance: ${lowestBalance.toLocaleString()} VND`);\n        // === CASH FLOW 3.0: LIQUIDITY & SOLVENCY ANALYSIS ===\n        const liquidityPosition = await (0,_lib_cash_flow_analyzer__WEBPACK_IMPORTED_MODULE_2__.analyzeLiquidityPosition)(entityId);\n        const monthlyBurnRate = totalObligations / monthsAhead;\n        const runwayAnalysis = (0,_lib_cash_flow_analyzer__WEBPACK_IMPORTED_MODULE_2__.calculateRunwayAnalysis)(liquidityPosition, monthlyBurnRate, predictedMonthlyIncome, monthsAhead);\n        console.log(`[Cash Flow 3.0] Total liquid assets: ${liquidityPosition.total_liquid_assets.toLocaleString()} VND`);\n        console.log(`[Cash Flow 3.0] Cash runway: ${runwayAnalysis.cash_runway_months.toFixed(1)} months`);\n        console.log(`[Cash Flow 3.0] Liquidity runway: ${runwayAnalysis.liquidity_runway_months.toFixed(1)} months`);\n        // Calculate total scenario debt drawdown (reduces credit availability for scenario)\n        const totalScenarioDebtDrawdown = projectionsWithBalance.reduce((sum, proj)=>sum + (proj.scenario_debt_drawdown || 0), 0);\n        // Calculate projected credit availability per month\n        // As debt payments are made, credit availability increases\n        // Scenario debt drawdowns reduce availability, scenario repayments restore it\n        const creditProjections = projectionsWithBalance.map((proj)=>{\n            // Find debt repayments for this month that will free up credit\n            const monthRepayments = proj.debt_payments.reduce((sum, p)=>sum + p.amount, 0);\n            // Scenario debt drawdown reduces credit (negative effect)\n            const monthScenarioDrawdown = proj.scenario_debt_drawdown || 0;\n            // Scenario debt repayment restores credit (positive effect)\n            const monthScenarioRepayment = proj.scenario_debt_repayment || 0;\n            return {\n                month: proj.month,\n                month_label: proj.month_label,\n                repayment_amount: monthRepayments,\n                scenario_drawdown: monthScenarioDrawdown,\n                scenario_repayment: monthScenarioRepayment\n            };\n        });\n        // Calculate cumulative credit changes over projection period\n        let cumulativeRepayments = 0;\n        let cumulativeScenarioDrawdowns = 0;\n        let cumulativeScenarioRepayments = 0;\n        const creditAvailabilityProjection = creditProjections.map((proj)=>{\n            cumulativeRepayments += proj.repayment_amount;\n            cumulativeScenarioDrawdowns += proj.scenario_drawdown;\n            cumulativeScenarioRepayments += proj.scenario_repayment;\n            // Net effect: actual repayments free credit, scenario drawdowns use it, scenario repayments restore it\n            const netCreditChange = cumulativeRepayments - cumulativeScenarioDrawdowns + cumulativeScenarioRepayments;\n            return {\n                month: proj.month,\n                month_label: proj.month_label,\n                available_credit: totalCreditAvailable + netCreditChange,\n                repayment_this_month: proj.repayment_amount,\n                scenario_drawdown_this_month: proj.scenario_drawdown,\n                scenario_repayment_this_month: proj.scenario_repayment,\n                cumulative_repayments: cumulativeRepayments,\n                cumulative_scenario_drawdowns: cumulativeScenarioDrawdowns,\n                cumulative_scenario_repayments: cumulativeScenarioRepayments\n            };\n        });\n        console.log(`[Cash Flow 3.0] Credit lines: ${creditLines.length}, total available: ${totalCreditAvailable.toLocaleString()} VND`);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            data: {\n                current_balance: currentBalance,\n                months_ahead: monthsAhead,\n                total_obligations: totalObligations,\n                total_projected_income: totalProjectedIncome,\n                net_projected_change: totalProjectedIncome - totalObligations,\n                lowest_projected_balance: lowestBalance,\n                months_until_negative: monthsUntilNegative === -1 ? null : monthsUntilNegative + 1,\n                projections: projectionsWithBalance,\n                // NEW in v3.0: Liquidity & Solvency Analysis\n                liquidity: liquidityPosition,\n                runway: runwayAnalysis,\n                // NEW in v3.1: Credit Line Analysis\n                credit_lines: {\n                    accounts: creditLines,\n                    total_limit: totalCreditLimit,\n                    total_used: totalCreditUsed,\n                    total_available: totalCreditAvailable,\n                    overall_utilization: totalCreditLimit > 0 ? totalCreditUsed / totalCreditLimit * 100 : 0,\n                    availability_projection: creditAvailabilityProjection,\n                    // NEW: Scenario impact on credit\n                    scenario_debt_drawdown: totalScenarioDebtDrawdown,\n                    scenario_adjusted_available: totalCreditAvailable - totalScenarioDebtDrawdown\n                },\n                // NEW in v3.1: Scenario info (if applied)\n                scenario: scenarioInfo,\n                version: \"3.0\" // Mark this as v3.0 response\n            }\n        });\n    } catch (error) {\n        console.error(\"Unexpected error:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: \"Internal server error\"\n        }, {\n            status: 500\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9hcHAvYXBpL2Nhc2gtZmxvdy1wcm9qZWN0aW9uL3JvdXRlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Q0FRQyxHQUVzRDtBQUNXO0FBQ21DO0FBUXBFO0FBK0JqQyxxREFBcUQ7QUFDckQsU0FBU2MseUJBQ1BDLFFBQWdCLEVBQ2hCQyxVQUFrQixFQUNsQkMscUJBQTZCLEVBQzdCQyxXQUFpQztJQVVqQyxJQUFJQyxpQkFBaUJIO0lBQ3JCLElBQUlJLG9CQUFvQkg7SUFDeEIsSUFBSUksdUJBQXVCLEVBQUUsa0NBQWtDOztJQUMvRCxJQUFJQyx3QkFBd0IsRUFBRSxtQ0FBbUM7O0lBQ2pFLElBQUlDLGlCQUFpQixFQUFFLGtDQUFrQzs7SUFDekQsSUFBSUMsa0JBQWtCLEVBQUUsbUNBQW1DOztJQUMzRCxNQUFNQyxnQkFBa0UsRUFBRTtJQUUxRSxNQUFNQyxZQUFZcEIsK0lBQVFBLENBQUMsQ0FBQyxFQUFFUyxTQUFTLEdBQUcsQ0FBQztJQUUzQyxLQUFLLE1BQU1ZLE9BQU9ULFlBQWE7UUFDN0IsNENBQTRDO1FBQzVDLE1BQU1VLGFBQWFELElBQUlFLFdBQVcsR0FBR3ZCLCtJQUFRQSxDQUFDcUIsSUFBSUUsV0FBVyxJQUFJO1FBQ2pFLE1BQU1DLFdBQVdILElBQUlJLFNBQVMsR0FBR3pCLCtJQUFRQSxDQUFDcUIsSUFBSUksU0FBUyxJQUFJO1FBRTNELE1BQU1DLG1CQUFtQixDQUFDSixjQUFjQSxjQUFjRjtRQUN0RCxNQUFNTyxnQkFBZ0IsQ0FBQ0gsWUFBWUEsWUFBWUo7UUFFL0Msd0RBQXdEO1FBQ3hELG9FQUFvRTtRQUNwRSxNQUFNUSxZQUFZUCxJQUFJUSxlQUFlLENBQUNDLFVBQVUsQ0FBQyxlQUFlVCxJQUFJUSxlQUFlLEtBQUs7UUFDeEYsTUFBTUUsZUFBZUgsWUFDaEJOLGNBQWN2Qiw2SUFBTUEsQ0FBQ3VCLFlBQVksZUFBZWIsV0FDaERpQixvQkFBb0JDO1FBRXpCLHVFQUF1RTtRQUN2RSxJQUFJTixJQUFJUSxlQUFlLEtBQUssbUJBQW1CUixJQUFJVyxNQUFNLElBQUlYLElBQUlZLFFBQVEsRUFBRUMsaUJBQWlCO1lBQzFGLE1BQU1DLGlCQUFpQmQsSUFBSVksUUFBUSxDQUFDQyxlQUFlO1lBQ25ELElBQUlDLG1CQUFtQjFCLFVBQVU7Z0JBQy9CLDBEQUEwRDtnQkFDMURLLHFCQUFxQk8sSUFBSVcsTUFBTTtnQkFDL0JoQix5QkFBeUJLLElBQUlXLE1BQU07Z0JBQ25DYixjQUFjaUIsSUFBSSxDQUFDO29CQUNqQkMsTUFBTSxDQUFDLEVBQUVoQixJQUFJZ0IsSUFBSSxDQUFDLFlBQVksQ0FBQztvQkFDL0JMLFFBQVEsQ0FBQ1gsSUFBSVcsTUFBTTtvQkFDbkJNLE1BQU07Z0JBQ1I7Z0JBQ0FDLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHVDQUF1QyxFQUFFbkIsSUFBSVcsTUFBTSxDQUFDLFVBQVUsRUFBRXZCLFNBQVMsQ0FBQztZQUN6RjtRQUNGO1FBRUEsSUFBSSxDQUFDc0IsY0FBYztRQUVuQlEsUUFBUUMsR0FBRyxDQUFDLENBQUMsMEJBQTBCLEVBQUVuQixJQUFJUSxlQUFlLENBQUMsRUFBRSxFQUFFUixJQUFJZ0IsSUFBSSxDQUFDLFdBQVcsRUFBRTVCLFNBQVMsQ0FBQztRQUVqRyxPQUFRWSxJQUFJUSxlQUFlO1lBQ3pCLEtBQUs7WUFDTCxLQUFLO2dCQUNILElBQUlSLElBQUlXLE1BQU0sRUFBRTtvQkFDZG5CLGtCQUFrQlEsSUFBSVcsTUFBTTtvQkFDNUJmLGtCQUFrQkksSUFBSVcsTUFBTTtvQkFDNUJiLGNBQWNpQixJQUFJLENBQUM7d0JBQ2pCQyxNQUFNaEIsSUFBSWdCLElBQUk7d0JBQ2RMLFFBQVFYLElBQUlXLE1BQU07d0JBQ2xCTSxNQUFNO29CQUNSO2dCQUNGO2dCQUNBO1lBRUYsS0FBSztZQUNMLEtBQUs7Z0JBQ0gsSUFBSWpCLElBQUlXLE1BQU0sRUFBRTtvQkFDZGxCLHFCQUFxQk8sSUFBSVcsTUFBTTtvQkFDL0JkLG1CQUFtQkcsSUFBSVcsTUFBTTtvQkFDN0JiLGNBQWNpQixJQUFJLENBQUM7d0JBQ2pCQyxNQUFNaEIsSUFBSWdCLElBQUk7d0JBQ2RMLFFBQVEsQ0FBQ1gsSUFBSVcsTUFBTTt3QkFDbkJNLE1BQU07b0JBQ1I7Z0JBQ0Y7Z0JBQ0E7WUFFRixLQUFLO2dCQUNILHVFQUF1RTtnQkFDdkUsSUFBSWpCLElBQUlXLE1BQU0sRUFBRTtvQkFDZG5CLGtCQUFrQlEsSUFBSVcsTUFBTTtvQkFDNUJqQix3QkFBd0JNLElBQUlXLE1BQU0sQ0FBQyxvQkFBb0I7O29CQUN2RGIsY0FBY2lCLElBQUksQ0FBQzt3QkFDakJDLE1BQU1oQixJQUFJZ0IsSUFBSTt3QkFDZEwsUUFBUVgsSUFBSVcsTUFBTTt3QkFDbEJNLE1BQU07b0JBQ1I7b0JBQ0FDLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHNDQUFzQyxFQUFFbkIsSUFBSVcsTUFBTSxDQUFDLFVBQVUsRUFBRXZCLFNBQVMsQ0FBQztnQkFDeEY7Z0JBQ0E7WUFFRixLQUFLO2dCQUNILGdEQUFnRDtnQkFDaEQsSUFBSVksSUFBSW9CLFVBQVUsS0FBSyxNQUFNO29CQUMzQixNQUFNQyxTQUFTL0Isd0JBQXlCVSxDQUFBQSxJQUFJb0IsVUFBVSxHQUFHLEdBQUU7b0JBQzNEM0IscUJBQXFCNEI7b0JBQ3JCeEIsbUJBQW1Cd0I7b0JBQ25CdkIsY0FBY2lCLElBQUksQ0FBQzt3QkFDakJDLE1BQU1oQixJQUFJZ0IsSUFBSTt3QkFDZEwsUUFBUVU7d0JBQ1JKLE1BQU07b0JBQ1I7Z0JBQ0Y7Z0JBQ0E7WUFFRixLQUFLO2dCQUNILG9DQUFvQztnQkFDcEMsSUFBSWpCLElBQUlvQixVQUFVLEtBQUssTUFBTTtvQkFDM0IsTUFBTUMsU0FBU2hDLGFBQWNXLENBQUFBLElBQUlvQixVQUFVLEdBQUcsR0FBRTtvQkFDaEQ1QixrQkFBa0I2QjtvQkFDbEJ6QixrQkFBa0J5QjtvQkFDbEJ2QixjQUFjaUIsSUFBSSxDQUFDO3dCQUNqQkMsTUFBTWhCLElBQUlnQixJQUFJO3dCQUNkTCxRQUFRVTt3QkFDUkosTUFBTTtvQkFDUjtnQkFDRjtnQkFDQTtRQUNKO0lBQ0Y7SUFFQSxPQUFPO1FBQUV6QjtRQUFnQkM7UUFBbUJDO1FBQXNCQztRQUF1QkM7UUFBZ0JDO1FBQWlCQztJQUFjO0FBQzFJO0FBRU8sZUFBZXdCLElBQUlDLE9BQW9CO0lBQzVDLE1BQU1DLFdBQVdsRCxnRkFBMEJBO0lBQzNDLE1BQU1tRCxlQUFlRixRQUFRRyxPQUFPLENBQUNELFlBQVk7SUFFakQsTUFBTUUsV0FBV0YsYUFBYUcsR0FBRyxDQUFDO0lBQ2xDLE1BQU1DLGNBQWNDLFNBQVNMLGFBQWFHLEdBQUcsQ0FBQyxtQkFBbUI7SUFDakUsTUFBTUcsYUFBYU4sYUFBYUcsR0FBRyxDQUFDLGVBQWUseUJBQXlCOztJQUU1RSxJQUFJLENBQUNELFVBQVU7UUFDYixPQUFPdEQscURBQVlBLENBQUMyRCxJQUFJLENBQ3RCO1lBQUVDLE9BQU87UUFBd0IsR0FDakM7WUFBRUMsUUFBUTtRQUFJO0lBRWxCO0lBRUEsSUFBSTtRQUNGLCtDQUErQztRQUMvQyxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsSUFBSSxFQUFFLEVBQUVILE9BQU9JLFNBQVMsRUFBRSxHQUFHLE1BQU1iLFNBQVNjLElBQUksQ0FBQ0MsT0FBTztRQUN4RSxJQUFJRixhQUFhLENBQUNELE1BQU07WUFDdEIsT0FBTy9ELHFEQUFZQSxDQUFDMkQsSUFBSSxDQUN0QjtnQkFBRUMsT0FBTztZQUFlLEdBQ3hCO2dCQUFFQyxRQUFRO1lBQUk7UUFFbEI7UUFFQSxrQ0FBa0M7UUFDbEMsTUFBTSxFQUFFQyxNQUFNSyxVQUFVLEVBQUVQLE9BQU9RLFNBQVMsRUFBRSxHQUFHLE1BQU1qQixTQUNsRGtCLElBQUksQ0FBQyxnQkFDTEMsTUFBTSxDQUFDLFFBQ1BDLEVBQUUsQ0FBQyxhQUFhakIsVUFDaEJpQixFQUFFLENBQUMsV0FBV1IsS0FBS1MsRUFBRSxFQUNyQkMsTUFBTTtRQUVULElBQUlMLGFBQWEsQ0FBQ0QsWUFBWTtZQUM1QixPQUFPbkUscURBQVlBLENBQUMyRCxJQUFJLENBQ3RCO2dCQUFFQyxPQUFPO1lBQXdDLEdBQ2pEO2dCQUFFQyxRQUFRO1lBQUk7UUFFbEI7UUFFQSx1Q0FBdUM7UUFDdkMsTUFBTSxFQUFFQyxNQUFNWSxnQkFBZ0IsRUFBRSxHQUFHLE1BQU12QixTQUN0Q2tCLElBQUksQ0FBQyxvQkFDTEMsTUFBTSxDQUFDLHNCQUNQQyxFQUFFLENBQUMsYUFBYWpCLFVBQ2hCaUIsRUFBRSxDQUFDLFFBQVFKLFdBQVdRLElBQUksRUFDMUJGLE1BQU07UUFFVCx1Q0FBdUM7UUFDdkMsMENBQTBDO1FBQzFDLE1BQU1HLGdCQUF3QztZQUM1QyxTQUFTO1lBQ1QsU0FBUztZQUNULFVBQVU7WUFDVixjQUFjO1lBQ2QsVUFBVTtRQUNaO1FBQ0EsTUFBTUMsZ0JBQWdCRCxhQUFhLENBQUNULFdBQVdRLElBQUksQ0FBQyxJQUFJO1FBQ3hELE1BQU1HLHlCQUF5QkQsaUJBQWlCLEVBQUUsZUFBZTs7UUFFakUsc0RBQXNEO1FBQ3RELE1BQU1FLGtCQUFrQkwsa0JBQWtCTSx1QkFBdUIsUUFBUU4sa0JBQWtCTSx1QkFBdUJDLFlBQzlHUCxpQkFBaUJNLGtCQUFrQixHQUNuQ0Y7UUFFSixJQUFJLENBQUNDLGlCQUFpQjtZQUNwQixPQUFPL0UscURBQVlBLENBQUMyRCxJQUFJLENBQ3RCO2dCQUFFQyxPQUFPO1lBQTJELEdBQ3BFO2dCQUFFQyxRQUFRO1lBQUk7UUFFbEI7UUFFQSxNQUFNcUIsWUFBWWhGLG1KQUFZQSxDQUFDLElBQUlpRjtRQUNuQyxNQUFNQyxVQUFVakYsaUpBQVVBLENBQUNDLGdKQUFTQSxDQUFDOEUsV0FBVzFCLGNBQWM7UUFFOUQscURBQXFEO1FBQ3JELElBQUk2QixzQkFBNEMsRUFBRTtRQUNsRCxJQUFJQyxlQUF1RDtRQUUzRCxJQUFJNUIsWUFBWTtZQUNkYixRQUFRQyxHQUFHLENBQUMsQ0FBQyxtQ0FBbUMsRUFBRVksV0FBVyxZQUFZLEVBQUVKLFNBQVMsQ0FBQztZQUNyRixNQUFNLEVBQUVRLE1BQU15QixRQUFRLEVBQUUzQixPQUFPNEIsYUFBYSxFQUFFLEdBQUcsTUFBTXJDLFNBQ3BEa0IsSUFBSSxDQUFDLHNCQUNMQyxNQUFNLENBQUMsQ0FBQzs7OztRQUlULENBQUMsRUFDQUMsRUFBRSxDQUFDLGVBQWViLFlBQ2xCYSxFQUFFLENBQUMsYUFBYWpCLFVBQ2hCbUIsTUFBTTtZQUVULElBQUllLGVBQWU7Z0JBQ2pCM0MsUUFBUWUsS0FBSyxDQUFDLDZDQUE2QzRCO1lBQzdEO1lBRUEsSUFBSSxDQUFDQSxpQkFBaUJELFVBQVU7Z0JBQzlCRCxlQUFlO29CQUFFM0MsTUFBTTRDLFNBQVM1QyxJQUFJO29CQUFFOEMsT0FBT0YsU0FBU0UsS0FBSztnQkFBQztnQkFDNURKLHNCQUFzQkUsU0FBU3JFLFdBQVcsSUFBSSxFQUFFO2dCQUNoRDJCLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLGlDQUFpQyxFQUFFeUMsU0FBUzVDLElBQUksQ0FBQyxlQUFlLEVBQUUwQyxvQkFBb0JLLE1BQU0sQ0FBQyxDQUFDO2dCQUMzRzdDLFFBQVFDLEdBQUcsQ0FBQyxpQ0FBaUM2QyxLQUFLQyxTQUFTLENBQUNQLHFCQUFxQixNQUFNO1lBQ3pGO1FBQ0Y7UUFFQSwwQkFBMEI7UUFDMUIsTUFBTVEsU0FBU3RGLDBKQUFtQkEsQ0FBQztZQUFFdUYsT0FBT1o7WUFBV2EsS0FBS1g7UUFBUTtRQUVwRSxnRUFBZ0U7UUFDaEUsK0RBQStEO1FBQy9ELE1BQU0sRUFBRXRCLE1BQU1rQyxhQUFhLEVBQUVwQyxPQUFPcUMsaUJBQWlCLEVBQUUsR0FBRyxNQUFNOUMsU0FDN0RrQixJQUFJLENBQUMsaUJBQ0xDLE1BQU0sQ0FBQyxDQUFDOzs7Ozs7O01BT1QsQ0FBQyxFQUNBQyxFQUFFLENBQUMsc0JBQXNCakIsVUFDekJpQixFQUFFLENBQUMsVUFBVSxVQUNiMkIsR0FBRyxDQUFDLFlBQVksTUFBTSxNQUN0QkMsR0FBRyxDQUFDLFlBQVk5Riw2SUFBTUEsQ0FBQzZFLFdBQVcsZUFDbENrQixHQUFHLENBQUMsWUFBWS9GLDZJQUFNQSxDQUFDK0UsU0FBUyxlQUNoQ2lCLEtBQUssQ0FBQyxZQUFZO1lBQUVDLFdBQVc7UUFBSztRQUV2QyxJQUFJTCxtQkFBbUI7WUFDckJwRCxRQUFRZSxLQUFLLENBQUMsa0NBQWtDcUM7UUFDbEQ7UUFFQSxpRkFBaUY7UUFDakYsTUFBTSxFQUFFbkMsTUFBTXlDLGVBQWUsRUFBRTNDLE9BQU80QyxTQUFTLEVBQUUsR0FBRyxNQUFNckQsU0FDdkRrQixJQUFJLENBQUMscUJBQ0xDLE1BQU0sQ0FBQyxDQUFDOzs7Ozs7TUFNVCxDQUFDLEVBQ0FDLEVBQUUsQ0FBQyxzQkFBc0JqQixVQUN6QmlCLEVBQUUsQ0FBQyxVQUFVLFVBQ2IyQixHQUFHLENBQUMsWUFBWSxNQUFNLE1BQ3RCQyxHQUFHLENBQUMsWUFBWTlGLDZJQUFNQSxDQUFDNkUsV0FBVyxlQUNsQ2tCLEdBQUcsQ0FBQyxZQUFZL0YsNklBQU1BLENBQUMrRSxTQUFTLGVBQ2hDaUIsS0FBSyxDQUFDLFlBQVk7WUFBRUMsV0FBVztRQUFLO1FBRXZDLElBQUlFLFdBQVc7WUFDYjNELFFBQVFlLEtBQUssQ0FBQyxvQ0FBb0M0QztRQUNwRDtRQUVBLGtEQUFrRDtRQUNsRCxNQUFNLEVBQUUxQyxNQUFNMkMsa0JBQWtCLEVBQUU3QyxPQUFPOEMsY0FBYyxFQUFFLEdBQUcsTUFBTXZELFNBQy9Ea0IsSUFBSSxDQUFDLCtCQUNMQyxNQUFNLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7O01BWVQsQ0FBQyxFQUNBQyxFQUFFLENBQUMsZ0NBQWdDakIsVUFDbkNxRCxFQUFFLENBQUMsVUFBVTtZQUFDO1lBQVc7U0FBVSxFQUFFLGdDQUFnQztTQUNyRVIsR0FBRyxDQUFDLFlBQVk5Riw2SUFBTUEsQ0FBQzZFLFdBQVcsZUFDbENrQixHQUFHLENBQUMsWUFBWS9GLDZJQUFNQSxDQUFDK0UsU0FBUyxlQUNoQ2lCLEtBQUssQ0FBQyxZQUFZO1lBQUVDLFdBQVc7UUFBSztRQUV2Qyw2Q0FBNkM7UUFDN0MsTUFBTSxFQUFFeEMsTUFBTThDLFlBQVksRUFBRSxHQUFHLE1BQU16RCxTQUNsQ2tCLElBQUksQ0FBQywrQkFDTEMsTUFBTSxDQUFDLENBQUM7Ozs7Ozs7Ozs7OztNQVlULENBQUMsRUFDQUMsRUFBRSxDQUFDLGdDQUFnQ2pCLFVBQ25DNkMsR0FBRyxDQUFDLFlBQVk5Riw2SUFBTUEsQ0FBQzZFLFdBQVcsZUFDbENrQixHQUFHLENBQUMsWUFBWS9GLDZJQUFNQSxDQUFDK0UsU0FBUztRQUVuQyxNQUFNeUIsb0JBQW9CRCxjQUFjRSxPQUFPLENBQUNDLEtBQUtDLElBQU1ELE1BQU9DLENBQUFBLEVBQUUxRSxNQUFNLElBQUksSUFBSSxNQUFNO1FBQ3hGLE1BQU0yRSx1QkFBdUJSLG9CQUFvQkssT0FBTyxDQUFDQyxLQUFLQyxJQUFNRCxNQUFPQyxDQUFBQSxFQUFFMUUsTUFBTSxJQUFJLElBQUksTUFBTTtRQUNqR08sUUFBUUMsR0FBRyxDQUFDLENBQUMsNkJBQTZCLEVBQUU4RCxjQUFjbEIsT0FBTyxHQUFHLEVBQUVtQixrQkFBa0JLLGNBQWMsR0FBRyxJQUFJLENBQUM7UUFDOUdyRSxRQUFRQyxHQUFHLENBQUMsQ0FBQyxnQ0FBZ0MsRUFBRTJELG9CQUFvQmYsT0FBTyxHQUFHLEVBQUV1QixxQkFBcUJDLGNBQWMsR0FBRyxJQUFJLENBQUM7UUFDMUhyRSxRQUFRQyxHQUFHLENBQUMsQ0FBQyxvQkFBb0IsRUFBRSxDQUFDK0Qsb0JBQW9CSSxvQkFBbUIsRUFBR0MsY0FBYyxHQUFHLElBQUksQ0FBQztRQUVwRyxJQUFJUixnQkFBZ0I7WUFDbEI3RCxRQUFRZSxLQUFLLENBQUMsc0NBQXNDOEM7UUFDdEQ7UUFFQSx1QkFBdUI7UUFDdkIsTUFBTSxFQUFFNUMsTUFBTXFELE9BQU8sRUFBRXZELE9BQU93RCxZQUFZLEVBQUUsR0FBRyxNQUFNakUsU0FDbERrQixJQUFJLENBQUMsb0JBQ0xDLE1BQU0sQ0FBQyxDQUFDOzs7OztNQUtULENBQUMsRUFDQUMsRUFBRSxDQUFDLGFBQWFqQixVQUNoQmlCLEVBQUUsQ0FBQyxhQUFhLE1BQ2hCNEIsR0FBRyxDQUFDLFlBQVk5Riw2SUFBTUEsQ0FBQzZFLFdBQVcsZUFDbENtQixLQUFLLENBQUMsY0FBYztZQUFFQyxXQUFXO1FBQUs7UUFFekMsSUFBSWMsY0FBYztZQUNoQnZFLFFBQVFlLEtBQUssQ0FBQywyQkFBMkJ3RDtRQUMzQztRQUVBLG9FQUFvRTtRQUNwRSxtRkFBbUY7UUFDbkYsTUFBTSxFQUFFdEQsTUFBTXVELFFBQVEsRUFBRXpELE9BQU8wRCxhQUFhLEVBQUMsR0FBRyxNQUFNbkUsU0FDbkRrQixJQUFJLENBQUMsWUFDTEMsTUFBTSxDQUFDLDBDQUNQQyxFQUFFLENBQUMsYUFBYWpCLFVBQ2hCaUIsRUFBRSxDQUFDLGFBQWEsTUFDaEJvQyxFQUFFLENBQUMsZ0JBQWdCO1lBQUM7WUFBUTtZQUFRO1NBQWEsRUFBRSw2QkFBNkI7O1FBRW5GLElBQUlXLGVBQWU7WUFDakJ6RSxRQUFRZSxLQUFLLENBQUMsNEJBQTRCMEQ7UUFDNUM7UUFFQSx5REFBeUQ7UUFDekQsTUFBTSxFQUFFeEQsTUFBTXlELGtCQUFrQixFQUFFM0QsT0FBTzRELGVBQWUsRUFBRSxHQUFHLE1BQU1yRSxTQUNoRWtCLElBQUksQ0FBQyxZQUNMQyxNQUFNLENBQUMscURBQ1BDLEVBQUUsQ0FBQyxhQUFhakIsVUFDaEJpQixFQUFFLENBQUMsYUFBYSxNQUNoQm9DLEVBQUUsQ0FBQyxnQkFBZ0I7WUFBQztZQUFlO1NBQVksRUFDL0NULEdBQUcsQ0FBQyxnQkFBZ0IsTUFBTTtRQUU3QixJQUFJc0IsaUJBQWlCO1lBQ25CM0UsUUFBUWUsS0FBSyxDQUFDLGdDQUFnQzREO1FBQ2hEO1FBRUEsd0VBQXdFO1FBQ3hFLE1BQU1DLGNBQWMsTUFBTUMsUUFBUUMsR0FBRyxDQUFDLENBQUNKLHNCQUFzQixFQUFFLEVBQUVLLEdBQUcsQ0FBQyxPQUFPQztZQUMxRSxNQUFNLEVBQUUvRCxNQUFNZ0UsU0FBUyxFQUFFLEdBQUcsTUFBTTNFLFNBQy9Ca0IsSUFBSSxDQUFDLGlCQUNMQyxNQUFNLENBQUMscUJBQ1BDLEVBQUUsQ0FBQyxjQUFjc0QsUUFBUUUsVUFBVSxFQUNuQ3BCLEVBQUUsQ0FBQyxVQUFVO2dCQUFDO2dCQUFVO2FBQVU7WUFFckMsTUFBTXFCLGFBQWFGLFdBQVdoQixPQUFPLENBQUNDLEtBQUtrQixJQUFNbEIsTUFBT2tCLENBQUFBLEVBQUVDLGlCQUFpQixJQUFJLElBQUksTUFBTTtZQUN6RixNQUFNQyxjQUFjTixRQUFRTyxZQUFZLElBQUk7WUFDNUMsTUFBTUMsa0JBQWtCRixjQUFjSDtZQUV0QyxPQUFPO2dCQUNMRCxZQUFZRixRQUFRRSxVQUFVO2dCQUM5Qk8sY0FBY1QsUUFBUVMsWUFBWTtnQkFDbENDLFdBQVdWLFFBQVFVLFNBQVM7Z0JBQzVCSCxjQUFjRDtnQkFDZEssYUFBYVI7Z0JBQ2JTLGtCQUFrQko7Z0JBQ2xCSyxxQkFBcUJQLGNBQWMsSUFBSSxhQUFjQSxjQUFlLE1BQU07WUFDNUU7UUFDRjtRQUVBLDJDQUEyQztRQUMzQyxNQUFNUSxtQkFBbUJsQixZQUFZWCxNQUFNLENBQUMsQ0FBQ0MsS0FBSzZCLEtBQU83QixNQUFNNkIsR0FBR1IsWUFBWSxFQUFFO1FBQ2hGLE1BQU1TLGtCQUFrQnBCLFlBQVlYLE1BQU0sQ0FBQyxDQUFDQyxLQUFLNkIsS0FBTzdCLE1BQU02QixHQUFHSixXQUFXLEVBQUU7UUFDOUUsTUFBTU0sdUJBQXVCSCxtQkFBbUJFO1FBRWhEaEcsUUFBUUMsR0FBRyxDQUFDLENBQUMsa0JBQWtCLEVBQUV1RSxVQUFVM0IsVUFBVSxFQUFFLDBDQUEwQyxFQUFFcEMsU0FBUyxDQUFDO1FBQzdHVCxRQUFRQyxHQUFHLENBQUMsQ0FBQyxzQkFBc0IsRUFBRXVFLFVBQVVPLElBQUltQixDQUFBQSxJQUFLLENBQUMsRUFBRUEsRUFBRVQsWUFBWSxDQUFDLENBQUMsRUFBRVMsRUFBRUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUFFQyxLQUFLLE1BQU0sQ0FBQztRQUU1RyxNQUFNQyxhQUFhN0IsVUFBVU8sSUFBSW1CLENBQUFBLElBQUtBLEVBQUVoQixVQUFVLEtBQUssRUFBRTtRQUV6RCx3REFBd0Q7UUFDeEQsSUFBSW9CLGlCQUFpQjtRQUNyQixJQUFJRCxXQUFXeEQsTUFBTSxHQUFHLEdBQUc7WUFDekIsaURBQWlEO1lBQ2pELE1BQU0wRCxRQUFRLElBQUlqRTtZQUNsQixLQUFLLE1BQU0wQyxXQUFZUixZQUFZLEVBQUUsQ0FBRztnQkFDdEMsTUFBTSxFQUFFdkQsTUFBTXVGLE9BQU8sRUFBRXpGLE9BQU8wRixZQUFZLEVBQUUsR0FBRyxNQUFNbkcsU0FBU29HLEdBQUcsQ0FBQyxnQ0FBZ0M7b0JBQ2hHQyxjQUFjM0IsUUFBUUUsVUFBVTtvQkFDaEMwQixjQUFjTCxNQUFNTSxXQUFXLEdBQUdDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDakQ7Z0JBQ0EsSUFBSUwsY0FBYztvQkFDaEJ6RyxRQUFRZSxLQUFLLENBQUMsQ0FBQywwQ0FBMEMsRUFBRWlFLFFBQVFTLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBRTNDLEtBQUtDLFNBQVMsQ0FBQzBEO2dCQUNyRztnQkFDQXpHLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLFlBQVksRUFBRStFLFFBQVFTLFlBQVksQ0FBQyxFQUFFLEVBQUVULFFBQVFtQixZQUFZLENBQUMsV0FBVyxFQUFFSyxXQUFXLEVBQUUsQ0FBQztnQkFDcEdGLGtCQUFtQkUsV0FBVztZQUNoQztRQUNGO1FBQ0F4RyxRQUFRQyxHQUFHLENBQUMsQ0FBQywrREFBK0QsRUFBRXFHLGVBQWUsQ0FBQztRQUU5RixpRkFBaUY7UUFDakYsTUFBTSxFQUFFUyxPQUFPQyxzQkFBc0IsRUFBRUMsV0FBV0MsZUFBZSxFQUFFLEdBQUcsTUFBTXZKLGlGQUF3QkEsQ0FBQzhDO1FBRXJHVCxRQUFRQyxHQUFHLENBQUMsQ0FBQywwQ0FBMEMsRUFBRStHLHVCQUF1QjNDLGNBQWMsR0FBRyxJQUFJLENBQUM7UUFDdEdyRSxRQUFRQyxHQUFHLENBQUMsQ0FBQyxnQ0FBZ0MsRUFBRWlILGdCQUFnQnJFLE1BQU0sQ0FBQyxDQUFDO1FBRXZFLDRCQUE0QjtRQUM1QixNQUFNc0UsY0FBYyxNQUFNdEMsUUFBUUMsR0FBRyxDQUFDOUIsT0FBTytCLEdBQUcsQ0FBQyxPQUFPcUM7WUFDdEQsTUFBTWxKLFdBQVdWLDZJQUFNQSxDQUFDNEosT0FBTztZQUMvQixNQUFNQyxhQUFhaEssbUpBQVlBLENBQUMrSjtZQUNoQyxNQUFNRSxXQUFXaEssaUpBQVVBLENBQUM4SjtZQUU1QixpRUFBaUU7WUFDakUsTUFBTUcsb0JBQW9CLENBQUNwRSxpQkFBaUIsRUFBRSxFQUFFcUUsTUFBTSxDQUFDLENBQUNDO2dCQUN0RCxNQUFNQyxVQUFVakssK0lBQVFBLENBQUNnSyxTQUFTRSxRQUFRO2dCQUMxQyxPQUFPRCxXQUFXTCxjQUFjSyxXQUFXSjtZQUM3QyxHQUFHdkMsR0FBRyxDQUFDLENBQUMwQyxXQUFtQjtvQkFDekIxSCxNQUFNO29CQUNONkgsV0FBV0gsU0FBU2pELFFBQVEsRUFBRWlCLGdCQUFnQjtvQkFDOUNvQyxvQkFBb0JKLFNBQVNJLGtCQUFrQixJQUFJO29CQUNuRHBJLFFBQVFnSSxTQUFTcEMsaUJBQWlCLElBQUk7b0JBQ3RDc0MsVUFBVUYsU0FBU0UsUUFBUTtvQkFDM0IzRyxRQUFReUcsU0FBU3pHLE1BQU07b0JBQ3ZCbUYsY0FBY3NCLFNBQVNqRCxRQUFRLEVBQUUyQixnQkFBZ0I7Z0JBQ25EO1lBRUEseUNBQXlDO1lBQ3pDLE1BQU0yQix5QkFBeUIsQ0FBQ2xFLHNCQUFzQixFQUFFLEVBQUU0RCxNQUFNLENBQUMsQ0FBQ087Z0JBQ2hFLE1BQU1MLFVBQVVqSywrSUFBUUEsQ0FBQ3NLLFNBQVNKLFFBQVE7Z0JBQzFDLE9BQU9ELFdBQVdMLGNBQWNLLFdBQVdKO1lBQzdDLEdBQUd2QyxHQUFHLENBQUMsQ0FBQ2dELFdBQW1CO29CQUN6QkMsZUFBZUQsU0FBU0Usa0JBQWtCLEVBQUVELGlCQUFpQjtvQkFDN0RFLGNBQWNILFNBQVNFLGtCQUFrQixFQUFFQztvQkFDM0NDLFlBQVlKLFNBQVNFLGtCQUFrQixFQUFFRSxjQUFjO29CQUN2RDFJLFFBQVFzSSxTQUFTdEksTUFBTSxJQUFJO29CQUMzQmtJLFVBQVVJLFNBQVNKLFFBQVE7b0JBQzNCM0csUUFBUStHLFNBQVMvRyxNQUFNO29CQUN2Qm9ILGFBQWFMLFNBQVNFLGtCQUFrQixFQUFFRztvQkFDMUNDLGVBQWVOLFNBQVNFLGtCQUFrQixFQUFFSyxZQUFZRCxpQkFBaUI7Z0JBQzNFO1lBRUEseURBQXlEO1lBQ3pELGdFQUFnRTtZQUNoRSxNQUFNRSxvQkFBb0IsTUFBTTNLLG1GQUEwQkEsQ0FBQzZDLFVBQVV2QztZQUVyRSxNQUFNc0ssaUJBQWlCRCxrQkFBa0J0RSxNQUFNLENBQUMsQ0FBQ0MsS0FBS3VFLE1BQVF2RSxNQUFNdUUsSUFBSWhKLE1BQU0sRUFBRTtZQUVoRixvRkFBb0Y7WUFDcEYsaUNBQWlDO1lBQ2pDLE1BQU1pSix1QkFBdUIsTUFBTTVLLDJGQUFrQ0EsQ0FBQzJDLFVBQVV2QztZQUNoRixNQUFNeUsseUJBQXlCLElBQUlDLElBQUlMLGtCQUFrQnhELEdBQUcsQ0FBQzBELENBQUFBLE1BQU9BLElBQUlKLGFBQWE7WUFFckYsTUFBTVEsZUFBZSxDQUFDdkUsV0FBVyxFQUFFLEVBQUVrRCxNQUFNLENBQUMsQ0FBQ3NCO2dCQUMzQyxNQUFNQyxjQUFjdEwsK0lBQVFBLENBQUNxTCxPQUFPRSxVQUFVO2dCQUM5QyxNQUFNQyxZQUFZeEwsK0lBQVFBLENBQUNxTCxPQUFPSSxRQUFRO2dCQUMxQyxNQUFNQyxhQUFhTCxPQUFPVixXQUFXO2dCQUNyQyxNQUFNZ0IsZUFBZU4sT0FBT1IsVUFBVSxFQUFFRCxpQkFBaUI7Z0JBRXpELDBCQUEwQjtnQkFDMUIsNEJBQTRCO2dCQUM1Qiw0Q0FBNEM7Z0JBQzVDLDRDQUE0QztnQkFDNUMsT0FBT1UsZUFBZXpCLFlBQ2YyQixhQUFhNUIsY0FDYixDQUFDcUIscUJBQXFCVyxHQUFHLENBQUNGLGVBQzFCLENBQUNSLHVCQUF1QlUsR0FBRyxDQUFDRDtZQUNyQyxHQUFHckUsR0FBRyxDQUFDLENBQUMrRCxTQUFpQjtvQkFDdkJULGVBQWVTLE9BQU9SLFVBQVUsRUFBRUQsaUJBQWlCO29CQUNuRGlCLGVBQWVSLE9BQU9RLGFBQWEsSUFBSTtvQkFDdkNDLGlCQUFpQlQsT0FBT1EsYUFBYSxJQUFJO2dCQUMzQztZQUVBLDBDQUEwQztZQUMxQyxNQUFNRSxhQUFhLENBQUNsRixXQUFXLEVBQUUsRUFDOUJrRCxNQUFNLENBQUMsQ0FBQ3NCO2dCQUNQLE1BQU1DLGNBQWN0TCwrSUFBUUEsQ0FBQ3FMLE9BQU9FLFVBQVU7Z0JBQzlDLE1BQU1DLFlBQVl4TCwrSUFBUUEsQ0FBQ3FMLE9BQU9JLFFBQVE7Z0JBQzFDLE9BQU9ILGVBQWV6QixZQUFZMkIsYUFBYTVCO1lBQ2pELEdBQ0N0QyxHQUFHLENBQUMsQ0FBQytELFNBQWlCO29CQUNyQlQsZUFBZVMsT0FBT1IsVUFBVSxFQUFFRCxpQkFBaUI7b0JBQ25EaUIsZUFBZVIsT0FBT1EsYUFBYSxJQUFJO2dCQUN6QztZQUVGLE1BQU1HLGlCQUFpQjVMLHVFQUFjQSxDQUFDMEssbUJBQW1CaUI7WUFFekQsbUJBQW1CO1lBQ25CLE1BQU1FLFlBQVluQyxrQkFBa0J0RCxNQUFNLENBQUMsQ0FBQ0MsS0FBYXlGLElBQVd6RixNQUFNeUYsRUFBRWxLLE1BQU0sRUFBRTtZQUNwRixNQUFNbUssaUJBQWlCOUIsdUJBQXVCN0QsTUFBTSxDQUFDLENBQUNDLEtBQWF5RixJQUFXekYsTUFBTXlGLEVBQUVsSyxNQUFNLEVBQUU7WUFDOUYsTUFBTW9LLGVBQWVoQixhQUFhNUUsTUFBTSxDQUFDLENBQUNDLEtBQWE0RixJQUFXNUYsTUFBTTRGLEVBQUVQLGVBQWUsRUFBRTtZQUMzRixNQUFNUSxtQkFBbUJMLFlBQVlFLGlCQUFpQnBCLGlCQUFpQnFCO1lBRXZFLE9BQU87Z0JBQ0x6QyxPQUFPbEo7Z0JBQ1A4TCxhQUFheE0sNklBQU1BLENBQUM0SixPQUFPO2dCQUMzQjZDLGVBQWUxQztnQkFDZlUsb0JBQW9CSDtnQkFDcEJvQyxvQkFBb0IzQjtnQkFDcEJqRSxTQUFTdUU7Z0JBQ1RzQixZQUFZVDtnQkFDWlUsaUJBQWlCUjtnQkFDakJTLGlCQUFpQjdCO2dCQUNqQjhCLGVBQWVUO2dCQUNmVSxtQkFBbUJSO2dCQUNuQlMsa0JBQWtCdEQ7Z0JBQ2xCdUQsaUJBQWlCaEI7WUFDbkI7UUFDRjtRQUVBLDBFQUEwRTtRQUMxRSxnRUFBZ0U7UUFDaEUsSUFBSWlCLGlCQUFpQnBFO1FBQ3JCLE1BQU1xRSx5QkFBeUJ4RCxZQUFZcEMsR0FBRyxDQUFDLENBQUM2RjtZQUM5QyxNQUFNQyxpQkFBaUJIO1lBQ3ZCLElBQUlJLGtCQUFrQjlELHVCQUF1Qiw0Q0FBNEM7O1lBQ3pGLElBQUkrRCw2QkFBNkJILEtBQUtQLGVBQWU7WUFFckQsNkJBQTZCO1lBQzdCLElBQUl6TCxnQkFBa0UsRUFBRTtZQUN4RSxJQUFJSix1QkFBdUI7WUFDM0IsSUFBSUMsd0JBQXdCO1lBQzVCLElBQUlDLGlCQUFpQjtZQUNyQixJQUFJQyxrQkFBa0I7WUFFdEIsSUFBSTZELG9CQUFvQkssTUFBTSxHQUFHLEdBQUc7Z0JBQ2xDLE1BQU1tSSxXQUFXL00seUJBQ2YyTSxLQUFLeEQsS0FBSyxFQUNWMEQsaUJBQ0FGLEtBQUtQLGVBQWUsRUFDcEI3SDtnQkFFRnNJLGtCQUFrQkUsU0FBUzFNLGNBQWM7Z0JBQ3pDeU0sNkJBQTZCQyxTQUFTek0saUJBQWlCO2dCQUN2REssZ0JBQWdCb00sU0FBU3BNLGFBQWE7Z0JBQ3RDSix1QkFBdUJ3TSxTQUFTeE0sb0JBQW9CO2dCQUNwREMsd0JBQXdCdU0sU0FBU3ZNLHFCQUFxQjtnQkFDdERDLGlCQUFpQnNNLFNBQVN0TSxjQUFjO2dCQUN4Q0Msa0JBQWtCcU0sU0FBU3JNLGVBQWU7WUFFNUM7WUFFQSwwREFBMEQ7WUFDMUQsTUFBTXNNLCtCQUErQkwsS0FBS1QsVUFBVSxHQUFHUyxLQUFLUixlQUFlLEdBQUdXLDZCQUE2QkgsS0FBS04sYUFBYTtZQUM3SCxNQUFNWSxpQkFBaUJMLGlCQUFpQkMsa0JBQWtCRztZQUMxRFAsaUJBQWlCUTtZQUVqQiwwQkFBMEI7WUFDMUIsSUFBSUM7WUFDSixJQUFJRCxpQkFBaUIsR0FBRztnQkFDdEJDLFNBQVM7WUFDWCxPQUFPLElBQUlELGlCQUFpQkwsaUJBQWlCLEtBQUs7Z0JBQ2hETSxTQUFTO1lBQ1gsT0FBTztnQkFDTEEsU0FBUztZQUNYO1lBRUEseUVBQXlFO1lBQ3pFLE1BQU1oTixhQUFhNkk7WUFFbkIsT0FBTztnQkFDTCxHQUFHNEQsSUFBSTtnQkFDUFEsaUJBQWlCUDtnQkFDakJRLGtCQUFrQlA7Z0JBQ2xCUSxhQUFhbk47Z0JBQ2JvTix3QkFBd0IvTTtnQkFDeEJnTix5QkFBeUIvTTtnQkFDekJnTixpQkFBaUIvTTtnQkFDakJnTixrQkFBa0IvTTtnQkFDbEIwTCxpQkFBaUJVO2dCQUNqQlIsbUJBQW1CVTtnQkFDbkJVLGlCQUFpQlQ7Z0JBQ2pCQztnQkFDQVMsZ0JBQWdCaE4sY0FBYyx1Q0FBdUM7WUFDdkU7UUFDRjtRQUVBLHFEQUFxRDtRQUNyRCxNQUFNbUwsbUJBQW1CNUMsWUFBWWxELE1BQU0sQ0FBQyxDQUFDQyxLQUFLeUYsSUFBTXpGLE1BQU15RixFQUFFWSxpQkFBaUIsRUFBRTtRQUNuRixNQUFNc0IsdUJBQXVCN0UseUJBQXlCckc7UUFDdEQsTUFBTW1MLGdCQUFnQkMsS0FBS0MsR0FBRyxJQUFJckIsdUJBQXVCNUYsR0FBRyxDQUFDNEUsQ0FBQUEsSUFBS0EsRUFBRWdDLGVBQWU7UUFDbkYsTUFBTU0sc0JBQXNCdEIsdUJBQXVCdUIsU0FBUyxDQUFDdkMsQ0FBQUEsSUFBS0EsRUFBRWdDLGVBQWUsR0FBRztRQUV0RjNMLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLG1DQUFtQyxFQUFFVSxZQUFZLFVBQVUsRUFBRW9KLGlCQUFpQjFGLGNBQWMsR0FBRyxJQUFJLENBQUM7UUFDakhyRSxRQUFRQyxHQUFHLENBQUMsQ0FBQyx3Q0FBd0MsRUFBRVUsWUFBWSxVQUFVLEVBQUVrTCxxQkFBcUJ4SCxjQUFjLEdBQUcsSUFBSSxDQUFDO1FBQzFIckUsUUFBUUMsR0FBRyxDQUFDLENBQUMsNEJBQTRCLEVBQUUsQ0FBQzRMLHVCQUF1QjlCLGdCQUFlLEVBQUcxRixjQUFjLEdBQUcsSUFBSSxDQUFDO1FBQzNHckUsUUFBUUMsR0FBRyxDQUFDLENBQUMsMENBQTBDLEVBQUU2TCxjQUFjekgsY0FBYyxHQUFHLElBQUksQ0FBQztRQUU3Rix1REFBdUQ7UUFDdkQsTUFBTThILG9CQUFvQixNQUFNcE8saUZBQXdCQSxDQUFDMEM7UUFDekQsTUFBTTJMLGtCQUFrQnJDLG1CQUFtQnBKO1FBQzNDLE1BQU0wTCxpQkFBaUJyTyxnRkFBdUJBLENBQzVDbU8sbUJBQ0FDLGlCQUNBcEYsd0JBQ0FyRztRQUdGWCxRQUFRQyxHQUFHLENBQUMsQ0FBQyxxQ0FBcUMsRUFBRWtNLGtCQUFrQkcsbUJBQW1CLENBQUNqSSxjQUFjLEdBQUcsSUFBSSxDQUFDO1FBQ2hIckUsUUFBUUMsR0FBRyxDQUFDLENBQUMsNkJBQTZCLEVBQUVvTSxlQUFlRSxrQkFBa0IsQ0FBQ0MsT0FBTyxDQUFDLEdBQUcsT0FBTyxDQUFDO1FBQ2pHeE0sUUFBUUMsR0FBRyxDQUFDLENBQUMsa0NBQWtDLEVBQUVvTSxlQUFlSSx1QkFBdUIsQ0FBQ0QsT0FBTyxDQUFDLEdBQUcsT0FBTyxDQUFDO1FBRTNHLG9GQUFvRjtRQUNwRixNQUFNRSw0QkFBNEIvQix1QkFBdUIxRyxNQUFNLENBQzdELENBQUNDLEtBQUswRyxPQUFTMUcsTUFBTzBHLENBQUFBLEtBQUtXLHNCQUFzQixJQUFJLElBQUk7UUFHM0Qsb0RBQW9EO1FBQ3BELDJEQUEyRDtRQUMzRCw4RUFBOEU7UUFDOUUsTUFBTW9CLG9CQUFvQmhDLHVCQUF1QjVGLEdBQUcsQ0FBQyxDQUFDNkY7WUFDcEQsK0RBQStEO1lBQy9ELE1BQU1nQyxrQkFBa0JoQyxLQUFLWCxhQUFhLENBQUNoRyxNQUFNLENBQUMsQ0FBQ0MsS0FBYXlGLElBQVd6RixNQUFNeUYsRUFBRWxLLE1BQU0sRUFBRTtZQUMzRiwwREFBMEQ7WUFDMUQsTUFBTW9OLHdCQUF3QmpDLEtBQUtXLHNCQUFzQixJQUFJO1lBQzdELDREQUE0RDtZQUM1RCxNQUFNdUIseUJBQXlCbEMsS0FBS1ksdUJBQXVCLElBQUk7WUFFL0QsT0FBTztnQkFDTHBFLE9BQU93RCxLQUFLeEQsS0FBSztnQkFDakI0QyxhQUFhWSxLQUFLWixXQUFXO2dCQUM3QitDLGtCQUFrQkg7Z0JBQ2xCSSxtQkFBbUJIO2dCQUNuQkksb0JBQW9CSDtZQUN0QjtRQUNGO1FBRUEsNkRBQTZEO1FBQzdELElBQUlJLHVCQUF1QjtRQUMzQixJQUFJQyw4QkFBOEI7UUFDbEMsSUFBSUMsK0JBQStCO1FBQ25DLE1BQU1DLCtCQUErQlYsa0JBQWtCNUgsR0FBRyxDQUFDLENBQUM2RjtZQUMxRHNDLHdCQUF3QnRDLEtBQUttQyxnQkFBZ0I7WUFDN0NJLCtCQUErQnZDLEtBQUtvQyxpQkFBaUI7WUFDckRJLGdDQUFnQ3hDLEtBQUtxQyxrQkFBa0I7WUFFdkQsdUdBQXVHO1lBQ3ZHLE1BQU1LLGtCQUFrQkosdUJBQXVCQyw4QkFBOEJDO1lBRTdFLE9BQU87Z0JBQ0xoRyxPQUFPd0QsS0FBS3hELEtBQUs7Z0JBQ2pCNEMsYUFBYVksS0FBS1osV0FBVztnQkFDN0JwRSxrQkFBa0JLLHVCQUF1QnFIO2dCQUN6Q0Msc0JBQXNCM0MsS0FBS21DLGdCQUFnQjtnQkFDM0NTLDhCQUE4QjVDLEtBQUtvQyxpQkFBaUI7Z0JBQ3BEUywrQkFBK0I3QyxLQUFLcUMsa0JBQWtCO2dCQUN0RFMsdUJBQXVCUjtnQkFDdkJTLCtCQUErQlI7Z0JBQy9CUyxnQ0FBZ0NSO1lBQ2xDO1FBQ0Y7UUFFQXBOLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLDhCQUE4QixFQUFFMkUsWUFBWS9CLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRW9ELHFCQUFxQjVCLGNBQWMsR0FBRyxJQUFJLENBQUM7UUFFaEksT0FBT2xILHFEQUFZQSxDQUFDMkQsSUFBSSxDQUFDO1lBQ3ZCRyxNQUFNO2dCQUNKNE0saUJBQWlCdkg7Z0JBQ2pCd0gsY0FBY25OO2dCQUNkNEosbUJBQW1CUjtnQkFDbkJnRSx3QkFBd0JsQztnQkFDeEJtQyxzQkFBc0JuQyx1QkFBdUI5QjtnQkFDN0NrRSwwQkFBMEJuQztnQkFDMUJvQyx1QkFBdUJqQyx3QkFBd0IsQ0FBQyxJQUFJLE9BQU9BLHNCQUFzQjtnQkFDakY5RSxhQUFhd0Q7Z0JBRWIsNkNBQTZDO2dCQUM3Q3dELFdBQVdoQztnQkFDWGlDLFFBQVEvQjtnQkFFUixvQ0FBb0M7Z0JBQ3BDZ0MsY0FBYztvQkFDWjdKLFVBQVVJO29CQUNWMEosYUFBYXhJO29CQUNieUksWUFBWXZJO29CQUNad0ksaUJBQWlCdkk7b0JBQ2pCd0kscUJBQXFCM0ksbUJBQW1CLElBQUksa0JBQW1CQSxtQkFBb0IsTUFBTTtvQkFDekY0SSx5QkFBeUJyQjtvQkFDekIsaUNBQWlDO29CQUNqQzlCLHdCQUF3Qm1CO29CQUN4QmlDLDZCQUE2QjFJLHVCQUF1QnlHO2dCQUN0RDtnQkFFQSwwQ0FBMEM7Z0JBQzFDaEssVUFBVUQ7Z0JBRVZtTSxTQUFTLE1BQU0sNkJBQTZCO1lBQzlDO1FBQ0Y7SUFFRixFQUFFLE9BQU83TixPQUFPO1FBQ2RmLFFBQVFlLEtBQUssQ0FBQyxxQkFBcUJBO1FBQ25DLE9BQU81RCxxREFBWUEsQ0FBQzJELElBQUksQ0FDdEI7WUFBRUMsT0FBTztRQUF3QixHQUNqQztZQUFFQyxRQUFRO1FBQUk7SUFFbEI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BmaW5hbmNlYXBwL3dlYi8uL2FwcC9hcGkvY2FzaC1mbG93LXByb2plY3Rpb24vcm91dGUudHM/NTdiMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENhc2ggRmxvdyBQcm9qZWN0aW9uIEFQSSAtIFZlcnNpb24gMy4wXG4gKlxuICogSW1wbGVtZW50cyBpbnRlbGxpZ2VudCBwcmVkaWN0aXZlIGZvcmVjYXN0aW5nIHdpdGggaGllcmFyY2hpY2FsIHByaW9yaXR5IHN5c3RlbVxuICogdG8gcHJldmVudCBkb3VibGUtY291bnRpbmcgb2YgZXhwZW5zZXMsIHBsdXMgbGlxdWlkaXR5ICYgc29sdmVuY3kgYW5hbHlzaXMuXG4gKlxuICogQHNlZSBkb2NzL0NBU0hGTE9XX1NZU1RFTV8yLjAubWQgZm9yIHYyLjAgZG9jdW1lbnRhdGlvblxuICogQHNlZSBkb2NzL0NBU0hGTE9XX1NZU1RFTV8zLjAubWQgZm9yIHYzLjAgbGlxdWlkaXR5IGZlYXR1cmVzXG4gKi9cblxuaW1wb3J0IHsgTmV4dFJlcXVlc3QsIE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJ1xuaW1wb3J0IHsgY3JlYXRlU3VwYWJhc2VTZXJ2ZXJDbGllbnQgfSBmcm9tICdAL2xpYi9zdXBhYmFzZS1zZXJ2ZXInXG5pbXBvcnQgeyBzdGFydE9mTW9udGgsIGVuZE9mTW9udGgsIGFkZE1vbnRocywgZm9ybWF0LCBwYXJzZUlTTywgZWFjaE1vbnRoT2ZJbnRlcnZhbCB9IGZyb20gJ2RhdGUtZm5zJ1xuaW1wb3J0IHtcbiAgY2FsY3VsYXRlUHJlZGljdGVkSW5jb21lLFxuICBjYWxjdWxhdGVQcmVkaWN0ZWRFeHBlbnNlcyxcbiAgY29tcGFyZUJ1ZGdldHMsXG4gIGdldENhdGVnb3JpZXNXaXRoU2NoZWR1bGVkUGF5bWVudHMsXG4gIGFuYWx5emVMaXF1aWRpdHlQb3NpdGlvbixcbiAgY2FsY3VsYXRlUnVud2F5QW5hbHlzaXNcbn0gZnJvbSAnQC9saWIvY2FzaC1mbG93LWFuYWx5emVyJ1xuXG4vLyBIZWxwZXIgdHlwZSBmb3Igc2NlbmFyaW8gYWRqdXN0bWVudHNcbmludGVyZmFjZSBTY2VuYXJpb0FkanVzdG1lbnQge1xuICBhZGp1c3RtZW50X2lkOiBudW1iZXJcbiAgYWRqdXN0bWVudF90eXBlOiBzdHJpbmdcbiAgbmFtZTogc3RyaW5nXG4gIGFtb3VudDogbnVtYmVyIHwgbnVsbFxuICBwZXJjZW50YWdlOiBudW1iZXIgfCBudWxsXG4gIHN0YXJ0X21vbnRoOiBzdHJpbmcgfCBudWxsXG4gIGVuZF9tb250aDogc3RyaW5nIHwgbnVsbFxuICBjYXRlZ29yeV9pZDogbnVtYmVyIHwgbnVsbFxuICBzY2hlZHVsZWRfcGF5bWVudF9pZDogbnVtYmVyIHwgbnVsbFxuICBhY2NvdW50X2lkOiBudW1iZXIgfCBudWxsXG4gIG1ldGFkYXRhOiB7XG4gICAgcmVwYXltZW50X21vbnRoPzogc3RyaW5nIC8vIFlZWVktTU0gZm9ybWF0IChjYWxjdWxhdGVkKVxuICAgIHJlcGF5bWVudF9tb250aHM/OiBudW1iZXIgLy8gTnVtYmVyIG9mIG1vbnRocyBhZnRlciBkcmF3ZG93biAodXNlciBzZWxlY3Rpb24pXG4gICAgY3JlZGl0X2xpbmVfYWNjb3VudF9pZD86IG51bWJlclxuICAgIGludGVyZXN0X3JhdGU/OiBudW1iZXJcbiAgfSB8IG51bGxcbn1cblxuLy8gSGVscGVyIHR5cGUgZm9yIGRlYnQgcmVwYXltZW50IGZyb20gc2NlbmFyaW9zXG5pbnRlcmZhY2UgU2NlbmFyaW9EZWJ0UmVwYXltZW50IHtcbiAgYWRqdXN0bWVudF9pZDogbnVtYmVyXG4gIG5hbWU6IHN0cmluZ1xuICBhbW91bnQ6IG51bWJlclxuICByZXBheW1lbnRfbW9udGg6IHN0cmluZyAvLyBZWVlZLU1NIGZvcm1hdFxuICBjcmVkaXRfbGluZV9hY2NvdW50X2lkPzogbnVtYmVyXG59XG5cbi8vIEFwcGx5IHNjZW5hcmlvIGFkanVzdG1lbnRzIHRvIGEgbW9udGhseSBwcm9qZWN0aW9uXG5mdW5jdGlvbiBhcHBseVNjZW5hcmlvQWRqdXN0bWVudHMoXG4gIG1vbnRoS2V5OiBzdHJpbmcsIC8vIFlZWVktTU0gZm9ybWF0XG4gIGJhc2VJbmNvbWU6IG51bWJlcixcbiAgYmFzZVByZWRpY3RlZEV4cGVuc2VzOiBudW1iZXIsXG4gIGFkanVzdG1lbnRzOiBTY2VuYXJpb0FkanVzdG1lbnRbXVxuKToge1xuICBhZGp1c3RlZEluY29tZTogbnVtYmVyXG4gIGFkanVzdGVkUHJlZGljdGVkOiBudW1iZXJcbiAgc2NlbmFyaW9EZWJ0RHJhd2Rvd246IG51bWJlciAvLyBORVc6IFNlcGFyYXRlIGRlYnQgZHJhd2Rvd24gYW1vdW50IGZvciBjaGFydCBkaXNwbGF5XG4gIHNjZW5hcmlvRGVidFJlcGF5bWVudDogbnVtYmVyIC8vIE5FVzogRGVidCByZXBheW1lbnQgYW1vdW50IChmcm9tIHNjZW5hcmlvKSBmb3IgY2hhcnQgZGlzcGxheVxuICBzY2VuYXJpb0luY29tZTogbnVtYmVyIC8vIE5FVzogQWRkaXRpb25hbCBzY2VuYXJpbyBpbmNvbWUgKG5vdCBkZWJ0KVxuICBzY2VuYXJpb0V4cGVuc2U6IG51bWJlciAvLyBORVc6IEFkZGl0aW9uYWwgc2NlbmFyaW8gZXhwZW5zZVxuICBzY2VuYXJpb0l0ZW1zOiB7IG5hbWU6IHN0cmluZzsgYW1vdW50OiBudW1iZXI7IHR5cGU6IHN0cmluZyB9W11cbn0ge1xuICBsZXQgYWRqdXN0ZWRJbmNvbWUgPSBiYXNlSW5jb21lXG4gIGxldCBhZGp1c3RlZFByZWRpY3RlZCA9IGJhc2VQcmVkaWN0ZWRFeHBlbnNlc1xuICBsZXQgc2NlbmFyaW9EZWJ0RHJhd2Rvd24gPSAwIC8vIFRyYWNrIGRlYnQgZHJhd2Rvd25zIHNlcGFyYXRlbHlcbiAgbGV0IHNjZW5hcmlvRGVidFJlcGF5bWVudCA9IDAgLy8gVHJhY2sgZGVidCByZXBheW1lbnRzIHNlcGFyYXRlbHlcbiAgbGV0IHNjZW5hcmlvSW5jb21lID0gMCAvLyBUcmFjayBzY2VuYXJpbyBpbmNvbWUgYWRkaXRpb25zXG4gIGxldCBzY2VuYXJpb0V4cGVuc2UgPSAwIC8vIFRyYWNrIHNjZW5hcmlvIGV4cGVuc2UgYWRkaXRpb25zXG4gIGNvbnN0IHNjZW5hcmlvSXRlbXM6IHsgbmFtZTogc3RyaW5nOyBhbW91bnQ6IG51bWJlcjsgdHlwZTogc3RyaW5nIH1bXSA9IFtdXG5cbiAgY29uc3QgbW9udGhEYXRlID0gcGFyc2VJU08oYCR7bW9udGhLZXl9LTAxYClcblxuICBmb3IgKGNvbnN0IGFkaiBvZiBhZGp1c3RtZW50cykge1xuICAgIC8vIENoZWNrIGlmIGFkanVzdG1lbnQgYXBwbGllcyB0byB0aGlzIG1vbnRoXG4gICAgY29uc3Qgc3RhcnRNb250aCA9IGFkai5zdGFydF9tb250aCA/IHBhcnNlSVNPKGFkai5zdGFydF9tb250aCkgOiBudWxsXG4gICAgY29uc3QgZW5kTW9udGggPSBhZGouZW5kX21vbnRoID8gcGFyc2VJU08oYWRqLmVuZF9tb250aCkgOiBudWxsXG5cbiAgICBjb25zdCBzdGFydHNCZWZvcmVPck9uID0gIXN0YXJ0TW9udGggfHwgc3RhcnRNb250aCA8PSBtb250aERhdGVcbiAgICBjb25zdCBlbmRzQWZ0ZXJPck9uID0gIWVuZE1vbnRoIHx8IGVuZE1vbnRoID49IG1vbnRoRGF0ZVxuXG4gICAgLy8gRm9yIG9uZS10aW1lIGl0ZW1zLCBvbmx5IGFwcGx5IGlmIHN0YXJ0X21vbnRoIG1hdGNoZXNcbiAgICAvLyBkZWJ0X2RyYXdkb3duIGlzIGFsc28gYSBvbmUtdGltZSBldmVudCAoc2luZ2xlIGxvYW4gZGlzYnVyc2VtZW50KVxuICAgIGNvbnN0IGlzT25lVGltZSA9IGFkai5hZGp1c3RtZW50X3R5cGUuc3RhcnRzV2l0aCgnb25lX3RpbWUnKSB8fCBhZGouYWRqdXN0bWVudF90eXBlID09PSAnZGVidF9kcmF3ZG93bidcbiAgICBjb25zdCBtYXRjaGVzTW9udGggPSBpc09uZVRpbWVcbiAgICAgID8gKHN0YXJ0TW9udGggJiYgZm9ybWF0KHN0YXJ0TW9udGgsICd5eXl5LU1NJykgPT09IG1vbnRoS2V5KVxuICAgICAgOiAoc3RhcnRzQmVmb3JlT3JPbiAmJiBlbmRzQWZ0ZXJPck9uKVxuXG4gICAgLy8gQ2hlY2sgZm9yIGRlYnQgcmVwYXltZW50IGluIHRoaXMgbW9udGggKGZyb20gZGVidF9kcmF3ZG93biBtZXRhZGF0YSlcbiAgICBpZiAoYWRqLmFkanVzdG1lbnRfdHlwZSA9PT0gJ2RlYnRfZHJhd2Rvd24nICYmIGFkai5hbW91bnQgJiYgYWRqLm1ldGFkYXRhPy5yZXBheW1lbnRfbW9udGgpIHtcbiAgICAgIGNvbnN0IHJlcGF5bWVudE1vbnRoID0gYWRqLm1ldGFkYXRhLnJlcGF5bWVudF9tb250aFxuICAgICAgaWYgKHJlcGF5bWVudE1vbnRoID09PSBtb250aEtleSkge1xuICAgICAgICAvLyBBZGQgZGVidCByZXBheW1lbnQgYXMgYW4gZXhwZW5zZSBpbiB0aGUgcmVwYXltZW50IG1vbnRoXG4gICAgICAgIGFkanVzdGVkUHJlZGljdGVkICs9IGFkai5hbW91bnRcbiAgICAgICAgc2NlbmFyaW9EZWJ0UmVwYXltZW50ICs9IGFkai5hbW91bnRcbiAgICAgICAgc2NlbmFyaW9JdGVtcy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBgJHthZGoubmFtZX0gKFJlcGF5bWVudClgLFxuICAgICAgICAgIGFtb3VudDogLWFkai5hbW91bnQsXG4gICAgICAgICAgdHlwZTogJ2RlYnRfcmVwYXltZW50J1xuICAgICAgICB9KVxuICAgICAgICBjb25zb2xlLmxvZyhgW1NjZW5hcmlvIERlYnVnXSBBZGRlZCBkZWJ0X3JlcGF5bWVudDogJHthZGouYW1vdW50fSB0byBtb250aCAke21vbnRoS2V5fWApXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFtYXRjaGVzTW9udGgpIGNvbnRpbnVlXG5cbiAgICBjb25zb2xlLmxvZyhgW1NjZW5hcmlvIERlYnVnXSBBcHBseWluZyAke2Fkai5hZGp1c3RtZW50X3R5cGV9IFwiJHthZGoubmFtZX1cIiB0byBtb250aCAke21vbnRoS2V5fWApXG5cbiAgICBzd2l0Y2ggKGFkai5hZGp1c3RtZW50X3R5cGUpIHtcbiAgICAgIGNhc2UgJ29uZV90aW1lX2luY29tZSc6XG4gICAgICBjYXNlICdyZWN1cnJpbmdfaW5jb21lJzpcbiAgICAgICAgaWYgKGFkai5hbW91bnQpIHtcbiAgICAgICAgICBhZGp1c3RlZEluY29tZSArPSBhZGouYW1vdW50XG4gICAgICAgICAgc2NlbmFyaW9JbmNvbWUgKz0gYWRqLmFtb3VudFxuICAgICAgICAgIHNjZW5hcmlvSXRlbXMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBhZGoubmFtZSxcbiAgICAgICAgICAgIGFtb3VudDogYWRqLmFtb3VudCxcbiAgICAgICAgICAgIHR5cGU6ICdpbmNvbWUnXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdvbmVfdGltZV9leHBlbnNlJzpcbiAgICAgIGNhc2UgJ3JlY3VycmluZ19leHBlbnNlJzpcbiAgICAgICAgaWYgKGFkai5hbW91bnQpIHtcbiAgICAgICAgICBhZGp1c3RlZFByZWRpY3RlZCArPSBhZGouYW1vdW50XG4gICAgICAgICAgc2NlbmFyaW9FeHBlbnNlICs9IGFkai5hbW91bnRcbiAgICAgICAgICBzY2VuYXJpb0l0ZW1zLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogYWRqLm5hbWUsXG4gICAgICAgICAgICBhbW91bnQ6IC1hZGouYW1vdW50LFxuICAgICAgICAgICAgdHlwZTogJ2V4cGVuc2UnXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdkZWJ0X2RyYXdkb3duJzpcbiAgICAgICAgLy8gQWRkIGRlYnQgYXMgaW5jb21lIChjYXNoIGluZmxvdykgYnV0IHRyYWNrIGl0IHNlcGFyYXRlbHkgZm9yIGRpc3BsYXlcbiAgICAgICAgaWYgKGFkai5hbW91bnQpIHtcbiAgICAgICAgICBhZGp1c3RlZEluY29tZSArPSBhZGouYW1vdW50XG4gICAgICAgICAgc2NlbmFyaW9EZWJ0RHJhd2Rvd24gKz0gYWRqLmFtb3VudCAvLyBUcmFjayBzZXBhcmF0ZWx5IVxuICAgICAgICAgIHNjZW5hcmlvSXRlbXMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBhZGoubmFtZSxcbiAgICAgICAgICAgIGFtb3VudDogYWRqLmFtb3VudCxcbiAgICAgICAgICAgIHR5cGU6ICdkZWJ0J1xuICAgICAgICAgIH0pXG4gICAgICAgICAgY29uc29sZS5sb2coYFtTY2VuYXJpbyBEZWJ1Z10gQWRkZWQgZGVidF9kcmF3ZG93bjogJHthZGouYW1vdW50fSB0byBtb250aCAke21vbnRoS2V5fWApXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnbW9kaWZ5X3ByZWRpY3RlZCc6XG4gICAgICAgIC8vIEFwcGx5IHBlcmNlbnRhZ2UgY2hhbmdlIHRvIHByZWRpY3RlZCBleHBlbnNlc1xuICAgICAgICBpZiAoYWRqLnBlcmNlbnRhZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBjaGFuZ2UgPSBiYXNlUHJlZGljdGVkRXhwZW5zZXMgKiAoYWRqLnBlcmNlbnRhZ2UgLyAxMDApXG4gICAgICAgICAgYWRqdXN0ZWRQcmVkaWN0ZWQgKz0gY2hhbmdlXG4gICAgICAgICAgc2NlbmFyaW9FeHBlbnNlICs9IGNoYW5nZVxuICAgICAgICAgIHNjZW5hcmlvSXRlbXMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBhZGoubmFtZSxcbiAgICAgICAgICAgIGFtb3VudDogY2hhbmdlLFxuICAgICAgICAgICAgdHlwZTogJ21vZGlmaWNhdGlvbidcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ21vZGlmeV9pbmNvbWUnOlxuICAgICAgICAvLyBBcHBseSBwZXJjZW50YWdlIGNoYW5nZSB0byBpbmNvbWVcbiAgICAgICAgaWYgKGFkai5wZXJjZW50YWdlICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgY2hhbmdlID0gYmFzZUluY29tZSAqIChhZGoucGVyY2VudGFnZSAvIDEwMClcbiAgICAgICAgICBhZGp1c3RlZEluY29tZSArPSBjaGFuZ2VcbiAgICAgICAgICBzY2VuYXJpb0luY29tZSArPSBjaGFuZ2VcbiAgICAgICAgICBzY2VuYXJpb0l0ZW1zLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogYWRqLm5hbWUsXG4gICAgICAgICAgICBhbW91bnQ6IGNoYW5nZSxcbiAgICAgICAgICAgIHR5cGU6ICdtb2RpZmljYXRpb24nXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IGFkanVzdGVkSW5jb21lLCBhZGp1c3RlZFByZWRpY3RlZCwgc2NlbmFyaW9EZWJ0RHJhd2Rvd24sIHNjZW5hcmlvRGVidFJlcGF5bWVudCwgc2NlbmFyaW9JbmNvbWUsIHNjZW5hcmlvRXhwZW5zZSwgc2NlbmFyaW9JdGVtcyB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBHRVQocmVxdWVzdDogTmV4dFJlcXVlc3QpIHtcbiAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVTdXBhYmFzZVNlcnZlckNsaWVudCgpXG4gIGNvbnN0IHNlYXJjaFBhcmFtcyA9IHJlcXVlc3QubmV4dFVybC5zZWFyY2hQYXJhbXNcblxuICBjb25zdCBlbnRpdHlJZCA9IHNlYXJjaFBhcmFtcy5nZXQoJ2VudGl0eV9pZCcpXG4gIGNvbnN0IG1vbnRoc0FoZWFkID0gcGFyc2VJbnQoc2VhcmNoUGFyYW1zLmdldCgnbW9udGhzX2FoZWFkJykgfHwgJzYnKVxuICBjb25zdCBzY2VuYXJpb0lkID0gc2VhcmNoUGFyYW1zLmdldCgnc2NlbmFyaW9faWQnKSAvLyBORVc6IE9wdGlvbmFsIHNjZW5hcmlvXG5cbiAgaWYgKCFlbnRpdHlJZCkge1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgIHsgZXJyb3I6ICdlbnRpdHlfaWQgaXMgcmVxdWlyZWQnIH0sXG4gICAgICB7IHN0YXR1czogNDAwIH1cbiAgICApXG4gIH1cblxuICB0cnkge1xuICAgIC8vIFZlcmlmeSB1c2VyIGhhcyBwZXJtaXNzaW9uIHRvIHZpZXcgY2FzaCBmbG93XG4gICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSwgZXJyb3I6IGF1dGhFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKClcbiAgICBpZiAoYXV0aEVycm9yIHx8ICF1c2VyKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdVbmF1dGhvcml6ZWQnIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDEgfVxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIEdldCB1c2VyJ3Mgcm9sZSBmb3IgdGhpcyBlbnRpdHlcbiAgICBjb25zdCB7IGRhdGE6IGVudGl0eVVzZXIsIGVycm9yOiByb2xlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnZW50aXR5X3VzZXJzJylcbiAgICAgIC5zZWxlY3QoJ3JvbGUnKVxuICAgICAgLmVxKCdlbnRpdHlfaWQnLCBlbnRpdHlJZClcbiAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpXG4gICAgICAuc2luZ2xlKClcblxuICAgIGlmIChyb2xlRXJyb3IgfHwgIWVudGl0eVVzZXIpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ1lvdSBkbyBub3QgaGF2ZSBhY2Nlc3MgdG8gdGhpcyBlbnRpdHknIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDMgfVxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBjdXN0b20gcGVybWlzc2lvbiBvdmVycmlkZVxuICAgIGNvbnN0IHsgZGF0YTogY3VzdG9tUGVybWlzc2lvbiB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdyb2xlX3Blcm1pc3Npb25zJylcbiAgICAgIC5zZWxlY3QoJ2Nhbl92aWV3X2Nhc2hfZmxvdycpXG4gICAgICAuZXEoJ2VudGl0eV9pZCcsIGVudGl0eUlkKVxuICAgICAgLmVxKCdyb2xlJywgZW50aXR5VXNlci5yb2xlKVxuICAgICAgLnNpbmdsZSgpXG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgdXNlciBjYW4gdmlldyBjYXNoIGZsb3dcbiAgICAvLyBEZWZhdWx0OiBvbmx5IGVkaXRvciBhbmQgYWJvdmUgY2FuIHZpZXdcbiAgICBjb25zdCByb2xlSGllcmFyY2h5OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge1xuICAgICAgJ293bmVyJzogNSxcbiAgICAgICdhZG1pbic6IDQsXG4gICAgICAnZWRpdG9yJzogMyxcbiAgICAgICdkYXRhX2VudHJ5JzogMixcbiAgICAgICd2aWV3ZXInOiAxXG4gICAgfVxuICAgIGNvbnN0IHVzZXJSb2xlTGV2ZWwgPSByb2xlSGllcmFyY2h5W2VudGl0eVVzZXIucm9sZV0gfHwgMFxuICAgIGNvbnN0IGRlZmF1bHRDYW5WaWV3Q2FzaEZsb3cgPSB1c2VyUm9sZUxldmVsID49IDMgLy8gZWRpdG9yIGxldmVsXG5cbiAgICAvLyBVc2UgY3VzdG9tIHBlcm1pc3Npb24gaWYgc2V0LCBvdGhlcndpc2UgdXNlIGRlZmF1bHRcbiAgICBjb25zdCBjYW5WaWV3Q2FzaEZsb3cgPSBjdXN0b21QZXJtaXNzaW9uPy5jYW5fdmlld19jYXNoX2Zsb3cgIT09IG51bGwgJiYgY3VzdG9tUGVybWlzc2lvbj8uY2FuX3ZpZXdfY2FzaF9mbG93ICE9PSB1bmRlZmluZWRcbiAgICAgID8gY3VzdG9tUGVybWlzc2lvbi5jYW5fdmlld19jYXNoX2Zsb3dcbiAgICAgIDogZGVmYXVsdENhblZpZXdDYXNoRmxvd1xuXG4gICAgaWYgKCFjYW5WaWV3Q2FzaEZsb3cpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ1lvdSBkbyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIHZpZXcgY2FzaCBmbG93IHByb2plY3Rpb25zJyB9LFxuICAgICAgICB7IHN0YXR1czogNDAzIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydERhdGUgPSBzdGFydE9mTW9udGgobmV3IERhdGUoKSlcbiAgICBjb25zdCBlbmREYXRlID0gZW5kT2ZNb250aChhZGRNb250aHMoc3RhcnREYXRlLCBtb250aHNBaGVhZCAtIDEpKVxuXG4gICAgLy8gRmV0Y2ggc2NlbmFyaW8gYWRqdXN0bWVudHMgaWYgc2NlbmFyaW9faWQgcHJvdmlkZWRcbiAgICBsZXQgc2NlbmFyaW9BZGp1c3RtZW50czogU2NlbmFyaW9BZGp1c3RtZW50W10gPSBbXVxuICAgIGxldCBzY2VuYXJpb0luZm86IHsgbmFtZTogc3RyaW5nOyBjb2xvcjogc3RyaW5nIH0gfCBudWxsID0gbnVsbFxuXG4gICAgaWYgKHNjZW5hcmlvSWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbU2NlbmFyaW8gRGVidWddIEZldGNoaW5nIHNjZW5hcmlvICR7c2NlbmFyaW9JZH0gZm9yIGVudGl0eSAke2VudGl0eUlkfWApXG4gICAgICBjb25zdCB7IGRhdGE6IHNjZW5hcmlvLCBlcnJvcjogc2NlbmFyaW9FcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2Nhc2hmbG93X3NjZW5hcmlvcycpXG4gICAgICAgIC5zZWxlY3QoYFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgY29sb3IsXG4gICAgICAgICAgYWRqdXN0bWVudHM6c2NlbmFyaW9fYWRqdXN0bWVudHMoKilcbiAgICAgICAgYClcbiAgICAgICAgLmVxKCdzY2VuYXJpb19pZCcsIHNjZW5hcmlvSWQpXG4gICAgICAgIC5lcSgnZW50aXR5X2lkJywgZW50aXR5SWQpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBpZiAoc2NlbmFyaW9FcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbU2NlbmFyaW8gRGVidWddIEVycm9yIGZldGNoaW5nIHNjZW5hcmlvOicsIHNjZW5hcmlvRXJyb3IpXG4gICAgICB9XG5cbiAgICAgIGlmICghc2NlbmFyaW9FcnJvciAmJiBzY2VuYXJpbykge1xuICAgICAgICBzY2VuYXJpb0luZm8gPSB7IG5hbWU6IHNjZW5hcmlvLm5hbWUsIGNvbG9yOiBzY2VuYXJpby5jb2xvciB9XG4gICAgICAgIHNjZW5hcmlvQWRqdXN0bWVudHMgPSBzY2VuYXJpby5hZGp1c3RtZW50cyB8fCBbXVxuICAgICAgICBjb25zb2xlLmxvZyhgW1NjZW5hcmlvIERlYnVnXSBGb3VuZCBzY2VuYXJpbzogJHtzY2VuYXJpby5uYW1lfSwgYWRqdXN0bWVudHM6ICR7c2NlbmFyaW9BZGp1c3RtZW50cy5sZW5ndGh9YClcbiAgICAgICAgY29uc29sZS5sb2coJ1tTY2VuYXJpbyBEZWJ1Z10gQWRqdXN0bWVudHM6JywgSlNPTi5zdHJpbmdpZnkoc2NlbmFyaW9BZGp1c3RtZW50cywgbnVsbCwgMikpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgbGlzdCBvZiBtb250aHNcbiAgICBjb25zdCBtb250aHMgPSBlYWNoTW9udGhPZkludGVydmFsKHsgc3RhcnQ6IHN0YXJ0RGF0ZSwgZW5kOiBlbmREYXRlIH0pXG5cbiAgICAvLyBGZXRjaCBkZWJ0IGRyYXdkb3ducyAobW9uZXkgd2UgYm9ycm93ZWQgYW5kIG5lZWQgdG8gcGF5IGJhY2spXG4gICAgLy8gVGhlc2UgYXJlIGZyb20gY3JlZGl0X2xpbmUvdGVybV9sb2FuIGFjY291bnRzIHdpdGggZHVlIGRhdGVzXG4gICAgY29uc3QgeyBkYXRhOiBkZWJ0RHJhd2Rvd25zLCBlcnJvcjogZGVidERyYXdkb3duRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnZGVidF9kcmF3ZG93bicpXG4gICAgICAuc2VsZWN0KGBcbiAgICAgICAgKixcbiAgICAgICAgYWNjb3VudHMhaW5uZXIgKFxuICAgICAgICAgIGVudGl0eV9pZCxcbiAgICAgICAgICBhY2NvdW50X25hbWUsXG4gICAgICAgICAgYWNjb3VudF90eXBlXG4gICAgICAgIClcbiAgICAgIGApXG4gICAgICAuZXEoJ2FjY291bnRzLmVudGl0eV9pZCcsIGVudGl0eUlkKVxuICAgICAgLmVxKCdzdGF0dXMnLCAnYWN0aXZlJylcbiAgICAgIC5ub3QoJ2R1ZV9kYXRlJywgJ2lzJywgbnVsbClcbiAgICAgIC5ndGUoJ2R1ZV9kYXRlJywgZm9ybWF0KHN0YXJ0RGF0ZSwgJ3l5eXktTU0tZGQnKSlcbiAgICAgIC5sdGUoJ2R1ZV9kYXRlJywgZm9ybWF0KGVuZERhdGUsICd5eXl5LU1NLWRkJykpXG4gICAgICAub3JkZXIoJ2R1ZV9kYXRlJywgeyBhc2NlbmRpbmc6IHRydWUgfSlcblxuICAgIGlmIChkZWJ0RHJhd2Rvd25FcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgZGVidCBkcmF3ZG93bnM6JywgZGVidERyYXdkb3duRXJyb3IpXG4gICAgfVxuXG4gICAgLy8gQWxzbyBmZXRjaCBsb2FuIGRpc2J1cnNlbWVudHMgKGxvYW5zIHdlIGdhdmUgb3V0IC0gcmVjZWl2YWJsZXMgd2l0aCBkdWUgZGF0ZXMpXG4gICAgY29uc3QgeyBkYXRhOiBsb2FuUmVjZWl2YWJsZXMsIGVycm9yOiBsb2FuRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnbG9hbl9kaXNidXJzZW1lbnQnKVxuICAgICAgLnNlbGVjdChgXG4gICAgICAgICosXG4gICAgICAgIGFjY291bnRzIWlubmVyIChcbiAgICAgICAgICBlbnRpdHlfaWQsXG4gICAgICAgICAgYWNjb3VudF9uYW1lXG4gICAgICAgIClcbiAgICAgIGApXG4gICAgICAuZXEoJ2FjY291bnRzLmVudGl0eV9pZCcsIGVudGl0eUlkKVxuICAgICAgLmVxKCdzdGF0dXMnLCAnYWN0aXZlJylcbiAgICAgIC5ub3QoJ2R1ZV9kYXRlJywgJ2lzJywgbnVsbClcbiAgICAgIC5ndGUoJ2R1ZV9kYXRlJywgZm9ybWF0KHN0YXJ0RGF0ZSwgJ3l5eXktTU0tZGQnKSlcbiAgICAgIC5sdGUoJ2R1ZV9kYXRlJywgZm9ybWF0KGVuZERhdGUsICd5eXl5LU1NLWRkJykpXG4gICAgICAub3JkZXIoJ2R1ZV9kYXRlJywgeyBhc2NlbmRpbmc6IHRydWUgfSlcblxuICAgIGlmIChsb2FuRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGxvYW4gcmVjZWl2YWJsZXM6JywgbG9hbkVycm9yKVxuICAgIH1cblxuICAgIC8vIEZldGNoIHNjaGVkdWxlZCBwYXltZW50IGluc3RhbmNlcyAob25seSB1bnBhaWQpXG4gICAgY29uc3QgeyBkYXRhOiBzY2hlZHVsZWRJbnN0YW5jZXMsIGVycm9yOiBzY2hlZHVsZWRFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdzY2hlZHVsZWRfcGF5bWVudF9pbnN0YW5jZXMnKVxuICAgICAgLnNlbGVjdChgXG4gICAgICAgICosXG4gICAgICAgIHNjaGVkdWxlZF9wYXltZW50czpzY2hlZHVsZWRfcGF5bWVudF9pZCFpbm5lciAoXG4gICAgICAgICAgY29udHJhY3RfbmFtZSxcbiAgICAgICAgICBwYXltZW50X3R5cGUsXG4gICAgICAgICAgcGF5ZWVfbmFtZSxcbiAgICAgICAgICBjYXRlZ29yeV9pZCxcbiAgICAgICAgICBlbnRpdHlfaWQsXG4gICAgICAgICAgY2F0ZWdvcmllczpjYXRlZ29yeV9pZCAoXG4gICAgICAgICAgICBjYXRlZ29yeV9uYW1lXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICBgKVxuICAgICAgLmVxKCdzY2hlZHVsZWRfcGF5bWVudHMuZW50aXR5X2lkJywgZW50aXR5SWQpXG4gICAgICAuaW4oJ3N0YXR1cycsIFsncGVuZGluZycsICdvdmVyZHVlJ10pIC8vIE9ubHkgaW5jbHVkZSB1bnBhaWQgaW5zdGFuY2VzXG4gICAgICAuZ3RlKCdkdWVfZGF0ZScsIGZvcm1hdChzdGFydERhdGUsICd5eXl5LU1NLWRkJykpXG4gICAgICAubHRlKCdkdWVfZGF0ZScsIGZvcm1hdChlbmREYXRlLCAneXl5eS1NTS1kZCcpKVxuICAgICAgLm9yZGVyKCdkdWVfZGF0ZScsIHsgYXNjZW5kaW5nOiB0cnVlIH0pXG5cbiAgICAvLyBERUJVRzogQWxzbyBmZXRjaCBBTEwgaW5zdGFuY2VzIHRvIGNvbXBhcmVcbiAgICBjb25zdCB7IGRhdGE6IGFsbEluc3RhbmNlcyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdzY2hlZHVsZWRfcGF5bWVudF9pbnN0YW5jZXMnKVxuICAgICAgLnNlbGVjdChgXG4gICAgICAgICosXG4gICAgICAgIHNjaGVkdWxlZF9wYXltZW50czpzY2hlZHVsZWRfcGF5bWVudF9pZCFpbm5lciAoXG4gICAgICAgICAgY29udHJhY3RfbmFtZSxcbiAgICAgICAgICBwYXltZW50X3R5cGUsXG4gICAgICAgICAgcGF5ZWVfbmFtZSxcbiAgICAgICAgICBjYXRlZ29yeV9pZCxcbiAgICAgICAgICBlbnRpdHlfaWQsXG4gICAgICAgICAgY2F0ZWdvcmllczpjYXRlZ29yeV9pZCAoXG4gICAgICAgICAgICBjYXRlZ29yeV9uYW1lXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICBgKVxuICAgICAgLmVxKCdzY2hlZHVsZWRfcGF5bWVudHMuZW50aXR5X2lkJywgZW50aXR5SWQpXG4gICAgICAuZ3RlKCdkdWVfZGF0ZScsIGZvcm1hdChzdGFydERhdGUsICd5eXl5LU1NLWRkJykpXG4gICAgICAubHRlKCdkdWVfZGF0ZScsIGZvcm1hdChlbmREYXRlLCAneXl5eS1NTS1kZCcpKVxuXG4gICAgY29uc3QgdG90YWxBbGxJbnN0YW5jZXMgPSBhbGxJbnN0YW5jZXM/LnJlZHVjZSgoc3VtLCBpKSA9PiBzdW0gKyAoaS5hbW91bnQgfHwgMCksIDApIHx8IDBcbiAgICBjb25zdCB0b3RhbFVucGFpZEluc3RhbmNlcyA9IHNjaGVkdWxlZEluc3RhbmNlcz8ucmVkdWNlKChzdW0sIGkpID0+IHN1bSArIChpLmFtb3VudCB8fCAwKSwgMCkgfHwgMFxuICAgIGNvbnNvbGUubG9nKGBbREVCVUddIFRvdGFsIGFsbCBpbnN0YW5jZXMgKCR7YWxsSW5zdGFuY2VzPy5sZW5ndGh9KTogJHt0b3RhbEFsbEluc3RhbmNlcy50b0xvY2FsZVN0cmluZygpfSBWTkRgKVxuICAgIGNvbnNvbGUubG9nKGBbREVCVUddIFRvdGFsIHVucGFpZCBpbnN0YW5jZXMgKCR7c2NoZWR1bGVkSW5zdGFuY2VzPy5sZW5ndGh9KTogJHt0b3RhbFVucGFpZEluc3RhbmNlcy50b0xvY2FsZVN0cmluZygpfSBWTkRgKVxuICAgIGNvbnNvbGUubG9nKGBbREVCVUddIERpZmZlcmVuY2U6ICR7KHRvdGFsQWxsSW5zdGFuY2VzIC0gdG90YWxVbnBhaWRJbnN0YW5jZXMpLnRvTG9jYWxlU3RyaW5nKCl9IFZORGApXG5cbiAgICBpZiAoc2NoZWR1bGVkRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHNjaGVkdWxlZCBwYXltZW50czonLCBzY2hlZHVsZWRFcnJvcilcbiAgICB9XG5cbiAgICAvLyBGZXRjaCBhY3RpdmUgYnVkZ2V0c1xuICAgIGNvbnN0IHsgZGF0YTogYnVkZ2V0cywgZXJyb3I6IGJ1ZGdldHNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdjYXRlZ29yeV9idWRnZXRzJylcbiAgICAgIC5zZWxlY3QoYFxuICAgICAgICAqLFxuICAgICAgICBjYXRlZ29yaWVzOmNhdGVnb3J5X2lkIChcbiAgICAgICAgICBjYXRlZ29yeV9uYW1lXG4gICAgICAgIClcbiAgICAgIGApXG4gICAgICAuZXEoJ2VudGl0eV9pZCcsIGVudGl0eUlkKVxuICAgICAgLmVxKCdpc19hY3RpdmUnLCB0cnVlKVxuICAgICAgLmd0ZSgnZW5kX2RhdGUnLCBmb3JtYXQoc3RhcnREYXRlLCAneXl5eS1NTS1kZCcpKVxuICAgICAgLm9yZGVyKCdzdGFydF9kYXRlJywgeyBhc2NlbmRpbmc6IHRydWUgfSlcblxuICAgIGlmIChidWRnZXRzRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGJ1ZGdldHM6JywgYnVkZ2V0c0Vycm9yKVxuICAgIH1cblxuICAgIC8vIEdldCBjdXJyZW50IGNhc2ggYmFsYW5jZSAoc3VtIG9mIGNhc2gvYmFuayBhY2NvdW50IGJhbGFuY2VzIG9ubHkpXG4gICAgLy8gRXhjbHVkZXMgZGVidCBhY2NvdW50cyAoY3JlZGl0X2NhcmQsIGNyZWRpdF9saW5lLCB0ZXJtX2xvYW4pIGFuZCBsb2FuX3JlY2VpdmFibGVcbiAgICBjb25zdCB7IGRhdGE6IGFjY291bnRzLCBlcnJvcjogYWNjb3VudHNFcnJvcn0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2FjY291bnRzJylcbiAgICAgIC5zZWxlY3QoJ2FjY291bnRfaWQsIGFjY291bnRfbmFtZSwgYWNjb3VudF90eXBlJylcbiAgICAgIC5lcSgnZW50aXR5X2lkJywgZW50aXR5SWQpXG4gICAgICAuZXEoJ2lzX2FjdGl2ZScsIHRydWUpXG4gICAgICAuaW4oJ2FjY291bnRfdHlwZScsIFsnYmFuaycsICdjYXNoJywgJ2ludmVzdG1lbnQnXSkgLy8gT25seSBsaXF1aWQgYXNzZXQgYWNjb3VudHNcblxuICAgIGlmIChhY2NvdW50c0Vycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBhY2NvdW50czonLCBhY2NvdW50c0Vycm9yKVxuICAgIH1cblxuICAgIC8vIEZldGNoIGNyZWRpdCBsaW5lIGFjY291bnRzIHdpdGggdGhlaXIgbGltaXRzIGFuZCB1c2FnZVxuICAgIGNvbnN0IHsgZGF0YTogY3JlZGl0TGluZUFjY291bnRzLCBlcnJvcjogY3JlZGl0TGluZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2FjY291bnRzJylcbiAgICAgIC5zZWxlY3QoJ2FjY291bnRfaWQsIGFjY291bnRfbmFtZSwgY3JlZGl0X2xpbWl0LCBiYW5rX25hbWUnKVxuICAgICAgLmVxKCdlbnRpdHlfaWQnLCBlbnRpdHlJZClcbiAgICAgIC5lcSgnaXNfYWN0aXZlJywgdHJ1ZSlcbiAgICAgIC5pbignYWNjb3VudF90eXBlJywgWydjcmVkaXRfbGluZScsICd0ZXJtX2xvYW4nXSlcbiAgICAgIC5ub3QoJ2NyZWRpdF9saW1pdCcsICdpcycsIG51bGwpXG5cbiAgICBpZiAoY3JlZGl0TGluZUVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBjcmVkaXQgbGluZXM6JywgY3JlZGl0TGluZUVycm9yKVxuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSB1c2VkIGFtb3VudCBmb3IgZWFjaCBjcmVkaXQgbGluZSBmcm9tIGFjdGl2ZSBkZWJ0IGRyYXdkb3duc1xuICAgIGNvbnN0IGNyZWRpdExpbmVzID0gYXdhaXQgUHJvbWlzZS5hbGwoKGNyZWRpdExpbmVBY2NvdW50cyB8fCBbXSkubWFwKGFzeW5jIChhY2NvdW50KSA9PiB7XG4gICAgICBjb25zdCB7IGRhdGE6IGRyYXdkb3ducyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2RlYnRfZHJhd2Rvd24nKVxuICAgICAgICAuc2VsZWN0KCdyZW1haW5pbmdfYmFsYW5jZScpXG4gICAgICAgIC5lcSgnYWNjb3VudF9pZCcsIGFjY291bnQuYWNjb3VudF9pZClcbiAgICAgICAgLmluKCdzdGF0dXMnLCBbJ2FjdGl2ZScsICdvdmVyZHVlJ10pXG5cbiAgICAgIGNvbnN0IHVzZWRBbW91bnQgPSBkcmF3ZG93bnM/LnJlZHVjZSgoc3VtLCBkKSA9PiBzdW0gKyAoZC5yZW1haW5pbmdfYmFsYW5jZSB8fCAwKSwgMCkgfHwgMFxuICAgICAgY29uc3QgY3JlZGl0TGltaXQgPSBhY2NvdW50LmNyZWRpdF9saW1pdCB8fCAwXG4gICAgICBjb25zdCBhdmFpbGFibGVDcmVkaXQgPSBjcmVkaXRMaW1pdCAtIHVzZWRBbW91bnRcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWNjb3VudF9pZDogYWNjb3VudC5hY2NvdW50X2lkLFxuICAgICAgICBhY2NvdW50X25hbWU6IGFjY291bnQuYWNjb3VudF9uYW1lLFxuICAgICAgICBiYW5rX25hbWU6IGFjY291bnQuYmFua19uYW1lLFxuICAgICAgICBjcmVkaXRfbGltaXQ6IGNyZWRpdExpbWl0LFxuICAgICAgICB1c2VkX2Ftb3VudDogdXNlZEFtb3VudCxcbiAgICAgICAgYXZhaWxhYmxlX2NyZWRpdDogYXZhaWxhYmxlQ3JlZGl0LFxuICAgICAgICB1dGlsaXphdGlvbl9wZXJjZW50OiBjcmVkaXRMaW1pdCA+IDAgPyAodXNlZEFtb3VudCAvIGNyZWRpdExpbWl0KSAqIDEwMCA6IDBcbiAgICAgIH1cbiAgICB9KSlcblxuICAgIC8vIENhbGN1bGF0ZSB0b3RhbCBjcmVkaXQgbGluZSBhdmFpbGFiaWxpdHlcbiAgICBjb25zdCB0b3RhbENyZWRpdExpbWl0ID0gY3JlZGl0TGluZXMucmVkdWNlKChzdW0sIGNsKSA9PiBzdW0gKyBjbC5jcmVkaXRfbGltaXQsIDApXG4gICAgY29uc3QgdG90YWxDcmVkaXRVc2VkID0gY3JlZGl0TGluZXMucmVkdWNlKChzdW0sIGNsKSA9PiBzdW0gKyBjbC51c2VkX2Ftb3VudCwgMClcbiAgICBjb25zdCB0b3RhbENyZWRpdEF2YWlsYWJsZSA9IHRvdGFsQ3JlZGl0TGltaXQgLSB0b3RhbENyZWRpdFVzZWRcblxuICAgIGNvbnNvbGUubG9nKGBbQ2FzaCBGbG93XSBGb3VuZCAke2FjY291bnRzPy5sZW5ndGggfHwgMH0gY2FzaC9iYW5rL2ludmVzdG1lbnQgYWNjb3VudHMgZm9yIGVudGl0eSAke2VudGl0eUlkfWApXG4gICAgY29uc29sZS5sb2coYFtDYXNoIEZsb3ddIEFjY291bnRzOiAke2FjY291bnRzPy5tYXAoYSA9PiBgJHthLmFjY291bnRfbmFtZX0oJHthLmFjY291bnRfdHlwZX0pYCkuam9pbignLCAnKX1gKVxuXG4gICAgY29uc3QgYWNjb3VudElkcyA9IGFjY291bnRzPy5tYXAoYSA9PiBhLmFjY291bnRfaWQpIHx8IFtdXG5cbiAgICAvLyBHZXQgY3VycmVudCBiYWxhbmNlcyBieSBjYWxjdWxhdGluZyBmcm9tIHRyYW5zYWN0aW9uc1xuICAgIGxldCBjdXJyZW50QmFsYW5jZSA9IDBcbiAgICBpZiAoYWNjb3VudElkcy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBDYWxjdWxhdGUgYmFsYW5jZSBmb3IgZWFjaCBhY2NvdW50IHVwIHRvIHRvZGF5XG4gICAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKClcbiAgICAgIGZvciAoY29uc3QgYWNjb3VudCBvZiAoYWNjb3VudHMgfHwgW10pKSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YTogYmFsYW5jZSwgZXJyb3I6IGJhbGFuY2VFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UucnBjKCdjYWxjdWxhdGVfYmFsYW5jZV91cF90b19kYXRlJywge1xuICAgICAgICAgIHBfYWNjb3VudF9pZDogYWNjb3VudC5hY2NvdW50X2lkLFxuICAgICAgICAgIHBfdXBfdG9fZGF0ZTogdG9kYXkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLCAvLyBZWVlZLU1NLUREXG4gICAgICAgIH0pXG4gICAgICAgIGlmIChiYWxhbmNlRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBbQ2FzaCBGbG93XSBFcnJvciBjYWxjdWxhdGluZyBiYWxhbmNlIGZvciAke2FjY291bnQuYWNjb3VudF9uYW1lfTpgLCBKU09OLnN0cmluZ2lmeShiYWxhbmNlRXJyb3IpKVxuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKGBbQ2FzaCBGbG93XSAke2FjY291bnQuYWNjb3VudF9uYW1lfSAoJHthY2NvdW50LmFjY291bnRfdHlwZX0pIGJhbGFuY2U6ICR7YmFsYW5jZSB8fCAwfWApXG4gICAgICAgIGN1cnJlbnRCYWxhbmNlICs9IChiYWxhbmNlIHx8IDApXG4gICAgICB9XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKGBbQ2FzaCBGbG93XSBUb3RhbCBjdXJyZW50IGJhbGFuY2UgKGNhc2gvYmFuay9pbnZlc3RtZW50IG9ubHkpOiAke2N1cnJlbnRCYWxhbmNlfWApXG5cbiAgICAvLyA9PT0gQ0FTSCBGTE9XIFNZU1RFTSAyLjA6IENhbGN1bGF0ZSBwcmVkaWN0ZWQgaW5jb21lIChvbmNlIGZvciBhbGwgbW9udGhzKSA9PT1cbiAgICBjb25zdCB7IHRvdGFsOiBwcmVkaWN0ZWRNb250aGx5SW5jb21lLCBicmVha2Rvd246IGluY29tZUJyZWFrZG93biB9ID0gYXdhaXQgY2FsY3VsYXRlUHJlZGljdGVkSW5jb21lKGVudGl0eUlkKVxuXG4gICAgY29uc29sZS5sb2coYFtDYXNoIEZsb3cgMi4wXSBQcmVkaWN0ZWQgbW9udGhseSBpbmNvbWU6ICR7cHJlZGljdGVkTW9udGhseUluY29tZS50b0xvY2FsZVN0cmluZygpfSBWTkRgKVxuICAgIGNvbnNvbGUubG9nKGBbQ2FzaCBGbG93IDIuMF0gSW5jb21lIHNvdXJjZXM6ICR7aW5jb21lQnJlYWtkb3duLmxlbmd0aH1gKVxuXG4gICAgLy8gQnVpbGQgbW9udGhseSBwcm9qZWN0aW9uc1xuICAgIGNvbnN0IHByb2plY3Rpb25zID0gYXdhaXQgUHJvbWlzZS5hbGwobW9udGhzLm1hcChhc3luYyAobW9udGgpID0+IHtcbiAgICAgIGNvbnN0IG1vbnRoS2V5ID0gZm9ybWF0KG1vbnRoLCAneXl5eS1NTScpXG4gICAgICBjb25zdCBtb250aFN0YXJ0ID0gc3RhcnRPZk1vbnRoKG1vbnRoKVxuICAgICAgY29uc3QgbW9udGhFbmQgPSBlbmRPZk1vbnRoKG1vbnRoKVxuXG4gICAgICAvLyA9PT0gUFJJT1JJVFkgMTogREVCVCBQQVlNRU5UUyAoRHJhd2Rvd25zIHdlIG5lZWQgdG8gcmVwYXkpID09PVxuICAgICAgY29uc3QgbW9udGhEZWJ0UGF5bWVudHMgPSAoZGVidERyYXdkb3ducyB8fCBbXSkuZmlsdGVyKChkcmF3ZG93bjogYW55KSA9PiB7XG4gICAgICAgIGNvbnN0IGR1ZURhdGUgPSBwYXJzZUlTTyhkcmF3ZG93bi5kdWVfZGF0ZSlcbiAgICAgICAgcmV0dXJuIGR1ZURhdGUgPj0gbW9udGhTdGFydCAmJiBkdWVEYXRlIDw9IG1vbnRoRW5kXG4gICAgICB9KS5tYXAoKGRyYXdkb3duOiBhbnkpID0+ICh7XG4gICAgICAgIHR5cGU6ICdEZWJ0IFJlcGF5bWVudCcsXG4gICAgICAgIGxvYW5fbmFtZTogZHJhd2Rvd24uYWNjb3VudHM/LmFjY291bnRfbmFtZSB8fCAnRGVidCBBY2NvdW50JyxcbiAgICAgICAgZHJhd2Rvd25fcmVmZXJlbmNlOiBkcmF3ZG93bi5kcmF3ZG93bl9yZWZlcmVuY2UgfHwgJ1Vua25vd24nLFxuICAgICAgICBhbW91bnQ6IGRyYXdkb3duLnJlbWFpbmluZ19iYWxhbmNlIHx8IDAsXG4gICAgICAgIGR1ZV9kYXRlOiBkcmF3ZG93bi5kdWVfZGF0ZSxcbiAgICAgICAgc3RhdHVzOiBkcmF3ZG93bi5zdGF0dXMsXG4gICAgICAgIGFjY291bnRfdHlwZTogZHJhd2Rvd24uYWNjb3VudHM/LmFjY291bnRfdHlwZSB8fCAndW5rbm93bidcbiAgICAgIH0pKVxuXG4gICAgICAvLyA9PT0gUFJJT1JJVFkgMTogU0NIRURVTEVEIFBBWU1FTlRTID09PVxuICAgICAgY29uc3QgbW9udGhTY2hlZHVsZWRQYXltZW50cyA9IChzY2hlZHVsZWRJbnN0YW5jZXMgfHwgW10pLmZpbHRlcigoaW5zdGFuY2U6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCBkdWVEYXRlID0gcGFyc2VJU08oaW5zdGFuY2UuZHVlX2RhdGUpXG4gICAgICAgIHJldHVybiBkdWVEYXRlID49IG1vbnRoU3RhcnQgJiYgZHVlRGF0ZSA8PSBtb250aEVuZFxuICAgICAgfSkubWFwKChpbnN0YW5jZTogYW55KSA9PiAoe1xuICAgICAgICBjb250cmFjdF9uYW1lOiBpbnN0YW5jZS5zY2hlZHVsZWRfcGF5bWVudHM/LmNvbnRyYWN0X25hbWUgfHwgJ1Vua25vd24nLFxuICAgICAgICBwYXltZW50X3R5cGU6IGluc3RhbmNlLnNjaGVkdWxlZF9wYXltZW50cz8ucGF5bWVudF90eXBlLFxuICAgICAgICBwYXllZV9uYW1lOiBpbnN0YW5jZS5zY2hlZHVsZWRfcGF5bWVudHM/LnBheWVlX25hbWUgfHwgJ1Vua25vd24nLFxuICAgICAgICBhbW91bnQ6IGluc3RhbmNlLmFtb3VudCB8fCAwLFxuICAgICAgICBkdWVfZGF0ZTogaW5zdGFuY2UuZHVlX2RhdGUsXG4gICAgICAgIHN0YXR1czogaW5zdGFuY2Uuc3RhdHVzLFxuICAgICAgICBjYXRlZ29yeV9pZDogaW5zdGFuY2Uuc2NoZWR1bGVkX3BheW1lbnRzPy5jYXRlZ29yeV9pZCxcbiAgICAgICAgY2F0ZWdvcnlfbmFtZTogaW5zdGFuY2Uuc2NoZWR1bGVkX3BheW1lbnRzPy5jYXRlZ29yaWVzPy5jYXRlZ29yeV9uYW1lIHx8ICdVbmNhdGVnb3JpemVkJ1xuICAgICAgfSkpXG5cbiAgICAgIC8vID09PSBQUklPUklUWSAyOiBQUkVESUNURUQgRVhQRU5TRVMgKENhc2ggRmxvdyAyLjApID09PVxuICAgICAgLy8gT25seSBwcmVkaWN0IGZvciBjYXRlZ29yaWVzIE5PVCBjb3ZlcmVkIGJ5IHNjaGVkdWxlZCBwYXltZW50c1xuICAgICAgY29uc3QgcHJlZGljdGVkRXhwZW5zZXMgPSBhd2FpdCBjYWxjdWxhdGVQcmVkaWN0ZWRFeHBlbnNlcyhlbnRpdHlJZCwgbW9udGhLZXkpXG5cbiAgICAgIGNvbnN0IHRvdGFsUHJlZGljdGVkID0gcHJlZGljdGVkRXhwZW5zZXMucmVkdWNlKChzdW0sIGV4cCkgPT4gc3VtICsgZXhwLmFtb3VudCwgMClcblxuICAgICAgLy8gPT09IFBSSU9SSVRZIDM6IEJVREdFVFMgKG9ubHkgZm9yIGNhdGVnb3JpZXMgd2l0aCBubyBzY2hlZHVsZSBBTkQgbm8gaGlzdG9yeSkgPT09XG4gICAgICAvLyBHZXQgY2F0ZWdvcmllcyBhbHJlYWR5IGNvdmVyZWRcbiAgICAgIGNvbnN0IHNjaGVkdWxlZENhdGVnb3J5SWRzID0gYXdhaXQgZ2V0Q2F0ZWdvcmllc1dpdGhTY2hlZHVsZWRQYXltZW50cyhlbnRpdHlJZCwgbW9udGhLZXkpXG4gICAgICBjb25zdCBwcmVkaWN0ZWRDYXRlZ29yeU5hbWVzID0gbmV3IFNldChwcmVkaWN0ZWRFeHBlbnNlcy5tYXAoZXhwID0+IGV4cC5jYXRlZ29yeV9uYW1lKSlcblxuICAgICAgY29uc3QgbW9udGhCdWRnZXRzID0gKGJ1ZGdldHMgfHwgW10pLmZpbHRlcigoYnVkZ2V0OiBhbnkpID0+IHtcbiAgICAgICAgY29uc3QgYnVkZ2V0U3RhcnQgPSBwYXJzZUlTTyhidWRnZXQuc3RhcnRfZGF0ZSlcbiAgICAgICAgY29uc3QgYnVkZ2V0RW5kID0gcGFyc2VJU08oYnVkZ2V0LmVuZF9kYXRlKVxuICAgICAgICBjb25zdCBjYXRlZ29yeUlkID0gYnVkZ2V0LmNhdGVnb3J5X2lkXG4gICAgICAgIGNvbnN0IGNhdGVnb3J5TmFtZSA9IGJ1ZGdldC5jYXRlZ29yaWVzPy5jYXRlZ29yeV9uYW1lIHx8ICdVbmtub3duJ1xuXG4gICAgICAgIC8vIE9ubHkgaW5jbHVkZSBidWRnZXQgaWY6XG4gICAgICAgIC8vIDEuIEl0J3MgYWN0aXZlIHRoaXMgbW9udGhcbiAgICAgICAgLy8gMi4gTk9UIGluIHNjaGVkdWxlZCBwYXltZW50cyAoUHJpb3JpdHkgMSlcbiAgICAgICAgLy8gMy4gTk9UIGluIHByZWRpY3RlZCBleHBlbnNlcyAoUHJpb3JpdHkgMilcbiAgICAgICAgcmV0dXJuIGJ1ZGdldFN0YXJ0IDw9IG1vbnRoRW5kICYmXG4gICAgICAgICAgICAgICBidWRnZXRFbmQgPj0gbW9udGhTdGFydCAmJlxuICAgICAgICAgICAgICAgIXNjaGVkdWxlZENhdGVnb3J5SWRzLmhhcyhjYXRlZ29yeUlkKSAmJlxuICAgICAgICAgICAgICAgIXByZWRpY3RlZENhdGVnb3J5TmFtZXMuaGFzKGNhdGVnb3J5TmFtZSlcbiAgICAgIH0pLm1hcCgoYnVkZ2V0OiBhbnkpID0+ICh7XG4gICAgICAgIGNhdGVnb3J5X25hbWU6IGJ1ZGdldC5jYXRlZ29yaWVzPy5jYXRlZ29yeV9uYW1lIHx8ICdVbmtub3duJyxcbiAgICAgICAgYnVkZ2V0X2Ftb3VudDogYnVkZ2V0LmJ1ZGdldF9hbW91bnQgfHwgMCxcbiAgICAgICAgZXN0aW1hdGVkX3NwZW5kOiBidWRnZXQuYnVkZ2V0X2Ftb3VudCB8fCAwXG4gICAgICB9KSlcblxuICAgICAgLy8gPT09IEJVREdFVCBXQVJOSU5HUyAoQ2FzaCBGbG93IDIuMCkgPT09XG4gICAgICBjb25zdCBhbGxCdWRnZXRzID0gKGJ1ZGdldHMgfHwgW10pXG4gICAgICAgIC5maWx0ZXIoKGJ1ZGdldDogYW55KSA9PiB7XG4gICAgICAgICAgY29uc3QgYnVkZ2V0U3RhcnQgPSBwYXJzZUlTTyhidWRnZXQuc3RhcnRfZGF0ZSlcbiAgICAgICAgICBjb25zdCBidWRnZXRFbmQgPSBwYXJzZUlTTyhidWRnZXQuZW5kX2RhdGUpXG4gICAgICAgICAgcmV0dXJuIGJ1ZGdldFN0YXJ0IDw9IG1vbnRoRW5kICYmIGJ1ZGdldEVuZCA+PSBtb250aFN0YXJ0XG4gICAgICAgIH0pXG4gICAgICAgIC5tYXAoKGJ1ZGdldDogYW55KSA9PiAoe1xuICAgICAgICAgIGNhdGVnb3J5X25hbWU6IGJ1ZGdldC5jYXRlZ29yaWVzPy5jYXRlZ29yeV9uYW1lIHx8ICdVbmtub3duJyxcbiAgICAgICAgICBidWRnZXRfYW1vdW50OiBidWRnZXQuYnVkZ2V0X2Ftb3VudCB8fCAwXG4gICAgICAgIH0pKVxuXG4gICAgICBjb25zdCBidWRnZXRXYXJuaW5ncyA9IGNvbXBhcmVCdWRnZXRzKHByZWRpY3RlZEV4cGVuc2VzLCBhbGxCdWRnZXRzKVxuXG4gICAgICAvLyBDYWxjdWxhdGUgdG90YWxzXG4gICAgICBjb25zdCB0b3RhbERlYnQgPSBtb250aERlYnRQYXltZW50cy5yZWR1Y2UoKHN1bTogbnVtYmVyLCBwOiBhbnkpID0+IHN1bSArIHAuYW1vdW50LCAwKVxuICAgICAgY29uc3QgdG90YWxTY2hlZHVsZWQgPSBtb250aFNjaGVkdWxlZFBheW1lbnRzLnJlZHVjZSgoc3VtOiBudW1iZXIsIHA6IGFueSkgPT4gc3VtICsgcC5hbW91bnQsIDApXG4gICAgICBjb25zdCB0b3RhbEJ1ZGdldHMgPSBtb250aEJ1ZGdldHMucmVkdWNlKChzdW06IG51bWJlciwgYjogYW55KSA9PiBzdW0gKyBiLmVzdGltYXRlZF9zcGVuZCwgMClcbiAgICAgIGNvbnN0IHRvdGFsT2JsaWdhdGlvbnMgPSB0b3RhbERlYnQgKyB0b3RhbFNjaGVkdWxlZCArIHRvdGFsUHJlZGljdGVkICsgdG90YWxCdWRnZXRzXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vbnRoOiBtb250aEtleSxcbiAgICAgICAgbW9udGhfbGFiZWw6IGZvcm1hdChtb250aCwgJ01NTU0geXl5eScpLFxuICAgICAgICBkZWJ0X3BheW1lbnRzOiBtb250aERlYnRQYXltZW50cyxcbiAgICAgICAgc2NoZWR1bGVkX3BheW1lbnRzOiBtb250aFNjaGVkdWxlZFBheW1lbnRzLFxuICAgICAgICBwcmVkaWN0ZWRfZXhwZW5zZXM6IHByZWRpY3RlZEV4cGVuc2VzLFxuICAgICAgICBidWRnZXRzOiBtb250aEJ1ZGdldHMsXG4gICAgICAgIHRvdGFsX2RlYnQ6IHRvdGFsRGVidCxcbiAgICAgICAgdG90YWxfc2NoZWR1bGVkOiB0b3RhbFNjaGVkdWxlZCxcbiAgICAgICAgdG90YWxfcHJlZGljdGVkOiB0b3RhbFByZWRpY3RlZCxcbiAgICAgICAgdG90YWxfYnVkZ2V0czogdG90YWxCdWRnZXRzLFxuICAgICAgICB0b3RhbF9vYmxpZ2F0aW9uczogdG90YWxPYmxpZ2F0aW9ucyxcbiAgICAgICAgaW5jb21lX2JyZWFrZG93bjogaW5jb21lQnJlYWtkb3duLFxuICAgICAgICBidWRnZXRfd2FybmluZ3M6IGJ1ZGdldFdhcm5pbmdzXG4gICAgICB9XG4gICAgfSkpXG5cbiAgICAvLyA9PT0gQ0FTSCBGTE9XIDIuMDogQ2FsY3VsYXRlIHJ1bm5pbmcgYmFsYW5jZXMgV0lUSCBwcmVkaWN0ZWQgaW5jb21lID09PVxuICAgIC8vID09PSBDQVNIIEZMT1cgMy4xOiBBcHBseSBzY2VuYXJpbyBhZGp1c3RtZW50cyBpZiBwcm92aWRlZCA9PT1cbiAgICBsZXQgcnVubmluZ0JhbGFuY2UgPSBjdXJyZW50QmFsYW5jZVxuICAgIGNvbnN0IHByb2plY3Rpb25zV2l0aEJhbGFuY2UgPSBwcm9qZWN0aW9ucy5tYXAoKHByb2opID0+IHtcbiAgICAgIGNvbnN0IG9wZW5pbmdCYWxhbmNlID0gcnVubmluZ0JhbGFuY2VcbiAgICAgIGxldCBwcm9qZWN0ZWRJbmNvbWUgPSBwcmVkaWN0ZWRNb250aGx5SW5jb21lIC8vIFVzZSBwcmVkaWN0ZWQgaW5jb21lIGZyb20gaGlzdG9yaWNhbCBkYXRhXG4gICAgICBsZXQgdG90YWxQcmVkaWN0ZWRXaXRoU2NlbmFyaW8gPSBwcm9qLnRvdGFsX3ByZWRpY3RlZFxuXG4gICAgICAvLyBBcHBseSBzY2VuYXJpbyBhZGp1c3RtZW50c1xuICAgICAgbGV0IHNjZW5hcmlvSXRlbXM6IHsgbmFtZTogc3RyaW5nOyBhbW91bnQ6IG51bWJlcjsgdHlwZTogc3RyaW5nIH1bXSA9IFtdXG4gICAgICBsZXQgc2NlbmFyaW9EZWJ0RHJhd2Rvd24gPSAwXG4gICAgICBsZXQgc2NlbmFyaW9EZWJ0UmVwYXltZW50ID0gMFxuICAgICAgbGV0IHNjZW5hcmlvSW5jb21lID0gMFxuICAgICAgbGV0IHNjZW5hcmlvRXhwZW5zZSA9IDBcblxuICAgICAgaWYgKHNjZW5hcmlvQWRqdXN0bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBhZGp1c3RlZCA9IGFwcGx5U2NlbmFyaW9BZGp1c3RtZW50cyhcbiAgICAgICAgICBwcm9qLm1vbnRoLFxuICAgICAgICAgIHByb2plY3RlZEluY29tZSxcbiAgICAgICAgICBwcm9qLnRvdGFsX3ByZWRpY3RlZCxcbiAgICAgICAgICBzY2VuYXJpb0FkanVzdG1lbnRzXG4gICAgICAgIClcbiAgICAgICAgcHJvamVjdGVkSW5jb21lID0gYWRqdXN0ZWQuYWRqdXN0ZWRJbmNvbWVcbiAgICAgICAgdG90YWxQcmVkaWN0ZWRXaXRoU2NlbmFyaW8gPSBhZGp1c3RlZC5hZGp1c3RlZFByZWRpY3RlZFxuICAgICAgICBzY2VuYXJpb0l0ZW1zID0gYWRqdXN0ZWQuc2NlbmFyaW9JdGVtc1xuICAgICAgICBzY2VuYXJpb0RlYnREcmF3ZG93biA9IGFkanVzdGVkLnNjZW5hcmlvRGVidERyYXdkb3duXG4gICAgICAgIHNjZW5hcmlvRGVidFJlcGF5bWVudCA9IGFkanVzdGVkLnNjZW5hcmlvRGVidFJlcGF5bWVudFxuICAgICAgICBzY2VuYXJpb0luY29tZSA9IGFkanVzdGVkLnNjZW5hcmlvSW5jb21lXG4gICAgICAgIHNjZW5hcmlvRXhwZW5zZSA9IGFkanVzdGVkLnNjZW5hcmlvRXhwZW5zZVxuXG4gICAgICB9XG5cbiAgICAgIC8vIFJlY2FsY3VsYXRlIHRvdGFsIG9ibGlnYXRpb25zIHdpdGggc2NlbmFyaW8gYWRqdXN0bWVudHNcbiAgICAgIGNvbnN0IHRvdGFsT2JsaWdhdGlvbnNXaXRoU2NlbmFyaW8gPSBwcm9qLnRvdGFsX2RlYnQgKyBwcm9qLnRvdGFsX3NjaGVkdWxlZCArIHRvdGFsUHJlZGljdGVkV2l0aFNjZW5hcmlvICsgcHJvai50b3RhbF9idWRnZXRzXG4gICAgICBjb25zdCBjbG9zaW5nQmFsYW5jZSA9IG9wZW5pbmdCYWxhbmNlICsgcHJvamVjdGVkSW5jb21lIC0gdG90YWxPYmxpZ2F0aW9uc1dpdGhTY2VuYXJpb1xuICAgICAgcnVubmluZ0JhbGFuY2UgPSBjbG9zaW5nQmFsYW5jZVxuXG4gICAgICAvLyBEZXRlcm1pbmUgaGVhbHRoIHN0YXR1c1xuICAgICAgbGV0IGhlYWx0aDogJ3N1cnBsdXMnIHwgJ3RpZ2h0JyB8ICdkZWZpY2l0J1xuICAgICAgaWYgKGNsb3NpbmdCYWxhbmNlIDwgMCkge1xuICAgICAgICBoZWFsdGggPSAnZGVmaWNpdCdcbiAgICAgIH0gZWxzZSBpZiAoY2xvc2luZ0JhbGFuY2UgPCBvcGVuaW5nQmFsYW5jZSAqIDAuMikge1xuICAgICAgICBoZWFsdGggPSAndGlnaHQnXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZWFsdGggPSAnc3VycGx1cydcbiAgICAgIH1cblxuICAgICAgLy8gQ2FsY3VsYXRlIGJhc2UgaW5jb21lICh3aXRob3V0IHNjZW5hcmlvIGFkanVzdG1lbnRzKSBmb3IgY2hhcnQgZGlzcGxheVxuICAgICAgY29uc3QgYmFzZUluY29tZSA9IHByZWRpY3RlZE1vbnRobHlJbmNvbWVcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucHJvaixcbiAgICAgICAgb3BlbmluZ19iYWxhbmNlOiBvcGVuaW5nQmFsYW5jZSxcbiAgICAgICAgcHJvamVjdGVkX2luY29tZTogcHJvamVjdGVkSW5jb21lLFxuICAgICAgICBiYXNlX2luY29tZTogYmFzZUluY29tZSwgLy8gTkVXOiBCYXNlIGluY29tZSBiZWZvcmUgc2NlbmFyaW8gYWRqdXN0bWVudHNcbiAgICAgICAgc2NlbmFyaW9fZGVidF9kcmF3ZG93bjogc2NlbmFyaW9EZWJ0RHJhd2Rvd24sIC8vIE5FVzogRGVidCBkcmF3ZG93biBmcm9tIHNjZW5hcmlvc1xuICAgICAgICBzY2VuYXJpb19kZWJ0X3JlcGF5bWVudDogc2NlbmFyaW9EZWJ0UmVwYXltZW50LCAvLyBORVc6IERlYnQgcmVwYXltZW50IGZyb20gc2NlbmFyaW9zIChleHBlbnNlKVxuICAgICAgICBzY2VuYXJpb19pbmNvbWU6IHNjZW5hcmlvSW5jb21lLCAvLyBORVc6IEFkZGl0aW9uYWwgaW5jb21lIGZyb20gc2NlbmFyaW9zXG4gICAgICAgIHNjZW5hcmlvX2V4cGVuc2U6IHNjZW5hcmlvRXhwZW5zZSwgLy8gTkVXOiBBZGRpdGlvbmFsIGV4cGVuc2UgZnJvbSBzY2VuYXJpb3NcbiAgICAgICAgdG90YWxfcHJlZGljdGVkOiB0b3RhbFByZWRpY3RlZFdpdGhTY2VuYXJpbyxcbiAgICAgICAgdG90YWxfb2JsaWdhdGlvbnM6IHRvdGFsT2JsaWdhdGlvbnNXaXRoU2NlbmFyaW8sXG4gICAgICAgIGNsb3NpbmdfYmFsYW5jZTogY2xvc2luZ0JhbGFuY2UsXG4gICAgICAgIGhlYWx0aCxcbiAgICAgICAgc2NlbmFyaW9faXRlbXM6IHNjZW5hcmlvSXRlbXMgLy8gTkVXOiBJdGVtcyBmcm9tIHNjZW5hcmlvIGFkanVzdG1lbnRzXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vID09PSBDQVNIIEZMT1cgMi4wOiBFbmhhbmNlZCBzdW1tYXJ5IHN0YXRpc3RpY3MgPT09XG4gICAgY29uc3QgdG90YWxPYmxpZ2F0aW9ucyA9IHByb2plY3Rpb25zLnJlZHVjZSgoc3VtLCBwKSA9PiBzdW0gKyBwLnRvdGFsX29ibGlnYXRpb25zLCAwKVxuICAgIGNvbnN0IHRvdGFsUHJvamVjdGVkSW5jb21lID0gcHJlZGljdGVkTW9udGhseUluY29tZSAqIG1vbnRoc0FoZWFkXG4gICAgY29uc3QgbG93ZXN0QmFsYW5jZSA9IE1hdGgubWluKC4uLnByb2plY3Rpb25zV2l0aEJhbGFuY2UubWFwKHAgPT4gcC5jbG9zaW5nX2JhbGFuY2UpKVxuICAgIGNvbnN0IG1vbnRoc1VudGlsTmVnYXRpdmUgPSBwcm9qZWN0aW9uc1dpdGhCYWxhbmNlLmZpbmRJbmRleChwID0+IHAuY2xvc2luZ19iYWxhbmNlIDwgMClcblxuICAgIGNvbnNvbGUubG9nKGBbQ2FzaCBGbG93IDIuMF0gVG90YWwgb2JsaWdhdGlvbnMgKCR7bW9udGhzQWhlYWR9IG1vbnRocyk6ICR7dG90YWxPYmxpZ2F0aW9ucy50b0xvY2FsZVN0cmluZygpfSBWTkRgKVxuICAgIGNvbnNvbGUubG9nKGBbQ2FzaCBGbG93IDIuMF0gVG90YWwgcHJvamVjdGVkIGluY29tZSAoJHttb250aHNBaGVhZH0gbW9udGhzKTogJHt0b3RhbFByb2plY3RlZEluY29tZS50b0xvY2FsZVN0cmluZygpfSBWTkRgKVxuICAgIGNvbnNvbGUubG9nKGBbQ2FzaCBGbG93IDIuMF0gTmV0IGNoYW5nZTogJHsodG90YWxQcm9qZWN0ZWRJbmNvbWUgLSB0b3RhbE9ibGlnYXRpb25zKS50b0xvY2FsZVN0cmluZygpfSBWTkRgKVxuICAgIGNvbnNvbGUubG9nKGBbQ2FzaCBGbG93IDIuMF0gTG93ZXN0IHByb2plY3RlZCBiYWxhbmNlOiAke2xvd2VzdEJhbGFuY2UudG9Mb2NhbGVTdHJpbmcoKX0gVk5EYClcblxuICAgIC8vID09PSBDQVNIIEZMT1cgMy4wOiBMSVFVSURJVFkgJiBTT0xWRU5DWSBBTkFMWVNJUyA9PT1cbiAgICBjb25zdCBsaXF1aWRpdHlQb3NpdGlvbiA9IGF3YWl0IGFuYWx5emVMaXF1aWRpdHlQb3NpdGlvbihlbnRpdHlJZClcbiAgICBjb25zdCBtb250aGx5QnVyblJhdGUgPSB0b3RhbE9ibGlnYXRpb25zIC8gbW9udGhzQWhlYWRcbiAgICBjb25zdCBydW53YXlBbmFseXNpcyA9IGNhbGN1bGF0ZVJ1bndheUFuYWx5c2lzKFxuICAgICAgbGlxdWlkaXR5UG9zaXRpb24sXG4gICAgICBtb250aGx5QnVyblJhdGUsXG4gICAgICBwcmVkaWN0ZWRNb250aGx5SW5jb21lLFxuICAgICAgbW9udGhzQWhlYWRcbiAgICApXG5cbiAgICBjb25zb2xlLmxvZyhgW0Nhc2ggRmxvdyAzLjBdIFRvdGFsIGxpcXVpZCBhc3NldHM6ICR7bGlxdWlkaXR5UG9zaXRpb24udG90YWxfbGlxdWlkX2Fzc2V0cy50b0xvY2FsZVN0cmluZygpfSBWTkRgKVxuICAgIGNvbnNvbGUubG9nKGBbQ2FzaCBGbG93IDMuMF0gQ2FzaCBydW53YXk6ICR7cnVud2F5QW5hbHlzaXMuY2FzaF9ydW53YXlfbW9udGhzLnRvRml4ZWQoMSl9IG1vbnRoc2ApXG4gICAgY29uc29sZS5sb2coYFtDYXNoIEZsb3cgMy4wXSBMaXF1aWRpdHkgcnVud2F5OiAke3J1bndheUFuYWx5c2lzLmxpcXVpZGl0eV9ydW53YXlfbW9udGhzLnRvRml4ZWQoMSl9IG1vbnRoc2ApXG5cbiAgICAvLyBDYWxjdWxhdGUgdG90YWwgc2NlbmFyaW8gZGVidCBkcmF3ZG93biAocmVkdWNlcyBjcmVkaXQgYXZhaWxhYmlsaXR5IGZvciBzY2VuYXJpbylcbiAgICBjb25zdCB0b3RhbFNjZW5hcmlvRGVidERyYXdkb3duID0gcHJvamVjdGlvbnNXaXRoQmFsYW5jZS5yZWR1Y2UoXG4gICAgICAoc3VtLCBwcm9qKSA9PiBzdW0gKyAocHJvai5zY2VuYXJpb19kZWJ0X2RyYXdkb3duIHx8IDApLCAwXG4gICAgKVxuXG4gICAgLy8gQ2FsY3VsYXRlIHByb2plY3RlZCBjcmVkaXQgYXZhaWxhYmlsaXR5IHBlciBtb250aFxuICAgIC8vIEFzIGRlYnQgcGF5bWVudHMgYXJlIG1hZGUsIGNyZWRpdCBhdmFpbGFiaWxpdHkgaW5jcmVhc2VzXG4gICAgLy8gU2NlbmFyaW8gZGVidCBkcmF3ZG93bnMgcmVkdWNlIGF2YWlsYWJpbGl0eSwgc2NlbmFyaW8gcmVwYXltZW50cyByZXN0b3JlIGl0XG4gICAgY29uc3QgY3JlZGl0UHJvamVjdGlvbnMgPSBwcm9qZWN0aW9uc1dpdGhCYWxhbmNlLm1hcCgocHJvaikgPT4ge1xuICAgICAgLy8gRmluZCBkZWJ0IHJlcGF5bWVudHMgZm9yIHRoaXMgbW9udGggdGhhdCB3aWxsIGZyZWUgdXAgY3JlZGl0XG4gICAgICBjb25zdCBtb250aFJlcGF5bWVudHMgPSBwcm9qLmRlYnRfcGF5bWVudHMucmVkdWNlKChzdW06IG51bWJlciwgcDogYW55KSA9PiBzdW0gKyBwLmFtb3VudCwgMClcbiAgICAgIC8vIFNjZW5hcmlvIGRlYnQgZHJhd2Rvd24gcmVkdWNlcyBjcmVkaXQgKG5lZ2F0aXZlIGVmZmVjdClcbiAgICAgIGNvbnN0IG1vbnRoU2NlbmFyaW9EcmF3ZG93biA9IHByb2ouc2NlbmFyaW9fZGVidF9kcmF3ZG93biB8fCAwXG4gICAgICAvLyBTY2VuYXJpbyBkZWJ0IHJlcGF5bWVudCByZXN0b3JlcyBjcmVkaXQgKHBvc2l0aXZlIGVmZmVjdClcbiAgICAgIGNvbnN0IG1vbnRoU2NlbmFyaW9SZXBheW1lbnQgPSBwcm9qLnNjZW5hcmlvX2RlYnRfcmVwYXltZW50IHx8IDBcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9udGg6IHByb2oubW9udGgsXG4gICAgICAgIG1vbnRoX2xhYmVsOiBwcm9qLm1vbnRoX2xhYmVsLFxuICAgICAgICByZXBheW1lbnRfYW1vdW50OiBtb250aFJlcGF5bWVudHMsXG4gICAgICAgIHNjZW5hcmlvX2RyYXdkb3duOiBtb250aFNjZW5hcmlvRHJhd2Rvd24sXG4gICAgICAgIHNjZW5hcmlvX3JlcGF5bWVudDogbW9udGhTY2VuYXJpb1JlcGF5bWVudFxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBDYWxjdWxhdGUgY3VtdWxhdGl2ZSBjcmVkaXQgY2hhbmdlcyBvdmVyIHByb2plY3Rpb24gcGVyaW9kXG4gICAgbGV0IGN1bXVsYXRpdmVSZXBheW1lbnRzID0gMFxuICAgIGxldCBjdW11bGF0aXZlU2NlbmFyaW9EcmF3ZG93bnMgPSAwXG4gICAgbGV0IGN1bXVsYXRpdmVTY2VuYXJpb1JlcGF5bWVudHMgPSAwXG4gICAgY29uc3QgY3JlZGl0QXZhaWxhYmlsaXR5UHJvamVjdGlvbiA9IGNyZWRpdFByb2plY3Rpb25zLm1hcCgocHJvaikgPT4ge1xuICAgICAgY3VtdWxhdGl2ZVJlcGF5bWVudHMgKz0gcHJvai5yZXBheW1lbnRfYW1vdW50XG4gICAgICBjdW11bGF0aXZlU2NlbmFyaW9EcmF3ZG93bnMgKz0gcHJvai5zY2VuYXJpb19kcmF3ZG93blxuICAgICAgY3VtdWxhdGl2ZVNjZW5hcmlvUmVwYXltZW50cyArPSBwcm9qLnNjZW5hcmlvX3JlcGF5bWVudFxuXG4gICAgICAvLyBOZXQgZWZmZWN0OiBhY3R1YWwgcmVwYXltZW50cyBmcmVlIGNyZWRpdCwgc2NlbmFyaW8gZHJhd2Rvd25zIHVzZSBpdCwgc2NlbmFyaW8gcmVwYXltZW50cyByZXN0b3JlIGl0XG4gICAgICBjb25zdCBuZXRDcmVkaXRDaGFuZ2UgPSBjdW11bGF0aXZlUmVwYXltZW50cyAtIGN1bXVsYXRpdmVTY2VuYXJpb0RyYXdkb3ducyArIGN1bXVsYXRpdmVTY2VuYXJpb1JlcGF5bWVudHNcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9udGg6IHByb2oubW9udGgsXG4gICAgICAgIG1vbnRoX2xhYmVsOiBwcm9qLm1vbnRoX2xhYmVsLFxuICAgICAgICBhdmFpbGFibGVfY3JlZGl0OiB0b3RhbENyZWRpdEF2YWlsYWJsZSArIG5ldENyZWRpdENoYW5nZSxcbiAgICAgICAgcmVwYXltZW50X3RoaXNfbW9udGg6IHByb2oucmVwYXltZW50X2Ftb3VudCxcbiAgICAgICAgc2NlbmFyaW9fZHJhd2Rvd25fdGhpc19tb250aDogcHJvai5zY2VuYXJpb19kcmF3ZG93bixcbiAgICAgICAgc2NlbmFyaW9fcmVwYXltZW50X3RoaXNfbW9udGg6IHByb2ouc2NlbmFyaW9fcmVwYXltZW50LFxuICAgICAgICBjdW11bGF0aXZlX3JlcGF5bWVudHM6IGN1bXVsYXRpdmVSZXBheW1lbnRzLFxuICAgICAgICBjdW11bGF0aXZlX3NjZW5hcmlvX2RyYXdkb3duczogY3VtdWxhdGl2ZVNjZW5hcmlvRHJhd2Rvd25zLFxuICAgICAgICBjdW11bGF0aXZlX3NjZW5hcmlvX3JlcGF5bWVudHM6IGN1bXVsYXRpdmVTY2VuYXJpb1JlcGF5bWVudHNcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgY29uc29sZS5sb2coYFtDYXNoIEZsb3cgMy4wXSBDcmVkaXQgbGluZXM6ICR7Y3JlZGl0TGluZXMubGVuZ3RofSwgdG90YWwgYXZhaWxhYmxlOiAke3RvdGFsQ3JlZGl0QXZhaWxhYmxlLnRvTG9jYWxlU3RyaW5nKCl9IFZORGApXG5cbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgZGF0YToge1xuICAgICAgICBjdXJyZW50X2JhbGFuY2U6IGN1cnJlbnRCYWxhbmNlLFxuICAgICAgICBtb250aHNfYWhlYWQ6IG1vbnRoc0FoZWFkLFxuICAgICAgICB0b3RhbF9vYmxpZ2F0aW9uczogdG90YWxPYmxpZ2F0aW9ucyxcbiAgICAgICAgdG90YWxfcHJvamVjdGVkX2luY29tZTogdG90YWxQcm9qZWN0ZWRJbmNvbWUsIC8vIE5FVyBpbiB2Mi4wXG4gICAgICAgIG5ldF9wcm9qZWN0ZWRfY2hhbmdlOiB0b3RhbFByb2plY3RlZEluY29tZSAtIHRvdGFsT2JsaWdhdGlvbnMsIC8vIE5FVyBpbiB2Mi4wXG4gICAgICAgIGxvd2VzdF9wcm9qZWN0ZWRfYmFsYW5jZTogbG93ZXN0QmFsYW5jZSxcbiAgICAgICAgbW9udGhzX3VudGlsX25lZ2F0aXZlOiBtb250aHNVbnRpbE5lZ2F0aXZlID09PSAtMSA/IG51bGwgOiBtb250aHNVbnRpbE5lZ2F0aXZlICsgMSxcbiAgICAgICAgcHJvamVjdGlvbnM6IHByb2plY3Rpb25zV2l0aEJhbGFuY2UsXG5cbiAgICAgICAgLy8gTkVXIGluIHYzLjA6IExpcXVpZGl0eSAmIFNvbHZlbmN5IEFuYWx5c2lzXG4gICAgICAgIGxpcXVpZGl0eTogbGlxdWlkaXR5UG9zaXRpb24sXG4gICAgICAgIHJ1bndheTogcnVud2F5QW5hbHlzaXMsXG5cbiAgICAgICAgLy8gTkVXIGluIHYzLjE6IENyZWRpdCBMaW5lIEFuYWx5c2lzXG4gICAgICAgIGNyZWRpdF9saW5lczoge1xuICAgICAgICAgIGFjY291bnRzOiBjcmVkaXRMaW5lcyxcbiAgICAgICAgICB0b3RhbF9saW1pdDogdG90YWxDcmVkaXRMaW1pdCxcbiAgICAgICAgICB0b3RhbF91c2VkOiB0b3RhbENyZWRpdFVzZWQsXG4gICAgICAgICAgdG90YWxfYXZhaWxhYmxlOiB0b3RhbENyZWRpdEF2YWlsYWJsZSxcbiAgICAgICAgICBvdmVyYWxsX3V0aWxpemF0aW9uOiB0b3RhbENyZWRpdExpbWl0ID4gMCA/ICh0b3RhbENyZWRpdFVzZWQgLyB0b3RhbENyZWRpdExpbWl0KSAqIDEwMCA6IDAsXG4gICAgICAgICAgYXZhaWxhYmlsaXR5X3Byb2plY3Rpb246IGNyZWRpdEF2YWlsYWJpbGl0eVByb2plY3Rpb24sXG4gICAgICAgICAgLy8gTkVXOiBTY2VuYXJpbyBpbXBhY3Qgb24gY3JlZGl0XG4gICAgICAgICAgc2NlbmFyaW9fZGVidF9kcmF3ZG93bjogdG90YWxTY2VuYXJpb0RlYnREcmF3ZG93bixcbiAgICAgICAgICBzY2VuYXJpb19hZGp1c3RlZF9hdmFpbGFibGU6IHRvdGFsQ3JlZGl0QXZhaWxhYmxlIC0gdG90YWxTY2VuYXJpb0RlYnREcmF3ZG93blxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIE5FVyBpbiB2My4xOiBTY2VuYXJpbyBpbmZvIChpZiBhcHBsaWVkKVxuICAgICAgICBzY2VuYXJpbzogc2NlbmFyaW9JbmZvLFxuXG4gICAgICAgIHZlcnNpb246ICczLjAnIC8vIE1hcmsgdGhpcyBhcyB2My4wIHJlc3BvbnNlXG4gICAgICB9XG4gICAgfSlcblxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3I6JywgZXJyb3IpXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgeyBlcnJvcjogJ0ludGVybmFsIHNlcnZlciBlcnJvcicgfSxcbiAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgIClcbiAgfVxufVxuIl0sIm5hbWVzIjpbIk5leHRSZXNwb25zZSIsImNyZWF0ZVN1cGFiYXNlU2VydmVyQ2xpZW50Iiwic3RhcnRPZk1vbnRoIiwiZW5kT2ZNb250aCIsImFkZE1vbnRocyIsImZvcm1hdCIsInBhcnNlSVNPIiwiZWFjaE1vbnRoT2ZJbnRlcnZhbCIsImNhbGN1bGF0ZVByZWRpY3RlZEluY29tZSIsImNhbGN1bGF0ZVByZWRpY3RlZEV4cGVuc2VzIiwiY29tcGFyZUJ1ZGdldHMiLCJnZXRDYXRlZ29yaWVzV2l0aFNjaGVkdWxlZFBheW1lbnRzIiwiYW5hbHl6ZUxpcXVpZGl0eVBvc2l0aW9uIiwiY2FsY3VsYXRlUnVud2F5QW5hbHlzaXMiLCJhcHBseVNjZW5hcmlvQWRqdXN0bWVudHMiLCJtb250aEtleSIsImJhc2VJbmNvbWUiLCJiYXNlUHJlZGljdGVkRXhwZW5zZXMiLCJhZGp1c3RtZW50cyIsImFkanVzdGVkSW5jb21lIiwiYWRqdXN0ZWRQcmVkaWN0ZWQiLCJzY2VuYXJpb0RlYnREcmF3ZG93biIsInNjZW5hcmlvRGVidFJlcGF5bWVudCIsInNjZW5hcmlvSW5jb21lIiwic2NlbmFyaW9FeHBlbnNlIiwic2NlbmFyaW9JdGVtcyIsIm1vbnRoRGF0ZSIsImFkaiIsInN0YXJ0TW9udGgiLCJzdGFydF9tb250aCIsImVuZE1vbnRoIiwiZW5kX21vbnRoIiwic3RhcnRzQmVmb3JlT3JPbiIsImVuZHNBZnRlck9yT24iLCJpc09uZVRpbWUiLCJhZGp1c3RtZW50X3R5cGUiLCJzdGFydHNXaXRoIiwibWF0Y2hlc01vbnRoIiwiYW1vdW50IiwibWV0YWRhdGEiLCJyZXBheW1lbnRfbW9udGgiLCJyZXBheW1lbnRNb250aCIsInB1c2giLCJuYW1lIiwidHlwZSIsImNvbnNvbGUiLCJsb2ciLCJwZXJjZW50YWdlIiwiY2hhbmdlIiwiR0VUIiwicmVxdWVzdCIsInN1cGFiYXNlIiwic2VhcmNoUGFyYW1zIiwibmV4dFVybCIsImVudGl0eUlkIiwiZ2V0IiwibW9udGhzQWhlYWQiLCJwYXJzZUludCIsInNjZW5hcmlvSWQiLCJqc29uIiwiZXJyb3IiLCJzdGF0dXMiLCJkYXRhIiwidXNlciIsImF1dGhFcnJvciIsImF1dGgiLCJnZXRVc2VyIiwiZW50aXR5VXNlciIsInJvbGVFcnJvciIsImZyb20iLCJzZWxlY3QiLCJlcSIsImlkIiwic2luZ2xlIiwiY3VzdG9tUGVybWlzc2lvbiIsInJvbGUiLCJyb2xlSGllcmFyY2h5IiwidXNlclJvbGVMZXZlbCIsImRlZmF1bHRDYW5WaWV3Q2FzaEZsb3ciLCJjYW5WaWV3Q2FzaEZsb3ciLCJjYW5fdmlld19jYXNoX2Zsb3ciLCJ1bmRlZmluZWQiLCJzdGFydERhdGUiLCJEYXRlIiwiZW5kRGF0ZSIsInNjZW5hcmlvQWRqdXN0bWVudHMiLCJzY2VuYXJpb0luZm8iLCJzY2VuYXJpbyIsInNjZW5hcmlvRXJyb3IiLCJjb2xvciIsImxlbmd0aCIsIkpTT04iLCJzdHJpbmdpZnkiLCJtb250aHMiLCJzdGFydCIsImVuZCIsImRlYnREcmF3ZG93bnMiLCJkZWJ0RHJhd2Rvd25FcnJvciIsIm5vdCIsImd0ZSIsImx0ZSIsIm9yZGVyIiwiYXNjZW5kaW5nIiwibG9hblJlY2VpdmFibGVzIiwibG9hbkVycm9yIiwic2NoZWR1bGVkSW5zdGFuY2VzIiwic2NoZWR1bGVkRXJyb3IiLCJpbiIsImFsbEluc3RhbmNlcyIsInRvdGFsQWxsSW5zdGFuY2VzIiwicmVkdWNlIiwic3VtIiwiaSIsInRvdGFsVW5wYWlkSW5zdGFuY2VzIiwidG9Mb2NhbGVTdHJpbmciLCJidWRnZXRzIiwiYnVkZ2V0c0Vycm9yIiwiYWNjb3VudHMiLCJhY2NvdW50c0Vycm9yIiwiY3JlZGl0TGluZUFjY291bnRzIiwiY3JlZGl0TGluZUVycm9yIiwiY3JlZGl0TGluZXMiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwiYWNjb3VudCIsImRyYXdkb3ducyIsImFjY291bnRfaWQiLCJ1c2VkQW1vdW50IiwiZCIsInJlbWFpbmluZ19iYWxhbmNlIiwiY3JlZGl0TGltaXQiLCJjcmVkaXRfbGltaXQiLCJhdmFpbGFibGVDcmVkaXQiLCJhY2NvdW50X25hbWUiLCJiYW5rX25hbWUiLCJ1c2VkX2Ftb3VudCIsImF2YWlsYWJsZV9jcmVkaXQiLCJ1dGlsaXphdGlvbl9wZXJjZW50IiwidG90YWxDcmVkaXRMaW1pdCIsImNsIiwidG90YWxDcmVkaXRVc2VkIiwidG90YWxDcmVkaXRBdmFpbGFibGUiLCJhIiwiYWNjb3VudF90eXBlIiwiam9pbiIsImFjY291bnRJZHMiLCJjdXJyZW50QmFsYW5jZSIsInRvZGF5IiwiYmFsYW5jZSIsImJhbGFuY2VFcnJvciIsInJwYyIsInBfYWNjb3VudF9pZCIsInBfdXBfdG9fZGF0ZSIsInRvSVNPU3RyaW5nIiwic3BsaXQiLCJ0b3RhbCIsInByZWRpY3RlZE1vbnRobHlJbmNvbWUiLCJicmVha2Rvd24iLCJpbmNvbWVCcmVha2Rvd24iLCJwcm9qZWN0aW9ucyIsIm1vbnRoIiwibW9udGhTdGFydCIsIm1vbnRoRW5kIiwibW9udGhEZWJ0UGF5bWVudHMiLCJmaWx0ZXIiLCJkcmF3ZG93biIsImR1ZURhdGUiLCJkdWVfZGF0ZSIsImxvYW5fbmFtZSIsImRyYXdkb3duX3JlZmVyZW5jZSIsIm1vbnRoU2NoZWR1bGVkUGF5bWVudHMiLCJpbnN0YW5jZSIsImNvbnRyYWN0X25hbWUiLCJzY2hlZHVsZWRfcGF5bWVudHMiLCJwYXltZW50X3R5cGUiLCJwYXllZV9uYW1lIiwiY2F0ZWdvcnlfaWQiLCJjYXRlZ29yeV9uYW1lIiwiY2F0ZWdvcmllcyIsInByZWRpY3RlZEV4cGVuc2VzIiwidG90YWxQcmVkaWN0ZWQiLCJleHAiLCJzY2hlZHVsZWRDYXRlZ29yeUlkcyIsInByZWRpY3RlZENhdGVnb3J5TmFtZXMiLCJTZXQiLCJtb250aEJ1ZGdldHMiLCJidWRnZXQiLCJidWRnZXRTdGFydCIsInN0YXJ0X2RhdGUiLCJidWRnZXRFbmQiLCJlbmRfZGF0ZSIsImNhdGVnb3J5SWQiLCJjYXRlZ29yeU5hbWUiLCJoYXMiLCJidWRnZXRfYW1vdW50IiwiZXN0aW1hdGVkX3NwZW5kIiwiYWxsQnVkZ2V0cyIsImJ1ZGdldFdhcm5pbmdzIiwidG90YWxEZWJ0IiwicCIsInRvdGFsU2NoZWR1bGVkIiwidG90YWxCdWRnZXRzIiwiYiIsInRvdGFsT2JsaWdhdGlvbnMiLCJtb250aF9sYWJlbCIsImRlYnRfcGF5bWVudHMiLCJwcmVkaWN0ZWRfZXhwZW5zZXMiLCJ0b3RhbF9kZWJ0IiwidG90YWxfc2NoZWR1bGVkIiwidG90YWxfcHJlZGljdGVkIiwidG90YWxfYnVkZ2V0cyIsInRvdGFsX29ibGlnYXRpb25zIiwiaW5jb21lX2JyZWFrZG93biIsImJ1ZGdldF93YXJuaW5ncyIsInJ1bm5pbmdCYWxhbmNlIiwicHJvamVjdGlvbnNXaXRoQmFsYW5jZSIsInByb2oiLCJvcGVuaW5nQmFsYW5jZSIsInByb2plY3RlZEluY29tZSIsInRvdGFsUHJlZGljdGVkV2l0aFNjZW5hcmlvIiwiYWRqdXN0ZWQiLCJ0b3RhbE9ibGlnYXRpb25zV2l0aFNjZW5hcmlvIiwiY2xvc2luZ0JhbGFuY2UiLCJoZWFsdGgiLCJvcGVuaW5nX2JhbGFuY2UiLCJwcm9qZWN0ZWRfaW5jb21lIiwiYmFzZV9pbmNvbWUiLCJzY2VuYXJpb19kZWJ0X2RyYXdkb3duIiwic2NlbmFyaW9fZGVidF9yZXBheW1lbnQiLCJzY2VuYXJpb19pbmNvbWUiLCJzY2VuYXJpb19leHBlbnNlIiwiY2xvc2luZ19iYWxhbmNlIiwic2NlbmFyaW9faXRlbXMiLCJ0b3RhbFByb2plY3RlZEluY29tZSIsImxvd2VzdEJhbGFuY2UiLCJNYXRoIiwibWluIiwibW9udGhzVW50aWxOZWdhdGl2ZSIsImZpbmRJbmRleCIsImxpcXVpZGl0eVBvc2l0aW9uIiwibW9udGhseUJ1cm5SYXRlIiwicnVud2F5QW5hbHlzaXMiLCJ0b3RhbF9saXF1aWRfYXNzZXRzIiwiY2FzaF9ydW53YXlfbW9udGhzIiwidG9GaXhlZCIsImxpcXVpZGl0eV9ydW53YXlfbW9udGhzIiwidG90YWxTY2VuYXJpb0RlYnREcmF3ZG93biIsImNyZWRpdFByb2plY3Rpb25zIiwibW9udGhSZXBheW1lbnRzIiwibW9udGhTY2VuYXJpb0RyYXdkb3duIiwibW9udGhTY2VuYXJpb1JlcGF5bWVudCIsInJlcGF5bWVudF9hbW91bnQiLCJzY2VuYXJpb19kcmF3ZG93biIsInNjZW5hcmlvX3JlcGF5bWVudCIsImN1bXVsYXRpdmVSZXBheW1lbnRzIiwiY3VtdWxhdGl2ZVNjZW5hcmlvRHJhd2Rvd25zIiwiY3VtdWxhdGl2ZVNjZW5hcmlvUmVwYXltZW50cyIsImNyZWRpdEF2YWlsYWJpbGl0eVByb2plY3Rpb24iLCJuZXRDcmVkaXRDaGFuZ2UiLCJyZXBheW1lbnRfdGhpc19tb250aCIsInNjZW5hcmlvX2RyYXdkb3duX3RoaXNfbW9udGgiLCJzY2VuYXJpb19yZXBheW1lbnRfdGhpc19tb250aCIsImN1bXVsYXRpdmVfcmVwYXltZW50cyIsImN1bXVsYXRpdmVfc2NlbmFyaW9fZHJhd2Rvd25zIiwiY3VtdWxhdGl2ZV9zY2VuYXJpb19yZXBheW1lbnRzIiwiY3VycmVudF9iYWxhbmNlIiwibW9udGhzX2FoZWFkIiwidG90YWxfcHJvamVjdGVkX2luY29tZSIsIm5ldF9wcm9qZWN0ZWRfY2hhbmdlIiwibG93ZXN0X3Byb2plY3RlZF9iYWxhbmNlIiwibW9udGhzX3VudGlsX25lZ2F0aXZlIiwibGlxdWlkaXR5IiwicnVud2F5IiwiY3JlZGl0X2xpbmVzIiwidG90YWxfbGltaXQiLCJ0b3RhbF91c2VkIiwidG90YWxfYXZhaWxhYmxlIiwib3ZlcmFsbF91dGlsaXphdGlvbiIsImF2YWlsYWJpbGl0eV9wcm9qZWN0aW9uIiwic2NlbmFyaW9fYWRqdXN0ZWRfYXZhaWxhYmxlIiwidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./app/api/cash-flow-projection/route.ts\n");

/***/ }),

/***/ "(rsc)/./lib/cash-flow-analyzer.ts":
/*!***********************************!*\
  !*** ./lib/cash-flow-analyzer.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analyzeHistoricalExpenses: () => (/* binding */ analyzeHistoricalExpenses),\n/* harmony export */   analyzeHistoricalIncome: () => (/* binding */ analyzeHistoricalIncome),\n/* harmony export */   analyzeLiquidityPosition: () => (/* binding */ analyzeLiquidityPosition),\n/* harmony export */   analyzeReceivables: () => (/* binding */ analyzeReceivables),\n/* harmony export */   calculatePredictedExpenses: () => (/* binding */ calculatePredictedExpenses),\n/* harmony export */   calculatePredictedIncome: () => (/* binding */ calculatePredictedIncome),\n/* harmony export */   calculateRunwayAnalysis: () => (/* binding */ calculateRunwayAnalysis),\n/* harmony export */   compareBudgets: () => (/* binding */ compareBudgets),\n/* harmony export */   getAccountBalancesByType: () => (/* binding */ getAccountBalancesByType),\n/* harmony export */   getCategoriesWithScheduledPayments: () => (/* binding */ getCategoriesWithScheduledPayments),\n/* harmony export */   getScheduledAmountsByCategory: () => (/* binding */ getScheduledAmountsByCategory)\n/* harmony export */ });\n/* harmony import */ var _lib_supabase_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/supabase-server */ \"(rsc)/./lib/supabase-server.ts\");\n/* harmony import */ var _barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! __barrel_optimize__?names=endOfMonth,format,parseISO,startOfMonth,subMonths!=!date-fns */ \"(rsc)/../../node_modules/date-fns/startOfMonth.js\");\n/* harmony import */ var _barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=endOfMonth,format,parseISO,startOfMonth,subMonths!=!date-fns */ \"(rsc)/../../node_modules/date-fns/subMonths.js\");\n/* harmony import */ var _barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=endOfMonth,format,parseISO,startOfMonth,subMonths!=!date-fns */ \"(rsc)/../../node_modules/date-fns/endOfMonth.js\");\n/* harmony import */ var _barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=endOfMonth,format,parseISO,startOfMonth,subMonths!=!date-fns */ \"(rsc)/../../node_modules/date-fns/format.js\");\n/* harmony import */ var _barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=endOfMonth,format,parseISO,startOfMonth,subMonths!=!date-fns */ \"(rsc)/../../node_modules/date-fns/parseISO.js\");\n/**\n * Cash Flow System 2.0 - Historical Transaction Analyzer\n *\n * This module analyzes historical transaction data to predict future income and expenses.\n * It implements a hierarchical priority system to prevent double-counting.\n *\n * @see docs/CASHFLOW_SYSTEM_2.0.md for full documentation\n */ \n\n/**\n * Analyze historical income patterns from past transactions\n *\n * @param entityId - The entity to analyze\n * @param monthsBack - Number of months to look back (default: 6)\n * @returns Array of income predictions by category\n */ async function analyzeHistoricalIncome(entityId, monthsBack = 6) {\n    const supabase = (0,_lib_supabase_server__WEBPACK_IMPORTED_MODULE_0__.createSupabaseServerClient)();\n    const startDate = (0,_barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_1__.startOfMonth)((0,_barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_2__.subMonths)(new Date(), monthsBack));\n    const endDate = (0,_barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_3__.endOfMonth)(new Date());\n    // Fetch income transactions (credit direction transactions)\n    // Exclude transfers (TRF_IN) and debt drawdowns (DEBT_TAKE) as they are not real income\n    // Use pagination to get ALL results (Supabase defaults to 1000 rows max)\n    const PAGE_SIZE = 1000;\n    let allTransactions = [];\n    let offset = 0;\n    let hasMore = true;\n    while(hasMore){\n        const { data: pageData, error: pageError } = await supabase.from(\"main_transaction_details\").select(`\n        main_transaction_id,\n        transaction_date,\n        amount,\n        transaction_direction,\n        category_id,\n        category_name,\n        transaction_type_code,\n        affects_cashflow\n      `).eq(\"entity_id\", entityId).gte(\"transaction_date\", (0,_barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)(startDate, \"yyyy-MM-dd\")).lte(\"transaction_date\", (0,_barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)(endDate, \"yyyy-MM-dd\")).not(\"category_id\", \"is\", null).eq(\"transaction_direction\", \"credit\") // Only credit transactions (income)\n        .eq(\"affects_cashflow\", true) // Only transactions that affect cash flow (excludes transfers, debt)\n        .not(\"transaction_type_code\", \"in\", \"(TRF_IN,DEBT_TAKE,DEBT_PAYBACK)\") // Explicitly exclude transfers and debt-related\n        .order(\"main_transaction_id\", {\n            ascending: true\n        }).range(offset, offset + PAGE_SIZE - 1);\n        if (pageError) {\n            console.error(\"Error fetching income transactions at offset\", offset, \":\", pageError);\n            break;\n        }\n        if (pageData && pageData.length > 0) {\n            allTransactions = allTransactions.concat(pageData);\n            offset += PAGE_SIZE;\n            hasMore = pageData.length === PAGE_SIZE;\n        } else {\n            hasMore = false;\n        }\n        // Safety limit\n        if (offset > 50000) {\n            console.warn(\"[Income Analyzer] Safety limit reached at offset\", offset);\n            hasMore = false;\n        }\n    }\n    const transactions = allTransactions;\n    if (transactions.length === 0) {\n        console.log(\"[Income Analyzer] No income transactions found\");\n        return [];\n    }\n    console.log(`[Income Analyzer] Fetched ${transactions.length} income transactions`);\n    // All transactions are income (filtered by direction)\n    const incomeTransactions = transactions || [];\n    // Group by category and calculate statistics\n    const categoryMap = new Map();\n    incomeTransactions.forEach((tx)=>{\n        const categoryId = tx.category_id;\n        const categoryName = tx?.category_name || \"Unknown\";\n        const amount = tx.amount || 0;\n        const month = (0,_barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)((0,_barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_5__.parseISO)(tx.transaction_date), \"yyyy-MM\");\n        if (!categoryMap.has(categoryId)) {\n            categoryMap.set(categoryId, {\n                category_id: categoryId,\n                category_name: categoryName,\n                amounts: [],\n                months: new Set()\n            });\n        }\n        const entry = categoryMap.get(categoryId);\n        entry.amounts.push(amount);\n        entry.months.add(month);\n    });\n    // Calculate predictions for each category\n    const predictions = Array.from(categoryMap.values()).map((category)=>{\n        const monthsOfData = category.months.size;\n        const totalAmount = category.amounts.reduce((sum, amt)=>sum + amt, 0);\n        const monthlyAverage = totalAmount / Math.max(monthsOfData, 1);\n        // Calculate variance to determine if it's recurring\n        const mean = monthlyAverage;\n        const variance = category.amounts.reduce((sum, amt)=>{\n            return sum + Math.pow(amt - mean, 2);\n        }, 0) / category.amounts.length;\n        const stdDev = Math.sqrt(variance);\n        const variancePercentage = mean > 0 ? stdDev / mean * 100 : 100;\n        // Determine if recurring (low variance, appears in most months)\n        const appearanceRate = monthsOfData / monthsBack;\n        const isRecurring = variancePercentage < 15 && appearanceRate >= 0.5;\n        // Confidence scoring\n        let confidence;\n        if (monthsOfData >= 4 && variancePercentage < 10) {\n            confidence = \"high\";\n        } else if (monthsOfData >= 3 && variancePercentage < 30) {\n            confidence = \"medium\";\n        } else {\n            confidence = \"low\";\n        }\n        // Determine source\n        let source;\n        if (isRecurring) {\n            source = \"recurring\";\n        } else if (monthsOfData >= 3) {\n            source = \"average\";\n        } else {\n            source = \"estimate\";\n        }\n        return {\n            category_id: category.category_id,\n            category_name: category.category_name,\n            monthly_average: monthlyAverage,\n            months_of_data: monthsOfData,\n            is_recurring: isRecurring,\n            confidence,\n            source\n        };\n    });\n    return predictions.filter((p)=>p.monthly_average > 0);\n}\n/**\n * Get categories that already have scheduled payments\n * These should be excluded from historical expense predictions to prevent double-counting\n *\n * @param entityId - The entity to check\n * @param monthKey - The month to check for (format: 'yyyy-MM')\n * @returns Set of category IDs that have scheduled payments\n */ async function getCategoriesWithScheduledPayments(entityId, monthKey) {\n    const supabase = (0,_lib_supabase_server__WEBPACK_IMPORTED_MODULE_0__.createSupabaseServerClient)();\n    const monthStart = (0,_barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_1__.startOfMonth)((0,_barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_5__.parseISO)(monthKey + \"-01\"));\n    const monthEnd = (0,_barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_3__.endOfMonth)(monthStart);\n    const { data: scheduledPayments, error } = await supabase.from(\"scheduled_payment_instances\").select(`\n      scheduled_payments:scheduled_payment_id!inner (\n        category_id,\n        entity_id\n      )\n    `).eq(\"scheduled_payments.entity_id\", entityId).in(\"status\", [\n        \"pending\",\n        \"overdue\"\n    ]).gte(\"due_date\", (0,_barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)(monthStart, \"yyyy-MM-dd\")).lte(\"due_date\", (0,_barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)(monthEnd, \"yyyy-MM-dd\"));\n    if (error) {\n        console.error(\"Error fetching scheduled payment categories:\", error);\n        return new Set();\n    }\n    const categoryIds = new Set();\n    scheduledPayments?.forEach((sp)=>{\n        const categoryId = sp.scheduled_payments?.category_id;\n        if (categoryId) {\n            categoryIds.add(categoryId);\n        }\n    });\n    return categoryIds;\n}\n/**\n * Get scheduled payment amounts by category for a given month\n * Returns a map of category_id -> total scheduled amount\n */ async function getScheduledAmountsByCategory(entityId, monthKey) {\n    const supabase = (0,_lib_supabase_server__WEBPACK_IMPORTED_MODULE_0__.createSupabaseServerClient)();\n    const monthStart = (0,_barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_1__.startOfMonth)((0,_barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_5__.parseISO)(monthKey + \"-01\"));\n    const monthEnd = (0,_barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_3__.endOfMonth)(monthStart);\n    const { data: instances, error } = await supabase.from(\"scheduled_payment_instances\").select(`\n      amount,\n      scheduled_payments:scheduled_payment_id!inner (\n        category_id,\n        entity_id\n      )\n    `).eq(\"scheduled_payments.entity_id\", entityId).in(\"status\", [\n        \"pending\",\n        \"overdue\"\n    ]).gte(\"due_date\", (0,_barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)(monthStart, \"yyyy-MM-dd\")).lte(\"due_date\", (0,_barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)(monthEnd, \"yyyy-MM-dd\"));\n    if (error) {\n        console.error(\"Error fetching scheduled payment amounts:\", error);\n        return new Map();\n    }\n    const categoryAmounts = new Map();\n    instances?.forEach((inst)=>{\n        const categoryId = inst.scheduled_payments?.category_id;\n        const amount = inst.amount || 0;\n        if (categoryId) {\n            const currentTotal = categoryAmounts.get(categoryId) || 0;\n            categoryAmounts.set(categoryId, currentTotal + amount);\n        }\n    });\n    return categoryAmounts;\n}\n/**\n * Analyze historical expense patterns from past transactions\n * Excludes categories that have scheduled payments to prevent double-counting\n *\n * @param entityId - The entity to analyze\n * @param monthKey - The month to predict for (to check scheduled payments)\n * @param monthsBack - Number of months to look back (default: 6)\n * @returns Array of expense predictions by category\n */ async function analyzeHistoricalExpenses(entityId, monthKey, monthsBack = 6) {\n    const supabase = (0,_lib_supabase_server__WEBPACK_IMPORTED_MODULE_0__.createSupabaseServerClient)();\n    const startDate = (0,_barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_1__.startOfMonth)((0,_barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_2__.subMonths)(new Date(), monthsBack));\n    const endDate = (0,_barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_3__.endOfMonth)(new Date());\n    // Get categories with scheduled payments (to exclude)\n    const scheduledCategories = await getCategoriesWithScheduledPayments(entityId, monthKey);\n    // Fetch expense transactions (debit direction transactions)\n    // Exclude transfers (TRF_OUT) and debt payments (DEBT_PAYBACK) as they are not regular expenses\n    // Use pagination to get ALL results (Supabase defaults to 1000 rows max)\n    const PAGE_SIZE = 1000;\n    let allTransactions = [];\n    let offset = 0;\n    let hasMore = true;\n    while(hasMore){\n        const { data: pageData, error: pageError } = await supabase.from(\"main_transaction_details\").select(`\n        main_transaction_id,\n        transaction_date,\n        amount,\n        transaction_direction,\n        category_id,\n        category_name,\n        transaction_type_code,\n        affects_cashflow\n      `).eq(\"entity_id\", entityId).gte(\"transaction_date\", (0,_barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)(startDate, \"yyyy-MM-dd\")).lte(\"transaction_date\", (0,_barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)(endDate, \"yyyy-MM-dd\")).not(\"category_id\", \"is\", null).eq(\"transaction_direction\", \"debit\") // Only debit transactions (expenses)\n        .eq(\"affects_cashflow\", true) // Only transactions that affect cash flow\n        .not(\"transaction_type_code\", \"in\", \"(TRF_OUT,DEBT_TAKE,DEBT_PAYBACK)\") // Exclude transfers and debt-related\n        .order(\"main_transaction_id\", {\n            ascending: true\n        }).range(offset, offset + PAGE_SIZE - 1);\n        if (pageError) {\n            console.error(\"Error fetching expense transactions at offset\", offset, \":\", pageError);\n            break;\n        }\n        if (pageData && pageData.length > 0) {\n            allTransactions = allTransactions.concat(pageData);\n            offset += PAGE_SIZE;\n            hasMore = pageData.length === PAGE_SIZE;\n        } else {\n            hasMore = false;\n        }\n        // Safety limit\n        if (offset > 50000) {\n            console.warn(\"[Expense Analyzer] Safety limit reached at offset\", offset);\n            hasMore = false;\n        }\n    }\n    const transactions = allTransactions;\n    if (transactions.length === 0) {\n        console.log(\"[Expense Analyzer] No expense transactions found\");\n        return [];\n    }\n    console.log(`[Expense Analyzer] Fetched ${transactions.length} expense transactions`);\n    // All transactions are expenses (filtered by direction)\n    const expenseTransactions = transactions || [];\n    // Group by category and calculate statistics\n    const categoryMap = new Map();\n    expenseTransactions.forEach((tx)=>{\n        const categoryId = tx.category_id;\n        const categoryName = tx?.category_name || \"Unknown\";\n        const amount = tx.amount || 0;\n        const month = (0,_barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)((0,_barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_5__.parseISO)(tx.transaction_date), \"yyyy-MM\");\n        if (!categoryMap.has(categoryId)) {\n            categoryMap.set(categoryId, {\n                category_id: categoryId,\n                category_name: categoryName,\n                amounts: [],\n                months: new Set()\n            });\n        }\n        const entry = categoryMap.get(categoryId);\n        entry.amounts.push(amount);\n        entry.months.add(month);\n    });\n    // Calculate predictions for each category\n    const predictions = Array.from(categoryMap.values()).map((category)=>{\n        const monthsOfData = category.months.size;\n        const totalAmount = category.amounts.reduce((sum, amt)=>sum + amt, 0);\n        const monthlyAverage = totalAmount / Math.max(monthsOfData, 1);\n        // Calculate variance\n        const mean = monthlyAverage;\n        const variance = category.amounts.reduce((sum, amt)=>{\n            return sum + Math.pow(amt - mean, 2);\n        }, 0) / category.amounts.length;\n        const stdDev = Math.sqrt(variance);\n        const variancePercentage = mean > 0 ? stdDev / mean * 100 : 100;\n        // Confidence scoring\n        let confidence;\n        if (monthsOfData >= 4 && variancePercentage < 10) {\n            confidence = \"high\";\n        } else if (monthsOfData >= 3 && variancePercentage < 30) {\n            confidence = \"medium\";\n        } else {\n            confidence = \"low\";\n        }\n        return {\n            category_id: category.category_id,\n            category_name: category.category_name,\n            monthly_average: monthlyAverage,\n            months_of_data: monthsOfData,\n            confidence,\n            variance_percentage: variancePercentage,\n            has_scheduled_payment: false // Already filtered out\n        };\n    });\n    return predictions.filter((p)=>p.monthly_average > 0);\n}\n/**\n * Calculate total predicted income for a month\n *\n * @param entityId - The entity to analyze\n * @returns Total predicted monthly income and breakdown\n */ async function calculatePredictedIncome(entityId) {\n    const incomeData = await analyzeHistoricalIncome(entityId, 6);\n    const breakdown = incomeData.map((income)=>({\n            category_name: income.category_name,\n            amount: income.monthly_average,\n            confidence: income.confidence,\n            source: income.source\n        }));\n    const total = incomeData.reduce((sum, income)=>sum + income.monthly_average, 0);\n    return {\n        total,\n        breakdown\n    };\n}\n/**\n * Calculate predicted expenses for a month, excluding scheduled payments\n *\n * @param entityId - The entity to analyze\n * @param monthKey - The month to predict for\n * @returns Predicted expenses breakdown\n */ async function calculatePredictedExpenses(entityId, monthKey) {\n    const expenseData = await analyzeHistoricalExpenses(entityId, monthKey, 6);\n    const scheduledAmounts = await getScheduledAmountsByCategory(entityId, monthKey);\n    const predictions = [];\n    expenseData.forEach((expense)=>{\n        const scheduledAmount = scheduledAmounts.get(expense.category_id) || 0;\n        const historicalAverage = expense.monthly_average;\n        // If there's no scheduled payment, show full historical average\n        if (scheduledAmount === 0) {\n            predictions.push({\n                category_name: expense.category_name,\n                amount: historicalAverage,\n                historical_average: historicalAverage,\n                months_of_data: expense.months_of_data,\n                confidence: expense.confidence,\n                has_gap: false\n            });\n        } else if (historicalAverage > scheduledAmount) {\n            const gapAmount = historicalAverage - scheduledAmount;\n            predictions.push({\n                category_name: expense.category_name,\n                amount: gapAmount,\n                historical_average: historicalAverage,\n                months_of_data: expense.months_of_data,\n                confidence: expense.confidence,\n                has_gap: true,\n                scheduled_amount: scheduledAmount\n            });\n        }\n    // If scheduled >= historical, don't show in predictions (fully covered)\n    // This prevents showing the category in Priority 2 at all\n    });\n    return predictions;\n}\n/**\n * Compare predicted expenses with budgets to generate warnings\n *\n * @param predictedExpenses - Predicted expense amounts\n * @param budgets - Active budgets\n * @returns Array of budget warnings for overages\n */ function compareBudgets(predictedExpenses, budgets) {\n    const warnings = [];\n    // Create a map of budgets by category\n    const budgetMap = new Map();\n    budgets.forEach((budget)=>{\n        budgetMap.set(budget.category_name, budget.budget_amount);\n    });\n    // Check each predicted expense against budget\n    predictedExpenses.forEach((expense)=>{\n        const budgetAmount = budgetMap.get(expense.category_name);\n        if (budgetAmount && expense.amount > budgetAmount) {\n            warnings.push({\n                category_name: expense.category_name,\n                projected: expense.amount,\n                budget: budgetAmount,\n                variance: expense.amount - budgetAmount\n            });\n        }\n    });\n    return warnings;\n}\n/**\n * Get all account balances grouped by type\n * \n * @param entityId - The entity to analyze\n * @returns Account balances grouped by type\n */ async function getAccountBalancesByType(entityId) {\n    const supabase = (0,_lib_supabase_server__WEBPACK_IMPORTED_MODULE_0__.createSupabaseServerClient)();\n    // Get all accounts with their balances\n    const { data: accounts, error: accountsError } = await supabase.from(\"accounts\").select(\"account_id, account_name, account_type\").eq(\"entity_id\", entityId).eq(\"is_active\", true);\n    if (accountsError) {\n        console.error(\"Error fetching accounts:\", accountsError);\n        return {\n            cash: [],\n            investments: [],\n            total_cash: 0,\n            total_investments: 0\n        };\n    }\n    console.log(`[Liquidity] Found ${accounts?.length || 0} accounts for entity ${entityId}`);\n    console.log(`[Liquidity] Account types: ${accounts?.map((a)=>`${a.account_name}(${a.account_type})`).join(\", \")}`);\n    const accountIds = accounts?.map((a)=>a.account_id) || [];\n    if (accountIds.length === 0) {\n        return {\n            cash: [],\n            investments: [],\n            total_cash: 0,\n            total_investments: 0\n        };\n    }\n    // Calculate balances for those accounts using RPC function\n    const today = new Date().toISOString().split(\"T\")[0] // YYYY-MM-DD\n    ;\n    const accountsWithBalances = [];\n    for (const acc of accounts || []){\n        const { data: balance, error: balanceError } = await supabase.rpc(\"calculate_balance_up_to_date\", {\n            p_account_id: acc.account_id,\n            p_up_to_date: today\n        });\n        if (balanceError) {\n            console.error(`[Liquidity] Error calculating balance for ${acc.account_name}:`, JSON.stringify(balanceError));\n        }\n        console.log(`[Liquidity] ${acc.account_name} (${acc.account_type}) balance: ${balance || 0}`);\n        accountsWithBalances.push({\n            account_id: acc.account_id,\n            account_name: acc.account_name,\n            account_type: acc.account_type,\n            current_balance: balance || 0\n        });\n    }\n    // Separate cash accounts from investment accounts\n    // Based on AccountType: 'bank' | 'cash' | 'credit_card' | 'investment' | 'credit_line' | 'term_loan' | 'loan_receivable'\n    const cashAccounts = accountsWithBalances.filter((a)=>a.account_type === \"bank\" || a.account_type === \"cash\");\n    const investmentAccounts = accountsWithBalances.filter((a)=>a.account_type === \"investment\");\n    const totalCash = cashAccounts.reduce((sum, a)=>sum + a.current_balance, 0);\n    const totalInvestments = investmentAccounts.reduce((sum, a)=>sum + a.current_balance, 0);\n    return {\n        cash: cashAccounts,\n        investments: investmentAccounts,\n        total_cash: totalCash,\n        total_investments: totalInvestments\n    };\n}\n/**\n * Get outstanding receivables (loans given to others)\n * \n * @param entityId - The entity to analyze\n * @returns Receivables summary\n */ async function analyzeReceivables(entityId) {\n    const supabase = (0,_lib_supabase_server__WEBPACK_IMPORTED_MODULE_0__.createSupabaseServerClient)();\n    // Get all accounts for this entity\n    const { data: accounts, error: accountsError } = await supabase.from(\"accounts\").select(\"account_id\").eq(\"entity_id\", entityId).eq(\"is_active\", true);\n    if (accountsError) {\n        console.error(\"Error fetching accounts for receivables:\", accountsError);\n        return {\n            total: 0,\n            overdue_total: 0,\n            loans: []\n        };\n    }\n    const accountIds = accounts?.map((a)=>a.account_id) || [];\n    if (accountIds.length === 0) {\n        return {\n            total: 0,\n            overdue_total: 0,\n            loans: []\n        };\n    }\n    // Get loan disbursements (money we lent out)\n    const { data: loans, error } = await supabase.from(\"loan_disbursement\").select(`\n      loan_disbursement_id,\n      borrower_name,\n      remaining_balance,\n      due_date,\n      status\n    `).in(\"account_id\", accountIds).eq(\"status\", \"active\");\n    if (error) {\n        console.error(\"Error fetching receivables:\", error);\n        return {\n            total: 0,\n            overdue_total: 0,\n            loans: []\n        };\n    }\n    const today = new Date();\n    const receivableLoans = (loans || []).map((loan)=>{\n        const dueDate = loan.due_date ? new Date(loan.due_date) : null;\n        const isOverdue = dueDate ? dueDate < today : false;\n        const daysOverdue = isOverdue && dueDate ? Math.floor((today.getTime() - dueDate.getTime()) / (1000 * 60 * 60 * 24)) : 0;\n        return {\n            loan_disbursement_id: loan.loan_disbursement_id,\n            borrower_name: loan.borrower_name,\n            remaining_balance: loan.remaining_balance || 0,\n            due_date: loan.due_date,\n            is_overdue: isOverdue,\n            days_overdue: daysOverdue\n        };\n    });\n    const total = receivableLoans.reduce((sum, l)=>sum + l.remaining_balance, 0);\n    const overdueTotal = receivableLoans.filter((l)=>l.is_overdue).reduce((sum, l)=>sum + l.remaining_balance, 0);\n    return {\n        total,\n        overdue_total: overdueTotal,\n        loans: receivableLoans\n    };\n}\n/**\n * Calculate complete liquidity position\n * \n * @param entityId - The entity to analyze\n * @returns Complete liquidity analysis\n */ async function analyzeLiquidityPosition(entityId) {\n    // Get account balances by type\n    const { cash: cashAccounts, investments: investmentAccounts, total_cash, total_investments } = await getAccountBalancesByType(entityId);\n    // Get receivables\n    const { total: totalReceivables, overdue_total, loans } = await analyzeReceivables(entityId);\n    const totalLiquidAssets = total_cash + total_investments + totalReceivables;\n    const overdueCount = loans.filter((l)=>l.is_overdue).length;\n    return {\n        cash_balance: total_cash,\n        cash_accounts: cashAccounts,\n        investment_balance: total_investments,\n        investment_accounts: investmentAccounts,\n        receivables_balance: totalReceivables,\n        receivables: loans,\n        overdue_receivables: overdue_total,\n        overdue_count: overdueCount,\n        total_liquid_assets: totalLiquidAssets\n    };\n}\n/**\n * Calculate runway analysis\n * \n * @param liquidity - Liquidity position\n * @param monthlyBurnRate - Average monthly expenses\n * @param monthlyIncome - Average monthly income\n * @param monthsAhead - Number of months to project\n * @returns Runway analysis with depletion warnings\n */ function calculateRunwayAnalysis(liquidity, monthlyBurnRate, monthlyIncome, monthsAhead = 6) {\n    const netMonthlyBurn = monthlyBurnRate - monthlyIncome;\n    // If income > expenses, infinite runway\n    if (netMonthlyBurn <= 0) {\n        return {\n            monthly_burn_rate: netMonthlyBurn,\n            cash_runway_months: Infinity,\n            liquidity_runway_months: Infinity,\n            quick_ratio: Infinity,\n            will_run_out_of_cash: false,\n            cash_depletion_month: null,\n            liquidity_buffer: Infinity\n        };\n    }\n    // Calculate cash runway\n    const cashRunway = liquidity.cash_balance / netMonthlyBurn;\n    // Calculate total liquidity runway\n    const liquidityRunway = liquidity.total_liquid_assets / netMonthlyBurn;\n    // Quick ratio (liquid assets / monthly obligations)\n    const quickRatio = liquidity.total_liquid_assets / monthlyBurnRate;\n    // Determine cash depletion month\n    let cashDepletionMonth = null;\n    if (cashRunway < monthsAhead) {\n        const depletionDate = new Date();\n        depletionDate.setMonth(depletionDate.getMonth() + Math.floor(cashRunway));\n        cashDepletionMonth = (0,_barrel_optimize_names_endOfMonth_format_parseISO_startOfMonth_subMonths_date_fns__WEBPACK_IMPORTED_MODULE_4__.format)(depletionDate, \"yyyy-MM\");\n    }\n    return {\n        monthly_burn_rate: netMonthlyBurn,\n        cash_runway_months: cashRunway,\n        liquidity_runway_months: liquidityRunway,\n        quick_ratio: quickRatio,\n        will_run_out_of_cash: cashRunway < monthsAhead,\n        cash_depletion_month: cashDepletionMonth,\n        liquidity_buffer: liquidityRunway - cashRunway\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWtCQztJQUV6Qyx3Q0FBd0M7SUFDeEMsSUFBSUUsa0JBQWtCLEdBQUc7UUFDdkIsT0FBTztZQUNMQyxtQkFBbUJEO1lBQ25CRSxvQkFBb0JDO1lBQ3BCQyx5QkFBeUJEO1lBQ3pCRSxhQUFhRjtZQUNiRyxzQkFBc0I7WUFDdEJDLHNCQUFzQjtZQUN0QkMsa0JBQWtCTDtRQUNwQjtJQUNGO0lBRUEsd0JBQXdCO0lBQ3hCLE1BQU1NLGFBQWFiLFVBQVVWLFlBQVksR0FBR2M7SUFFNUMsbUNBQW1DO0lBQ25DLE1BQU1VLGtCQUFrQmQsVUFBVUYsbUJBQW1CLEdBQUdNO0lBRXhELG9EQUFvRDtJQUNwRCxNQUFNVyxhQUFhZixVQUFVRixtQkFBbUIsR0FBR0c7SUFFbkQsaUNBQWlDO0lBQ2pDLElBQUllLHFCQUFvQztJQUN4QyxJQUFJSCxhQUFhVixhQUFhO1FBQzVCLE1BQU1jLGdCQUFnQixJQUFJck07UUFDMUJxTSxjQUFjQyxRQUFRLENBQUNELGNBQWNFLFFBQVEsS0FBSzdJLEtBQUttRyxLQUFLLENBQUNvQztRQUM3REcscUJBQXFCM00seUhBQU1BLENBQUM0TSxlQUFlO0lBQzdDO0lBRUEsT0FBTztRQUNMWixtQkFBbUJEO1FBQ25CRSxvQkFBb0JPO1FBQ3BCTCx5QkFBeUJNO1FBQ3pCTCxhQUFhTTtRQUNiTCxzQkFBc0JHLGFBQWFWO1FBQ25DUSxzQkFBc0JLO1FBQ3RCSixrQkFBa0JFLGtCQUFrQkQ7SUFDdEM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BmaW5hbmNlYXBwL3dlYi8uL2xpYi9jYXNoLWZsb3ctYW5hbHl6ZXIudHM/Y2ZhOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENhc2ggRmxvdyBTeXN0ZW0gMi4wIC0gSGlzdG9yaWNhbCBUcmFuc2FjdGlvbiBBbmFseXplclxuICpcbiAqIFRoaXMgbW9kdWxlIGFuYWx5emVzIGhpc3RvcmljYWwgdHJhbnNhY3Rpb24gZGF0YSB0byBwcmVkaWN0IGZ1dHVyZSBpbmNvbWUgYW5kIGV4cGVuc2VzLlxuICogSXQgaW1wbGVtZW50cyBhIGhpZXJhcmNoaWNhbCBwcmlvcml0eSBzeXN0ZW0gdG8gcHJldmVudCBkb3VibGUtY291bnRpbmcuXG4gKlxuICogQHNlZSBkb2NzL0NBU0hGTE9XX1NZU1RFTV8yLjAubWQgZm9yIGZ1bGwgZG9jdW1lbnRhdGlvblxuICovXG5cbmltcG9ydCB7IGNyZWF0ZVN1cGFiYXNlU2VydmVyQ2xpZW50IH0gZnJvbSAnQC9saWIvc3VwYWJhc2Utc2VydmVyJ1xuaW1wb3J0IHsgc3RhcnRPZk1vbnRoLCBlbmRPZk1vbnRoLCBzdWJNb250aHMsIGZvcm1hdCwgcGFyc2VJU08gfSBmcm9tICdkYXRlLWZucydcblxuZXhwb3J0IGludGVyZmFjZSBIaXN0b3JpY2FsSW5jb21lIHtcbiAgY2F0ZWdvcnlfaWQ6IG51bWJlclxuICBjYXRlZ29yeV9uYW1lOiBzdHJpbmdcbiAgbW9udGhseV9hdmVyYWdlOiBudW1iZXJcbiAgbW9udGhzX29mX2RhdGE6IG51bWJlclxuICBpc19yZWN1cnJpbmc6IGJvb2xlYW5cbiAgY29uZmlkZW5jZTogJ2hpZ2gnIHwgJ21lZGl1bScgfCAnbG93J1xuICBzb3VyY2U6ICdyZWN1cnJpbmcnIHwgJ2F2ZXJhZ2UnIHwgJ2VzdGltYXRlJ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhpc3RvcmljYWxFeHBlbnNlIHtcbiAgY2F0ZWdvcnlfaWQ6IG51bWJlclxuICBjYXRlZ29yeV9uYW1lOiBzdHJpbmdcbiAgbW9udGhseV9hdmVyYWdlOiBudW1iZXJcbiAgbW9udGhzX29mX2RhdGE6IG51bWJlclxuICBjb25maWRlbmNlOiAnaGlnaCcgfCAnbWVkaXVtJyB8ICdsb3cnXG4gIHZhcmlhbmNlX3BlcmNlbnRhZ2U6IG51bWJlclxuICBoYXNfc2NoZWR1bGVkX3BheW1lbnQ6IGJvb2xlYW4gLy8gRmxhZyB0byBwcmV2ZW50IGRvdWJsZS1jb3VudGluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluY29tZUJyZWFrZG93biB7XG4gIGNhdGVnb3J5X25hbWU6IHN0cmluZ1xuICBhbW91bnQ6IG51bWJlclxuICBjb25maWRlbmNlOiAnaGlnaCcgfCAnbWVkaXVtJyB8ICdsb3cnXG4gIHNvdXJjZTogJ3JlY3VycmluZycgfCAnYXZlcmFnZScgfCAnZXN0aW1hdGUnXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJlZGljdGVkRXhwZW5zZSB7XG4gIGNhdGVnb3J5X25hbWU6IHN0cmluZ1xuICBhbW91bnQ6IG51bWJlclxuICBoaXN0b3JpY2FsX2F2ZXJhZ2U6IG51bWJlclxuICBtb250aHNfb2ZfZGF0YTogbnVtYmVyXG4gIGNvbmZpZGVuY2U6ICdoaWdoJyB8ICdtZWRpdW0nIHwgJ2xvdydcbiAgaGFzX2dhcD86IGJvb2xlYW4gLy8gVHJ1ZSBpZiB0aGlzIGlzIGEgZ2FwIGJldHdlZW4gc2NoZWR1bGVkIGFuZCBoaXN0b3JpY2FsXG4gIHNjaGVkdWxlZF9hbW91bnQ/OiBudW1iZXIgLy8gQW1vdW50IGNvdmVyZWQgYnkgc2NoZWR1bGVkIHBheW1lbnRzXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQnVkZ2V0V2FybmluZyB7XG4gIGNhdGVnb3J5X25hbWU6IHN0cmluZ1xuICBwcm9qZWN0ZWQ6IG51bWJlclxuICBidWRnZXQ6IG51bWJlclxuICB2YXJpYW5jZTogbnVtYmVyXG59XG5cbi8qKlxuICogQW5hbHl6ZSBoaXN0b3JpY2FsIGluY29tZSBwYXR0ZXJucyBmcm9tIHBhc3QgdHJhbnNhY3Rpb25zXG4gKlxuICogQHBhcmFtIGVudGl0eUlkIC0gVGhlIGVudGl0eSB0byBhbmFseXplXG4gKiBAcGFyYW0gbW9udGhzQmFjayAtIE51bWJlciBvZiBtb250aHMgdG8gbG9vayBiYWNrIChkZWZhdWx0OiA2KVxuICogQHJldHVybnMgQXJyYXkgb2YgaW5jb21lIHByZWRpY3Rpb25zIGJ5IGNhdGVnb3J5XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhbmFseXplSGlzdG9yaWNhbEluY29tZShcbiAgZW50aXR5SWQ6IHN0cmluZyxcbiAgbW9udGhzQmFjazogbnVtYmVyID0gNlxuKTogUHJvbWlzZTxIaXN0b3JpY2FsSW5jb21lW10+IHtcbiAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVTdXBhYmFzZVNlcnZlckNsaWVudCgpXG5cbiAgY29uc3Qgc3RhcnREYXRlID0gc3RhcnRPZk1vbnRoKHN1Yk1vbnRocyhuZXcgRGF0ZSgpLCBtb250aHNCYWNrKSlcbiAgY29uc3QgZW5kRGF0ZSA9IGVuZE9mTW9udGgobmV3IERhdGUoKSlcblxuICAvLyBGZXRjaCBpbmNvbWUgdHJhbnNhY3Rpb25zIChjcmVkaXQgZGlyZWN0aW9uIHRyYW5zYWN0aW9ucylcbiAgLy8gRXhjbHVkZSB0cmFuc2ZlcnMgKFRSRl9JTikgYW5kIGRlYnQgZHJhd2Rvd25zIChERUJUX1RBS0UpIGFzIHRoZXkgYXJlIG5vdCByZWFsIGluY29tZVxuICAvLyBVc2UgcGFnaW5hdGlvbiB0byBnZXQgQUxMIHJlc3VsdHMgKFN1cGFiYXNlIGRlZmF1bHRzIHRvIDEwMDAgcm93cyBtYXgpXG4gIGNvbnN0IFBBR0VfU0laRSA9IDEwMDBcbiAgbGV0IGFsbFRyYW5zYWN0aW9uczogYW55W10gPSBbXVxuICBsZXQgb2Zmc2V0ID0gMFxuICBsZXQgaGFzTW9yZSA9IHRydWVcblxuICB3aGlsZSAoaGFzTW9yZSkge1xuICAgIGNvbnN0IHsgZGF0YTogcGFnZURhdGEsIGVycm9yOiBwYWdlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnbWFpbl90cmFuc2FjdGlvbl9kZXRhaWxzJylcbiAgICAgIC5zZWxlY3QoYFxuICAgICAgICBtYWluX3RyYW5zYWN0aW9uX2lkLFxuICAgICAgICB0cmFuc2FjdGlvbl9kYXRlLFxuICAgICAgICBhbW91bnQsXG4gICAgICAgIHRyYW5zYWN0aW9uX2RpcmVjdGlvbixcbiAgICAgICAgY2F0ZWdvcnlfaWQsXG4gICAgICAgIGNhdGVnb3J5X25hbWUsXG4gICAgICAgIHRyYW5zYWN0aW9uX3R5cGVfY29kZSxcbiAgICAgICAgYWZmZWN0c19jYXNoZmxvd1xuICAgICAgYClcbiAgICAgIC5lcSgnZW50aXR5X2lkJywgZW50aXR5SWQpXG4gICAgICAuZ3RlKCd0cmFuc2FjdGlvbl9kYXRlJywgZm9ybWF0KHN0YXJ0RGF0ZSwgJ3l5eXktTU0tZGQnKSlcbiAgICAgIC5sdGUoJ3RyYW5zYWN0aW9uX2RhdGUnLCBmb3JtYXQoZW5kRGF0ZSwgJ3l5eXktTU0tZGQnKSlcbiAgICAgIC5ub3QoJ2NhdGVnb3J5X2lkJywgJ2lzJywgbnVsbClcbiAgICAgIC5lcSgndHJhbnNhY3Rpb25fZGlyZWN0aW9uJywgJ2NyZWRpdCcpIC8vIE9ubHkgY3JlZGl0IHRyYW5zYWN0aW9ucyAoaW5jb21lKVxuICAgICAgLmVxKCdhZmZlY3RzX2Nhc2hmbG93JywgdHJ1ZSkgLy8gT25seSB0cmFuc2FjdGlvbnMgdGhhdCBhZmZlY3QgY2FzaCBmbG93IChleGNsdWRlcyB0cmFuc2ZlcnMsIGRlYnQpXG4gICAgICAubm90KCd0cmFuc2FjdGlvbl90eXBlX2NvZGUnLCAnaW4nLCAnKFRSRl9JTixERUJUX1RBS0UsREVCVF9QQVlCQUNLKScpIC8vIEV4cGxpY2l0bHkgZXhjbHVkZSB0cmFuc2ZlcnMgYW5kIGRlYnQtcmVsYXRlZFxuICAgICAgLm9yZGVyKCdtYWluX3RyYW5zYWN0aW9uX2lkJywgeyBhc2NlbmRpbmc6IHRydWUgfSlcbiAgICAgIC5yYW5nZShvZmZzZXQsIG9mZnNldCArIFBBR0VfU0laRSAtIDEpXG5cbiAgICBpZiAocGFnZUVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBpbmNvbWUgdHJhbnNhY3Rpb25zIGF0IG9mZnNldCcsIG9mZnNldCwgJzonLCBwYWdlRXJyb3IpXG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGlmIChwYWdlRGF0YSAmJiBwYWdlRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICBhbGxUcmFuc2FjdGlvbnMgPSBhbGxUcmFuc2FjdGlvbnMuY29uY2F0KHBhZ2VEYXRhKVxuICAgICAgb2Zmc2V0ICs9IFBBR0VfU0laRVxuICAgICAgaGFzTW9yZSA9IHBhZ2VEYXRhLmxlbmd0aCA9PT0gUEFHRV9TSVpFXG4gICAgfSBlbHNlIHtcbiAgICAgIGhhc01vcmUgPSBmYWxzZVxuICAgIH1cblxuICAgIC8vIFNhZmV0eSBsaW1pdFxuICAgIGlmIChvZmZzZXQgPiA1MDAwMCkge1xuICAgICAgY29uc29sZS53YXJuKCdbSW5jb21lIEFuYWx5emVyXSBTYWZldHkgbGltaXQgcmVhY2hlZCBhdCBvZmZzZXQnLCBvZmZzZXQpXG4gICAgICBoYXNNb3JlID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICBjb25zdCB0cmFuc2FjdGlvbnMgPSBhbGxUcmFuc2FjdGlvbnNcblxuICBpZiAodHJhbnNhY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnNvbGUubG9nKCdbSW5jb21lIEFuYWx5emVyXSBObyBpbmNvbWUgdHJhbnNhY3Rpb25zIGZvdW5kJylcbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIGNvbnNvbGUubG9nKGBbSW5jb21lIEFuYWx5emVyXSBGZXRjaGVkICR7dHJhbnNhY3Rpb25zLmxlbmd0aH0gaW5jb21lIHRyYW5zYWN0aW9uc2ApXG5cbiAgLy8gQWxsIHRyYW5zYWN0aW9ucyBhcmUgaW5jb21lIChmaWx0ZXJlZCBieSBkaXJlY3Rpb24pXG4gIGNvbnN0IGluY29tZVRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucyB8fCBbXVxuXG4gIC8vIEdyb3VwIGJ5IGNhdGVnb3J5IGFuZCBjYWxjdWxhdGUgc3RhdGlzdGljc1xuICBjb25zdCBjYXRlZ29yeU1hcCA9IG5ldyBNYXA8bnVtYmVyLCB7XG4gICAgY2F0ZWdvcnlfaWQ6IG51bWJlclxuICAgIGNhdGVnb3J5X25hbWU6IHN0cmluZ1xuICAgIGFtb3VudHM6IG51bWJlcltdXG4gICAgbW9udGhzOiBTZXQ8c3RyaW5nPlxuICB9PigpXG5cbiAgaW5jb21lVHJhbnNhY3Rpb25zLmZvckVhY2godHggPT4ge1xuICAgIGNvbnN0IGNhdGVnb3J5SWQgPSB0eC5jYXRlZ29yeV9pZCFcbiAgICBjb25zdCBjYXRlZ29yeU5hbWUgPSAodHggYXMgYW55KT8uY2F0ZWdvcnlfbmFtZSB8fCAnVW5rbm93bidcbiAgICBjb25zdCBhbW91bnQgPSAodHggYXMgYW55KS5hbW91bnQgfHwgMFxuICAgIGNvbnN0IG1vbnRoID0gZm9ybWF0KHBhcnNlSVNPKHR4LnRyYW5zYWN0aW9uX2RhdGUpLCAneXl5eS1NTScpXG5cbiAgICBpZiAoIWNhdGVnb3J5TWFwLmhhcyhjYXRlZ29yeUlkKSkge1xuICAgICAgY2F0ZWdvcnlNYXAuc2V0KGNhdGVnb3J5SWQsIHtcbiAgICAgICAgY2F0ZWdvcnlfaWQ6IGNhdGVnb3J5SWQsXG4gICAgICAgIGNhdGVnb3J5X25hbWU6IGNhdGVnb3J5TmFtZSxcbiAgICAgICAgYW1vdW50czogW10sXG4gICAgICAgIG1vbnRoczogbmV3IFNldCgpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGNvbnN0IGVudHJ5ID0gY2F0ZWdvcnlNYXAuZ2V0KGNhdGVnb3J5SWQpIVxuICAgIGVudHJ5LmFtb3VudHMucHVzaChhbW91bnQpXG4gICAgZW50cnkubW9udGhzLmFkZChtb250aClcbiAgfSlcblxuICAvLyBDYWxjdWxhdGUgcHJlZGljdGlvbnMgZm9yIGVhY2ggY2F0ZWdvcnlcbiAgY29uc3QgcHJlZGljdGlvbnM6IEhpc3RvcmljYWxJbmNvbWVbXSA9IEFycmF5LmZyb20oY2F0ZWdvcnlNYXAudmFsdWVzKCkpLm1hcChjYXRlZ29yeSA9PiB7XG4gICAgY29uc3QgbW9udGhzT2ZEYXRhID0gY2F0ZWdvcnkubW9udGhzLnNpemVcbiAgICBjb25zdCB0b3RhbEFtb3VudCA9IGNhdGVnb3J5LmFtb3VudHMucmVkdWNlKChzdW0sIGFtdCkgPT4gc3VtICsgYW10LCAwKVxuICAgIGNvbnN0IG1vbnRobHlBdmVyYWdlID0gdG90YWxBbW91bnQgLyBNYXRoLm1heChtb250aHNPZkRhdGEsIDEpXG5cbiAgICAvLyBDYWxjdWxhdGUgdmFyaWFuY2UgdG8gZGV0ZXJtaW5lIGlmIGl0J3MgcmVjdXJyaW5nXG4gICAgY29uc3QgbWVhbiA9IG1vbnRobHlBdmVyYWdlXG4gICAgY29uc3QgdmFyaWFuY2UgPSBjYXRlZ29yeS5hbW91bnRzLnJlZHVjZSgoc3VtLCBhbXQpID0+IHtcbiAgICAgIHJldHVybiBzdW0gKyBNYXRoLnBvdyhhbXQgLSBtZWFuLCAyKVxuICAgIH0sIDApIC8gY2F0ZWdvcnkuYW1vdW50cy5sZW5ndGhcbiAgICBjb25zdCBzdGREZXYgPSBNYXRoLnNxcnQodmFyaWFuY2UpXG4gICAgY29uc3QgdmFyaWFuY2VQZXJjZW50YWdlID0gbWVhbiA+IDAgPyAoc3RkRGV2IC8gbWVhbikgKiAxMDAgOiAxMDBcblxuICAgIC8vIERldGVybWluZSBpZiByZWN1cnJpbmcgKGxvdyB2YXJpYW5jZSwgYXBwZWFycyBpbiBtb3N0IG1vbnRocylcbiAgICBjb25zdCBhcHBlYXJhbmNlUmF0ZSA9IG1vbnRoc09mRGF0YSAvIG1vbnRoc0JhY2tcbiAgICBjb25zdCBpc1JlY3VycmluZyA9IHZhcmlhbmNlUGVyY2VudGFnZSA8IDE1ICYmIGFwcGVhcmFuY2VSYXRlID49IDAuNVxuXG4gICAgLy8gQ29uZmlkZW5jZSBzY29yaW5nXG4gICAgbGV0IGNvbmZpZGVuY2U6ICdoaWdoJyB8ICdtZWRpdW0nIHwgJ2xvdydcbiAgICBpZiAobW9udGhzT2ZEYXRhID49IDQgJiYgdmFyaWFuY2VQZXJjZW50YWdlIDwgMTApIHtcbiAgICAgIGNvbmZpZGVuY2UgPSAnaGlnaCdcbiAgICB9IGVsc2UgaWYgKG1vbnRoc09mRGF0YSA+PSAzICYmIHZhcmlhbmNlUGVyY2VudGFnZSA8IDMwKSB7XG4gICAgICBjb25maWRlbmNlID0gJ21lZGl1bSdcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZmlkZW5jZSA9ICdsb3cnXG4gICAgfVxuXG4gICAgLy8gRGV0ZXJtaW5lIHNvdXJjZVxuICAgIGxldCBzb3VyY2U6ICdyZWN1cnJpbmcnIHwgJ2F2ZXJhZ2UnIHwgJ2VzdGltYXRlJ1xuICAgIGlmIChpc1JlY3VycmluZykge1xuICAgICAgc291cmNlID0gJ3JlY3VycmluZydcbiAgICB9IGVsc2UgaWYgKG1vbnRoc09mRGF0YSA+PSAzKSB7XG4gICAgICBzb3VyY2UgPSAnYXZlcmFnZSdcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlID0gJ2VzdGltYXRlJ1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjYXRlZ29yeV9pZDogY2F0ZWdvcnkuY2F0ZWdvcnlfaWQsXG4gICAgICBjYXRlZ29yeV9uYW1lOiBjYXRlZ29yeS5jYXRlZ29yeV9uYW1lLFxuICAgICAgbW9udGhseV9hdmVyYWdlOiBtb250aGx5QXZlcmFnZSxcbiAgICAgIG1vbnRoc19vZl9kYXRhOiBtb250aHNPZkRhdGEsXG4gICAgICBpc19yZWN1cnJpbmc6IGlzUmVjdXJyaW5nLFxuICAgICAgY29uZmlkZW5jZSxcbiAgICAgIHNvdXJjZVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gcHJlZGljdGlvbnMuZmlsdGVyKHAgPT4gcC5tb250aGx5X2F2ZXJhZ2UgPiAwKVxufVxuXG4vKipcbiAqIEdldCBjYXRlZ29yaWVzIHRoYXQgYWxyZWFkeSBoYXZlIHNjaGVkdWxlZCBwYXltZW50c1xuICogVGhlc2Ugc2hvdWxkIGJlIGV4Y2x1ZGVkIGZyb20gaGlzdG9yaWNhbCBleHBlbnNlIHByZWRpY3Rpb25zIHRvIHByZXZlbnQgZG91YmxlLWNvdW50aW5nXG4gKlxuICogQHBhcmFtIGVudGl0eUlkIC0gVGhlIGVudGl0eSB0byBjaGVja1xuICogQHBhcmFtIG1vbnRoS2V5IC0gVGhlIG1vbnRoIHRvIGNoZWNrIGZvciAoZm9ybWF0OiAneXl5eS1NTScpXG4gKiBAcmV0dXJucyBTZXQgb2YgY2F0ZWdvcnkgSURzIHRoYXQgaGF2ZSBzY2hlZHVsZWQgcGF5bWVudHNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENhdGVnb3JpZXNXaXRoU2NoZWR1bGVkUGF5bWVudHMoXG4gIGVudGl0eUlkOiBzdHJpbmcsXG4gIG1vbnRoS2V5OiBzdHJpbmdcbik6IFByb21pc2U8U2V0PG51bWJlcj4+IHtcbiAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVTdXBhYmFzZVNlcnZlckNsaWVudCgpXG5cbiAgY29uc3QgbW9udGhTdGFydCA9IHN0YXJ0T2ZNb250aChwYXJzZUlTTyhtb250aEtleSArICctMDEnKSlcbiAgY29uc3QgbW9udGhFbmQgPSBlbmRPZk1vbnRoKG1vbnRoU3RhcnQpXG5cbiAgY29uc3QgeyBkYXRhOiBzY2hlZHVsZWRQYXltZW50cywgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3NjaGVkdWxlZF9wYXltZW50X2luc3RhbmNlcycpXG4gICAgLnNlbGVjdChgXG4gICAgICBzY2hlZHVsZWRfcGF5bWVudHM6c2NoZWR1bGVkX3BheW1lbnRfaWQhaW5uZXIgKFxuICAgICAgICBjYXRlZ29yeV9pZCxcbiAgICAgICAgZW50aXR5X2lkXG4gICAgICApXG4gICAgYClcbiAgICAuZXEoJ3NjaGVkdWxlZF9wYXltZW50cy5lbnRpdHlfaWQnLCBlbnRpdHlJZClcbiAgICAuaW4oJ3N0YXR1cycsIFsncGVuZGluZycsICdvdmVyZHVlJ10pXG4gICAgLmd0ZSgnZHVlX2RhdGUnLCBmb3JtYXQobW9udGhTdGFydCwgJ3l5eXktTU0tZGQnKSlcbiAgICAubHRlKCdkdWVfZGF0ZScsIGZvcm1hdChtb250aEVuZCwgJ3l5eXktTU0tZGQnKSlcblxuICBpZiAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBzY2hlZHVsZWQgcGF5bWVudCBjYXRlZ29yaWVzOicsIGVycm9yKVxuICAgIHJldHVybiBuZXcgU2V0KClcbiAgfVxuXG4gIGNvbnN0IGNhdGVnb3J5SWRzID0gbmV3IFNldDxudW1iZXI+KClcbiAgc2NoZWR1bGVkUGF5bWVudHM/LmZvckVhY2goc3AgPT4ge1xuICAgIGNvbnN0IGNhdGVnb3J5SWQgPSAoc3Auc2NoZWR1bGVkX3BheW1lbnRzIGFzIGFueSk/LmNhdGVnb3J5X2lkXG4gICAgaWYgKGNhdGVnb3J5SWQpIHtcbiAgICAgIGNhdGVnb3J5SWRzLmFkZChjYXRlZ29yeUlkKVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gY2F0ZWdvcnlJZHNcbn1cblxuLyoqXG4gKiBHZXQgc2NoZWR1bGVkIHBheW1lbnQgYW1vdW50cyBieSBjYXRlZ29yeSBmb3IgYSBnaXZlbiBtb250aFxuICogUmV0dXJucyBhIG1hcCBvZiBjYXRlZ29yeV9pZCAtPiB0b3RhbCBzY2hlZHVsZWQgYW1vdW50XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTY2hlZHVsZWRBbW91bnRzQnlDYXRlZ29yeShcbiAgZW50aXR5SWQ6IHN0cmluZyxcbiAgbW9udGhLZXk6IHN0cmluZ1xuKTogUHJvbWlzZTxNYXA8bnVtYmVyLCBudW1iZXI+PiB7XG4gIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlU3VwYWJhc2VTZXJ2ZXJDbGllbnQoKVxuXG4gIGNvbnN0IG1vbnRoU3RhcnQgPSBzdGFydE9mTW9udGgocGFyc2VJU08obW9udGhLZXkgKyAnLTAxJykpXG4gIGNvbnN0IG1vbnRoRW5kID0gZW5kT2ZNb250aChtb250aFN0YXJ0KVxuXG4gIGNvbnN0IHsgZGF0YTogaW5zdGFuY2VzLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgnc2NoZWR1bGVkX3BheW1lbnRfaW5zdGFuY2VzJylcbiAgICAuc2VsZWN0KGBcbiAgICAgIGFtb3VudCxcbiAgICAgIHNjaGVkdWxlZF9wYXltZW50czpzY2hlZHVsZWRfcGF5bWVudF9pZCFpbm5lciAoXG4gICAgICAgIGNhdGVnb3J5X2lkLFxuICAgICAgICBlbnRpdHlfaWRcbiAgICAgIClcbiAgICBgKVxuICAgIC5lcSgnc2NoZWR1bGVkX3BheW1lbnRzLmVudGl0eV9pZCcsIGVudGl0eUlkKVxuICAgIC5pbignc3RhdHVzJywgWydwZW5kaW5nJywgJ292ZXJkdWUnXSlcbiAgICAuZ3RlKCdkdWVfZGF0ZScsIGZvcm1hdChtb250aFN0YXJ0LCAneXl5eS1NTS1kZCcpKVxuICAgIC5sdGUoJ2R1ZV9kYXRlJywgZm9ybWF0KG1vbnRoRW5kLCAneXl5eS1NTS1kZCcpKVxuXG4gIGlmIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHNjaGVkdWxlZCBwYXltZW50IGFtb3VudHM6JywgZXJyb3IpXG4gICAgcmV0dXJuIG5ldyBNYXAoKVxuICB9XG5cbiAgY29uc3QgY2F0ZWdvcnlBbW91bnRzID0gbmV3IE1hcDxudW1iZXIsIG51bWJlcj4oKVxuICBpbnN0YW5jZXM/LmZvckVhY2goaW5zdCA9PiB7XG4gICAgY29uc3QgY2F0ZWdvcnlJZCA9IChpbnN0LnNjaGVkdWxlZF9wYXltZW50cyBhcyBhbnkpPy5jYXRlZ29yeV9pZFxuICAgIGNvbnN0IGFtb3VudCA9IGluc3QuYW1vdW50IHx8IDBcbiAgICBpZiAoY2F0ZWdvcnlJZCkge1xuICAgICAgY29uc3QgY3VycmVudFRvdGFsID0gY2F0ZWdvcnlBbW91bnRzLmdldChjYXRlZ29yeUlkKSB8fCAwXG4gICAgICBjYXRlZ29yeUFtb3VudHMuc2V0KGNhdGVnb3J5SWQsIGN1cnJlbnRUb3RhbCArIGFtb3VudClcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIGNhdGVnb3J5QW1vdW50c1xufVxuXG4vKipcbiAqIEFuYWx5emUgaGlzdG9yaWNhbCBleHBlbnNlIHBhdHRlcm5zIGZyb20gcGFzdCB0cmFuc2FjdGlvbnNcbiAqIEV4Y2x1ZGVzIGNhdGVnb3JpZXMgdGhhdCBoYXZlIHNjaGVkdWxlZCBwYXltZW50cyB0byBwcmV2ZW50IGRvdWJsZS1jb3VudGluZ1xuICpcbiAqIEBwYXJhbSBlbnRpdHlJZCAtIFRoZSBlbnRpdHkgdG8gYW5hbHl6ZVxuICogQHBhcmFtIG1vbnRoS2V5IC0gVGhlIG1vbnRoIHRvIHByZWRpY3QgZm9yICh0byBjaGVjayBzY2hlZHVsZWQgcGF5bWVudHMpXG4gKiBAcGFyYW0gbW9udGhzQmFjayAtIE51bWJlciBvZiBtb250aHMgdG8gbG9vayBiYWNrIChkZWZhdWx0OiA2KVxuICogQHJldHVybnMgQXJyYXkgb2YgZXhwZW5zZSBwcmVkaWN0aW9ucyBieSBjYXRlZ29yeVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYW5hbHl6ZUhpc3RvcmljYWxFeHBlbnNlcyhcbiAgZW50aXR5SWQ6IHN0cmluZyxcbiAgbW9udGhLZXk6IHN0cmluZyxcbiAgbW9udGhzQmFjazogbnVtYmVyID0gNlxuKTogUHJvbWlzZTxIaXN0b3JpY2FsRXhwZW5zZVtdPiB7XG4gIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlU3VwYWJhc2VTZXJ2ZXJDbGllbnQoKVxuXG4gIGNvbnN0IHN0YXJ0RGF0ZSA9IHN0YXJ0T2ZNb250aChzdWJNb250aHMobmV3IERhdGUoKSwgbW9udGhzQmFjaykpXG4gIGNvbnN0IGVuZERhdGUgPSBlbmRPZk1vbnRoKG5ldyBEYXRlKCkpXG5cbiAgLy8gR2V0IGNhdGVnb3JpZXMgd2l0aCBzY2hlZHVsZWQgcGF5bWVudHMgKHRvIGV4Y2x1ZGUpXG4gIGNvbnN0IHNjaGVkdWxlZENhdGVnb3JpZXMgPSBhd2FpdCBnZXRDYXRlZ29yaWVzV2l0aFNjaGVkdWxlZFBheW1lbnRzKGVudGl0eUlkLCBtb250aEtleSlcblxuICAvLyBGZXRjaCBleHBlbnNlIHRyYW5zYWN0aW9ucyAoZGViaXQgZGlyZWN0aW9uIHRyYW5zYWN0aW9ucylcbiAgLy8gRXhjbHVkZSB0cmFuc2ZlcnMgKFRSRl9PVVQpIGFuZCBkZWJ0IHBheW1lbnRzIChERUJUX1BBWUJBQ0spIGFzIHRoZXkgYXJlIG5vdCByZWd1bGFyIGV4cGVuc2VzXG4gIC8vIFVzZSBwYWdpbmF0aW9uIHRvIGdldCBBTEwgcmVzdWx0cyAoU3VwYWJhc2UgZGVmYXVsdHMgdG8gMTAwMCByb3dzIG1heClcbiAgY29uc3QgUEFHRV9TSVpFID0gMTAwMFxuICBsZXQgYWxsVHJhbnNhY3Rpb25zOiBhbnlbXSA9IFtdXG4gIGxldCBvZmZzZXQgPSAwXG4gIGxldCBoYXNNb3JlID0gdHJ1ZVxuXG4gIHdoaWxlIChoYXNNb3JlKSB7XG4gICAgY29uc3QgeyBkYXRhOiBwYWdlRGF0YSwgZXJyb3I6IHBhZ2VFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdtYWluX3RyYW5zYWN0aW9uX2RldGFpbHMnKVxuICAgICAgLnNlbGVjdChgXG4gICAgICAgIG1haW5fdHJhbnNhY3Rpb25faWQsXG4gICAgICAgIHRyYW5zYWN0aW9uX2RhdGUsXG4gICAgICAgIGFtb3VudCxcbiAgICAgICAgdHJhbnNhY3Rpb25fZGlyZWN0aW9uLFxuICAgICAgICBjYXRlZ29yeV9pZCxcbiAgICAgICAgY2F0ZWdvcnlfbmFtZSxcbiAgICAgICAgdHJhbnNhY3Rpb25fdHlwZV9jb2RlLFxuICAgICAgICBhZmZlY3RzX2Nhc2hmbG93XG4gICAgICBgKVxuICAgICAgLmVxKCdlbnRpdHlfaWQnLCBlbnRpdHlJZClcbiAgICAgIC5ndGUoJ3RyYW5zYWN0aW9uX2RhdGUnLCBmb3JtYXQoc3RhcnREYXRlLCAneXl5eS1NTS1kZCcpKVxuICAgICAgLmx0ZSgndHJhbnNhY3Rpb25fZGF0ZScsIGZvcm1hdChlbmREYXRlLCAneXl5eS1NTS1kZCcpKVxuICAgICAgLm5vdCgnY2F0ZWdvcnlfaWQnLCAnaXMnLCBudWxsKVxuICAgICAgLmVxKCd0cmFuc2FjdGlvbl9kaXJlY3Rpb24nLCAnZGViaXQnKSAvLyBPbmx5IGRlYml0IHRyYW5zYWN0aW9ucyAoZXhwZW5zZXMpXG4gICAgICAuZXEoJ2FmZmVjdHNfY2FzaGZsb3cnLCB0cnVlKSAvLyBPbmx5IHRyYW5zYWN0aW9ucyB0aGF0IGFmZmVjdCBjYXNoIGZsb3dcbiAgICAgIC5ub3QoJ3RyYW5zYWN0aW9uX3R5cGVfY29kZScsICdpbicsICcoVFJGX09VVCxERUJUX1RBS0UsREVCVF9QQVlCQUNLKScpIC8vIEV4Y2x1ZGUgdHJhbnNmZXJzIGFuZCBkZWJ0LXJlbGF0ZWRcbiAgICAgIC5vcmRlcignbWFpbl90cmFuc2FjdGlvbl9pZCcsIHsgYXNjZW5kaW5nOiB0cnVlIH0pXG4gICAgICAucmFuZ2Uob2Zmc2V0LCBvZmZzZXQgKyBQQUdFX1NJWkUgLSAxKVxuXG4gICAgaWYgKHBhZ2VFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgZXhwZW5zZSB0cmFuc2FjdGlvbnMgYXQgb2Zmc2V0Jywgb2Zmc2V0LCAnOicsIHBhZ2VFcnJvcilcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgaWYgKHBhZ2VEYXRhICYmIHBhZ2VEYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIGFsbFRyYW5zYWN0aW9ucyA9IGFsbFRyYW5zYWN0aW9ucy5jb25jYXQocGFnZURhdGEpXG4gICAgICBvZmZzZXQgKz0gUEFHRV9TSVpFXG4gICAgICBoYXNNb3JlID0gcGFnZURhdGEubGVuZ3RoID09PSBQQUdFX1NJWkVcbiAgICB9IGVsc2Uge1xuICAgICAgaGFzTW9yZSA9IGZhbHNlXG4gICAgfVxuXG4gICAgLy8gU2FmZXR5IGxpbWl0XG4gICAgaWYgKG9mZnNldCA+IDUwMDAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1tFeHBlbnNlIEFuYWx5emVyXSBTYWZldHkgbGltaXQgcmVhY2hlZCBhdCBvZmZzZXQnLCBvZmZzZXQpXG4gICAgICBoYXNNb3JlID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICBjb25zdCB0cmFuc2FjdGlvbnMgPSBhbGxUcmFuc2FjdGlvbnNcblxuICBpZiAodHJhbnNhY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnNvbGUubG9nKCdbRXhwZW5zZSBBbmFseXplcl0gTm8gZXhwZW5zZSB0cmFuc2FjdGlvbnMgZm91bmQnKVxuICAgIHJldHVybiBbXVxuICB9XG5cbiAgY29uc29sZS5sb2coYFtFeHBlbnNlIEFuYWx5emVyXSBGZXRjaGVkICR7dHJhbnNhY3Rpb25zLmxlbmd0aH0gZXhwZW5zZSB0cmFuc2FjdGlvbnNgKVxuXG4gIC8vIEFsbCB0cmFuc2FjdGlvbnMgYXJlIGV4cGVuc2VzIChmaWx0ZXJlZCBieSBkaXJlY3Rpb24pXG4gIGNvbnN0IGV4cGVuc2VUcmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMgfHwgW11cblxuICAvLyBHcm91cCBieSBjYXRlZ29yeSBhbmQgY2FsY3VsYXRlIHN0YXRpc3RpY3NcbiAgY29uc3QgY2F0ZWdvcnlNYXAgPSBuZXcgTWFwPG51bWJlciwge1xuICAgIGNhdGVnb3J5X2lkOiBudW1iZXJcbiAgICBjYXRlZ29yeV9uYW1lOiBzdHJpbmdcbiAgICBhbW91bnRzOiBudW1iZXJbXVxuICAgIG1vbnRoczogU2V0PHN0cmluZz5cbiAgfT4oKVxuXG4gIGV4cGVuc2VUcmFuc2FjdGlvbnMuZm9yRWFjaCh0eCA9PiB7XG4gICAgY29uc3QgY2F0ZWdvcnlJZCA9IHR4LmNhdGVnb3J5X2lkIVxuICAgIGNvbnN0IGNhdGVnb3J5TmFtZSA9ICh0eCBhcyBhbnkpPy5jYXRlZ29yeV9uYW1lIHx8ICdVbmtub3duJ1xuICAgIGNvbnN0IGFtb3VudCA9ICh0eCBhcyBhbnkpLmFtb3VudCB8fCAwXG4gICAgY29uc3QgbW9udGggPSBmb3JtYXQocGFyc2VJU08odHgudHJhbnNhY3Rpb25fZGF0ZSksICd5eXl5LU1NJylcblxuICAgIGlmICghY2F0ZWdvcnlNYXAuaGFzKGNhdGVnb3J5SWQpKSB7XG4gICAgICBjYXRlZ29yeU1hcC5zZXQoY2F0ZWdvcnlJZCwge1xuICAgICAgICBjYXRlZ29yeV9pZDogY2F0ZWdvcnlJZCxcbiAgICAgICAgY2F0ZWdvcnlfbmFtZTogY2F0ZWdvcnlOYW1lLFxuICAgICAgICBhbW91bnRzOiBbXSxcbiAgICAgICAgbW9udGhzOiBuZXcgU2V0KClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgY29uc3QgZW50cnkgPSBjYXRlZ29yeU1hcC5nZXQoY2F0ZWdvcnlJZCkhXG4gICAgZW50cnkuYW1vdW50cy5wdXNoKGFtb3VudClcbiAgICBlbnRyeS5tb250aHMuYWRkKG1vbnRoKVxuICB9KVxuXG4gIC8vIENhbGN1bGF0ZSBwcmVkaWN0aW9ucyBmb3IgZWFjaCBjYXRlZ29yeVxuICBjb25zdCBwcmVkaWN0aW9uczogSGlzdG9yaWNhbEV4cGVuc2VbXSA9IEFycmF5LmZyb20oY2F0ZWdvcnlNYXAudmFsdWVzKCkpLm1hcChjYXRlZ29yeSA9PiB7XG4gICAgY29uc3QgbW9udGhzT2ZEYXRhID0gY2F0ZWdvcnkubW9udGhzLnNpemVcbiAgICBjb25zdCB0b3RhbEFtb3VudCA9IGNhdGVnb3J5LmFtb3VudHMucmVkdWNlKChzdW0sIGFtdCkgPT4gc3VtICsgYW10LCAwKVxuICAgIGNvbnN0IG1vbnRobHlBdmVyYWdlID0gdG90YWxBbW91bnQgLyBNYXRoLm1heChtb250aHNPZkRhdGEsIDEpXG5cbiAgICAvLyBDYWxjdWxhdGUgdmFyaWFuY2VcbiAgICBjb25zdCBtZWFuID0gbW9udGhseUF2ZXJhZ2VcbiAgICBjb25zdCB2YXJpYW5jZSA9IGNhdGVnb3J5LmFtb3VudHMucmVkdWNlKChzdW0sIGFtdCkgPT4ge1xuICAgICAgcmV0dXJuIHN1bSArIE1hdGgucG93KGFtdCAtIG1lYW4sIDIpXG4gICAgfSwgMCkgLyBjYXRlZ29yeS5hbW91bnRzLmxlbmd0aFxuICAgIGNvbnN0IHN0ZERldiA9IE1hdGguc3FydCh2YXJpYW5jZSlcbiAgICBjb25zdCB2YXJpYW5jZVBlcmNlbnRhZ2UgPSBtZWFuID4gMCA/IChzdGREZXYgLyBtZWFuKSAqIDEwMCA6IDEwMFxuXG4gICAgLy8gQ29uZmlkZW5jZSBzY29yaW5nXG4gICAgbGV0IGNvbmZpZGVuY2U6ICdoaWdoJyB8ICdtZWRpdW0nIHwgJ2xvdydcbiAgICBpZiAobW9udGhzT2ZEYXRhID49IDQgJiYgdmFyaWFuY2VQZXJjZW50YWdlIDwgMTApIHtcbiAgICAgIGNvbmZpZGVuY2UgPSAnaGlnaCdcbiAgICB9IGVsc2UgaWYgKG1vbnRoc09mRGF0YSA+PSAzICYmIHZhcmlhbmNlUGVyY2VudGFnZSA8IDMwKSB7XG4gICAgICBjb25maWRlbmNlID0gJ21lZGl1bSdcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZmlkZW5jZSA9ICdsb3cnXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNhdGVnb3J5X2lkOiBjYXRlZ29yeS5jYXRlZ29yeV9pZCxcbiAgICAgIGNhdGVnb3J5X25hbWU6IGNhdGVnb3J5LmNhdGVnb3J5X25hbWUsXG4gICAgICBtb250aGx5X2F2ZXJhZ2U6IG1vbnRobHlBdmVyYWdlLFxuICAgICAgbW9udGhzX29mX2RhdGE6IG1vbnRoc09mRGF0YSxcbiAgICAgIGNvbmZpZGVuY2UsXG4gICAgICB2YXJpYW5jZV9wZXJjZW50YWdlOiB2YXJpYW5jZVBlcmNlbnRhZ2UsXG4gICAgICBoYXNfc2NoZWR1bGVkX3BheW1lbnQ6IGZhbHNlIC8vIEFscmVhZHkgZmlsdGVyZWQgb3V0XG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBwcmVkaWN0aW9ucy5maWx0ZXIocCA9PiBwLm1vbnRobHlfYXZlcmFnZSA+IDApXG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRvdGFsIHByZWRpY3RlZCBpbmNvbWUgZm9yIGEgbW9udGhcbiAqXG4gKiBAcGFyYW0gZW50aXR5SWQgLSBUaGUgZW50aXR5IHRvIGFuYWx5emVcbiAqIEByZXR1cm5zIFRvdGFsIHByZWRpY3RlZCBtb250aGx5IGluY29tZSBhbmQgYnJlYWtkb3duXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWxjdWxhdGVQcmVkaWN0ZWRJbmNvbWUoXG4gIGVudGl0eUlkOiBzdHJpbmdcbik6IFByb21pc2U8eyB0b3RhbDogbnVtYmVyOyBicmVha2Rvd246IEluY29tZUJyZWFrZG93bltdIH0+IHtcbiAgY29uc3QgaW5jb21lRGF0YSA9IGF3YWl0IGFuYWx5emVIaXN0b3JpY2FsSW5jb21lKGVudGl0eUlkLCA2KVxuXG4gIGNvbnN0IGJyZWFrZG93bjogSW5jb21lQnJlYWtkb3duW10gPSBpbmNvbWVEYXRhLm1hcChpbmNvbWUgPT4gKHtcbiAgICBjYXRlZ29yeV9uYW1lOiBpbmNvbWUuY2F0ZWdvcnlfbmFtZSxcbiAgICBhbW91bnQ6IGluY29tZS5tb250aGx5X2F2ZXJhZ2UsXG4gICAgY29uZmlkZW5jZTogaW5jb21lLmNvbmZpZGVuY2UsXG4gICAgc291cmNlOiBpbmNvbWUuc291cmNlXG4gIH0pKVxuXG4gIGNvbnN0IHRvdGFsID0gaW5jb21lRGF0YS5yZWR1Y2UoKHN1bSwgaW5jb21lKSA9PiBzdW0gKyBpbmNvbWUubW9udGhseV9hdmVyYWdlLCAwKVxuXG4gIHJldHVybiB7IHRvdGFsLCBicmVha2Rvd24gfVxufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBwcmVkaWN0ZWQgZXhwZW5zZXMgZm9yIGEgbW9udGgsIGV4Y2x1ZGluZyBzY2hlZHVsZWQgcGF5bWVudHNcbiAqXG4gKiBAcGFyYW0gZW50aXR5SWQgLSBUaGUgZW50aXR5IHRvIGFuYWx5emVcbiAqIEBwYXJhbSBtb250aEtleSAtIFRoZSBtb250aCB0byBwcmVkaWN0IGZvclxuICogQHJldHVybnMgUHJlZGljdGVkIGV4cGVuc2VzIGJyZWFrZG93blxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlUHJlZGljdGVkRXhwZW5zZXMoXG4gIGVudGl0eUlkOiBzdHJpbmcsXG4gIG1vbnRoS2V5OiBzdHJpbmdcbik6IFByb21pc2U8UHJlZGljdGVkRXhwZW5zZVtdPiB7XG4gIGNvbnN0IGV4cGVuc2VEYXRhID0gYXdhaXQgYW5hbHl6ZUhpc3RvcmljYWxFeHBlbnNlcyhlbnRpdHlJZCwgbW9udGhLZXksIDYpXG4gIGNvbnN0IHNjaGVkdWxlZEFtb3VudHMgPSBhd2FpdCBnZXRTY2hlZHVsZWRBbW91bnRzQnlDYXRlZ29yeShlbnRpdHlJZCwgbW9udGhLZXkpXG5cbiAgY29uc3QgcHJlZGljdGlvbnM6IFByZWRpY3RlZEV4cGVuc2VbXSA9IFtdXG5cbiAgZXhwZW5zZURhdGEuZm9yRWFjaChleHBlbnNlID0+IHtcbiAgICBjb25zdCBzY2hlZHVsZWRBbW91bnQgPSBzY2hlZHVsZWRBbW91bnRzLmdldChleHBlbnNlLmNhdGVnb3J5X2lkKSB8fCAwXG4gICAgY29uc3QgaGlzdG9yaWNhbEF2ZXJhZ2UgPSBleHBlbnNlLm1vbnRobHlfYXZlcmFnZVxuXG4gICAgLy8gSWYgdGhlcmUncyBubyBzY2hlZHVsZWQgcGF5bWVudCwgc2hvdyBmdWxsIGhpc3RvcmljYWwgYXZlcmFnZVxuICAgIGlmIChzY2hlZHVsZWRBbW91bnQgPT09IDApIHtcbiAgICAgIHByZWRpY3Rpb25zLnB1c2goe1xuICAgICAgICBjYXRlZ29yeV9uYW1lOiBleHBlbnNlLmNhdGVnb3J5X25hbWUsXG4gICAgICAgIGFtb3VudDogaGlzdG9yaWNhbEF2ZXJhZ2UsXG4gICAgICAgIGhpc3RvcmljYWxfYXZlcmFnZTogaGlzdG9yaWNhbEF2ZXJhZ2UsXG4gICAgICAgIG1vbnRoc19vZl9kYXRhOiBleHBlbnNlLm1vbnRoc19vZl9kYXRhLFxuICAgICAgICBjb25maWRlbmNlOiBleHBlbnNlLmNvbmZpZGVuY2UsXG4gICAgICAgIGhhc19nYXA6IGZhbHNlXG4gICAgICB9KVxuICAgIH1cbiAgICAvLyBJZiBoaXN0b3JpY2FsIGF2ZXJhZ2UgPiBzY2hlZHVsZWQsIHNob3cgdGhlIGdhcFxuICAgIGVsc2UgaWYgKGhpc3RvcmljYWxBdmVyYWdlID4gc2NoZWR1bGVkQW1vdW50KSB7XG4gICAgICBjb25zdCBnYXBBbW91bnQgPSBoaXN0b3JpY2FsQXZlcmFnZSAtIHNjaGVkdWxlZEFtb3VudFxuICAgICAgcHJlZGljdGlvbnMucHVzaCh7XG4gICAgICAgIGNhdGVnb3J5X25hbWU6IGV4cGVuc2UuY2F0ZWdvcnlfbmFtZSxcbiAgICAgICAgYW1vdW50OiBnYXBBbW91bnQsXG4gICAgICAgIGhpc3RvcmljYWxfYXZlcmFnZTogaGlzdG9yaWNhbEF2ZXJhZ2UsXG4gICAgICAgIG1vbnRoc19vZl9kYXRhOiBleHBlbnNlLm1vbnRoc19vZl9kYXRhLFxuICAgICAgICBjb25maWRlbmNlOiBleHBlbnNlLmNvbmZpZGVuY2UsXG4gICAgICAgIGhhc19nYXA6IHRydWUsXG4gICAgICAgIHNjaGVkdWxlZF9hbW91bnQ6IHNjaGVkdWxlZEFtb3VudFxuICAgICAgfSlcbiAgICB9XG4gICAgLy8gSWYgc2NoZWR1bGVkID49IGhpc3RvcmljYWwsIGRvbid0IHNob3cgaW4gcHJlZGljdGlvbnMgKGZ1bGx5IGNvdmVyZWQpXG4gICAgLy8gVGhpcyBwcmV2ZW50cyBzaG93aW5nIHRoZSBjYXRlZ29yeSBpbiBQcmlvcml0eSAyIGF0IGFsbFxuICB9KVxuXG4gIHJldHVybiBwcmVkaWN0aW9uc1xufVxuXG4vKipcbiAqIENvbXBhcmUgcHJlZGljdGVkIGV4cGVuc2VzIHdpdGggYnVkZ2V0cyB0byBnZW5lcmF0ZSB3YXJuaW5nc1xuICpcbiAqIEBwYXJhbSBwcmVkaWN0ZWRFeHBlbnNlcyAtIFByZWRpY3RlZCBleHBlbnNlIGFtb3VudHNcbiAqIEBwYXJhbSBidWRnZXRzIC0gQWN0aXZlIGJ1ZGdldHNcbiAqIEByZXR1cm5zIEFycmF5IG9mIGJ1ZGdldCB3YXJuaW5ncyBmb3Igb3ZlcmFnZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVCdWRnZXRzKFxuICBwcmVkaWN0ZWRFeHBlbnNlczogUHJlZGljdGVkRXhwZW5zZVtdLFxuICBidWRnZXRzOiBBcnJheTx7IGNhdGVnb3J5X25hbWU6IHN0cmluZzsgYnVkZ2V0X2Ftb3VudDogbnVtYmVyIH0+XG4pOiBCdWRnZXRXYXJuaW5nW10ge1xuICBjb25zdCB3YXJuaW5nczogQnVkZ2V0V2FybmluZ1tdID0gW11cblxuICAvLyBDcmVhdGUgYSBtYXAgb2YgYnVkZ2V0cyBieSBjYXRlZ29yeVxuICBjb25zdCBidWRnZXRNYXAgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpXG4gIGJ1ZGdldHMuZm9yRWFjaChidWRnZXQgPT4ge1xuICAgIGJ1ZGdldE1hcC5zZXQoYnVkZ2V0LmNhdGVnb3J5X25hbWUsIGJ1ZGdldC5idWRnZXRfYW1vdW50KVxuICB9KVxuXG4gIC8vIENoZWNrIGVhY2ggcHJlZGljdGVkIGV4cGVuc2UgYWdhaW5zdCBidWRnZXRcbiAgcHJlZGljdGVkRXhwZW5zZXMuZm9yRWFjaChleHBlbnNlID0+IHtcbiAgICBjb25zdCBidWRnZXRBbW91bnQgPSBidWRnZXRNYXAuZ2V0KGV4cGVuc2UuY2F0ZWdvcnlfbmFtZSlcbiAgICBpZiAoYnVkZ2V0QW1vdW50ICYmIGV4cGVuc2UuYW1vdW50ID4gYnVkZ2V0QW1vdW50KSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKHtcbiAgICAgICAgY2F0ZWdvcnlfbmFtZTogZXhwZW5zZS5jYXRlZ29yeV9uYW1lLFxuICAgICAgICBwcm9qZWN0ZWQ6IGV4cGVuc2UuYW1vdW50LFxuICAgICAgICBidWRnZXQ6IGJ1ZGdldEFtb3VudCxcbiAgICAgICAgdmFyaWFuY2U6IGV4cGVuc2UuYW1vdW50IC0gYnVkZ2V0QW1vdW50XG4gICAgICB9KVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gd2FybmluZ3Ncbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBDQVNIIEZMT1cgMy4wOiBMSVFVSURJVFkgJiBTT0xWRU5DWSBBTkFMWVNJU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWNjb3VudEJhbGFuY2Uge1xuICBhY2NvdW50X2lkOiBudW1iZXJcbiAgYWNjb3VudF9uYW1lOiBzdHJpbmdcbiAgYWNjb3VudF90eXBlOiBzdHJpbmdcbiAgY3VycmVudF9iYWxhbmNlOiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWNlaXZhYmxlTG9hbiB7XG4gIGxvYW5fZGlzYnVyc2VtZW50X2lkOiBudW1iZXJcbiAgYm9ycm93ZXJfbmFtZTogc3RyaW5nXG4gIHJlbWFpbmluZ19iYWxhbmNlOiBudW1iZXJcbiAgZHVlX2RhdGU6IHN0cmluZyB8IG51bGxcbiAgaXNfb3ZlcmR1ZTogYm9vbGVhblxuICBkYXlzX292ZXJkdWU6IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIExpcXVpZGl0eVBvc2l0aW9uIHtcbiAgLy8gQ2FzaCBhY2NvdW50cyAoY2hlY2tpbmcsIHNhdmluZ3MpXG4gIGNhc2hfYmFsYW5jZTogbnVtYmVyXG4gIGNhc2hfYWNjb3VudHM6IEFjY291bnRCYWxhbmNlW11cbiAgXG4gIC8vIEludmVzdG1lbnQgYWNjb3VudHMgKHN0b2NrcywgYm9uZHMsIGZ1bmRzKVxuICBpbnZlc3RtZW50X2JhbGFuY2U6IG51bWJlclxuICBpbnZlc3RtZW50X2FjY291bnRzOiBBY2NvdW50QmFsYW5jZVtdXG4gIFxuICAvLyBSZWNlaXZhYmxlcyAobG9hbnMgZ2l2ZW4gb3V0KVxuICByZWNlaXZhYmxlc19iYWxhbmNlOiBudW1iZXJcbiAgcmVjZWl2YWJsZXM6IFJlY2VpdmFibGVMb2FuW11cbiAgb3ZlcmR1ZV9yZWNlaXZhYmxlczogbnVtYmVyXG4gIG92ZXJkdWVfY291bnQ6IG51bWJlclxuICBcbiAgLy8gVG90YWwgbGlxdWlkaXR5XG4gIHRvdGFsX2xpcXVpZF9hc3NldHM6IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJ1bndheUFuYWx5c2lzIHtcbiAgbW9udGhseV9idXJuX3JhdGU6IG51bWJlclxuICBjYXNoX3J1bndheV9tb250aHM6IG51bWJlclxuICBsaXF1aWRpdHlfcnVud2F5X21vbnRoczogbnVtYmVyXG4gIHF1aWNrX3JhdGlvOiBudW1iZXJcbiAgd2lsbF9ydW5fb3V0X29mX2Nhc2g6IGJvb2xlYW5cbiAgY2FzaF9kZXBsZXRpb25fbW9udGg6IHN0cmluZyB8IG51bGxcbiAgbGlxdWlkaXR5X2J1ZmZlcjogbnVtYmVyIC8vIEV4dHJhIG1vbnRocyBmcm9tIGludmVzdG1lbnRzICsgcmVjZWl2YWJsZXNcbn1cblxuLyoqXG4gKiBHZXQgYWxsIGFjY291bnQgYmFsYW5jZXMgZ3JvdXBlZCBieSB0eXBlXG4gKiBcbiAqIEBwYXJhbSBlbnRpdHlJZCAtIFRoZSBlbnRpdHkgdG8gYW5hbHl6ZVxuICogQHJldHVybnMgQWNjb3VudCBiYWxhbmNlcyBncm91cGVkIGJ5IHR5cGVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFjY291bnRCYWxhbmNlc0J5VHlwZShcbiAgZW50aXR5SWQ6IHN0cmluZ1xuKTogUHJvbWlzZTx7IGNhc2g6IEFjY291bnRCYWxhbmNlW107IGludmVzdG1lbnRzOiBBY2NvdW50QmFsYW5jZVtdOyB0b3RhbF9jYXNoOiBudW1iZXI7IHRvdGFsX2ludmVzdG1lbnRzOiBudW1iZXIgfT4ge1xuICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZVN1cGFiYXNlU2VydmVyQ2xpZW50KClcblxuICAvLyBHZXQgYWxsIGFjY291bnRzIHdpdGggdGhlaXIgYmFsYW5jZXNcbiAgY29uc3QgeyBkYXRhOiBhY2NvdW50cywgZXJyb3I6IGFjY291bnRzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ2FjY291bnRzJylcbiAgICAuc2VsZWN0KCdhY2NvdW50X2lkLCBhY2NvdW50X25hbWUsIGFjY291bnRfdHlwZScpXG4gICAgLmVxKCdlbnRpdHlfaWQnLCBlbnRpdHlJZClcbiAgICAuZXEoJ2lzX2FjdGl2ZScsIHRydWUpXG5cbiAgaWYgKGFjY291bnRzRXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBhY2NvdW50czonLCBhY2NvdW50c0Vycm9yKVxuICAgIHJldHVybiB7IGNhc2g6IFtdLCBpbnZlc3RtZW50czogW10sIHRvdGFsX2Nhc2g6IDAsIHRvdGFsX2ludmVzdG1lbnRzOiAwIH1cbiAgfVxuXG4gIGNvbnNvbGUubG9nKGBbTGlxdWlkaXR5XSBGb3VuZCAke2FjY291bnRzPy5sZW5ndGggfHwgMH0gYWNjb3VudHMgZm9yIGVudGl0eSAke2VudGl0eUlkfWApXG4gIGNvbnNvbGUubG9nKGBbTGlxdWlkaXR5XSBBY2NvdW50IHR5cGVzOiAke2FjY291bnRzPy5tYXAoYSA9PiBgJHthLmFjY291bnRfbmFtZX0oJHthLmFjY291bnRfdHlwZX0pYCkuam9pbignLCAnKX1gKVxuXG4gIGNvbnN0IGFjY291bnRJZHMgPSBhY2NvdW50cz8ubWFwKGEgPT4gYS5hY2NvdW50X2lkKSB8fCBbXVxuXG4gIGlmIChhY2NvdW50SWRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7IGNhc2g6IFtdLCBpbnZlc3RtZW50czogW10sIHRvdGFsX2Nhc2g6IDAsIHRvdGFsX2ludmVzdG1lbnRzOiAwIH1cbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSBiYWxhbmNlcyBmb3IgdGhvc2UgYWNjb3VudHMgdXNpbmcgUlBDIGZ1bmN0aW9uXG4gIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0gLy8gWVlZWS1NTS1ERFxuICBjb25zdCBhY2NvdW50c1dpdGhCYWxhbmNlczogQWNjb3VudEJhbGFuY2VbXSA9IFtdXG5cbiAgZm9yIChjb25zdCBhY2Mgb2YgKGFjY291bnRzIHx8IFtdKSkge1xuICAgIGNvbnN0IHsgZGF0YTogYmFsYW5jZSwgZXJyb3I6IGJhbGFuY2VFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UucnBjKCdjYWxjdWxhdGVfYmFsYW5jZV91cF90b19kYXRlJywge1xuICAgICAgcF9hY2NvdW50X2lkOiBhY2MuYWNjb3VudF9pZCxcbiAgICAgIHBfdXBfdG9fZGF0ZTogdG9kYXksXG4gICAgfSlcblxuICAgIGlmIChiYWxhbmNlRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFtMaXF1aWRpdHldIEVycm9yIGNhbGN1bGF0aW5nIGJhbGFuY2UgZm9yICR7YWNjLmFjY291bnRfbmFtZX06YCwgSlNPTi5zdHJpbmdpZnkoYmFsYW5jZUVycm9yKSlcbiAgICB9XG4gICAgY29uc29sZS5sb2coYFtMaXF1aWRpdHldICR7YWNjLmFjY291bnRfbmFtZX0gKCR7YWNjLmFjY291bnRfdHlwZX0pIGJhbGFuY2U6ICR7YmFsYW5jZSB8fCAwfWApXG5cbiAgICBhY2NvdW50c1dpdGhCYWxhbmNlcy5wdXNoKHtcbiAgICAgIGFjY291bnRfaWQ6IGFjYy5hY2NvdW50X2lkLFxuICAgICAgYWNjb3VudF9uYW1lOiBhY2MuYWNjb3VudF9uYW1lLFxuICAgICAgYWNjb3VudF90eXBlOiBhY2MuYWNjb3VudF90eXBlLFxuICAgICAgY3VycmVudF9iYWxhbmNlOiBiYWxhbmNlIHx8IDBcbiAgICB9KVxuICB9XG5cbiAgLy8gU2VwYXJhdGUgY2FzaCBhY2NvdW50cyBmcm9tIGludmVzdG1lbnQgYWNjb3VudHNcbiAgLy8gQmFzZWQgb24gQWNjb3VudFR5cGU6ICdiYW5rJyB8ICdjYXNoJyB8ICdjcmVkaXRfY2FyZCcgfCAnaW52ZXN0bWVudCcgfCAnY3JlZGl0X2xpbmUnIHwgJ3Rlcm1fbG9hbicgfCAnbG9hbl9yZWNlaXZhYmxlJ1xuICBjb25zdCBjYXNoQWNjb3VudHMgPSBhY2NvdW50c1dpdGhCYWxhbmNlcy5maWx0ZXIoYSA9PlxuICAgIGEuYWNjb3VudF90eXBlID09PSAnYmFuaycgfHxcbiAgICBhLmFjY291bnRfdHlwZSA9PT0gJ2Nhc2gnXG4gIClcblxuICBjb25zdCBpbnZlc3RtZW50QWNjb3VudHMgPSBhY2NvdW50c1dpdGhCYWxhbmNlcy5maWx0ZXIoYSA9PlxuICAgIGEuYWNjb3VudF90eXBlID09PSAnaW52ZXN0bWVudCdcbiAgKVxuXG4gIGNvbnN0IHRvdGFsQ2FzaCA9IGNhc2hBY2NvdW50cy5yZWR1Y2UoKHN1bSwgYSkgPT4gc3VtICsgYS5jdXJyZW50X2JhbGFuY2UsIDApXG4gIGNvbnN0IHRvdGFsSW52ZXN0bWVudHMgPSBpbnZlc3RtZW50QWNjb3VudHMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEuY3VycmVudF9iYWxhbmNlLCAwKVxuXG4gIHJldHVybiB7XG4gICAgY2FzaDogY2FzaEFjY291bnRzLFxuICAgIGludmVzdG1lbnRzOiBpbnZlc3RtZW50QWNjb3VudHMsXG4gICAgdG90YWxfY2FzaDogdG90YWxDYXNoLFxuICAgIHRvdGFsX2ludmVzdG1lbnRzOiB0b3RhbEludmVzdG1lbnRzXG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgb3V0c3RhbmRpbmcgcmVjZWl2YWJsZXMgKGxvYW5zIGdpdmVuIHRvIG90aGVycylcbiAqIFxuICogQHBhcmFtIGVudGl0eUlkIC0gVGhlIGVudGl0eSB0byBhbmFseXplXG4gKiBAcmV0dXJucyBSZWNlaXZhYmxlcyBzdW1tYXJ5XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhbmFseXplUmVjZWl2YWJsZXMoXG4gIGVudGl0eUlkOiBzdHJpbmdcbik6IFByb21pc2U8eyB0b3RhbDogbnVtYmVyOyBvdmVyZHVlX3RvdGFsOiBudW1iZXI7IGxvYW5zOiBSZWNlaXZhYmxlTG9hbltdIH0+IHtcbiAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVTdXBhYmFzZVNlcnZlckNsaWVudCgpXG5cbiAgLy8gR2V0IGFsbCBhY2NvdW50cyBmb3IgdGhpcyBlbnRpdHlcbiAgY29uc3QgeyBkYXRhOiBhY2NvdW50cywgZXJyb3I6IGFjY291bnRzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ2FjY291bnRzJylcbiAgICAuc2VsZWN0KCdhY2NvdW50X2lkJylcbiAgICAuZXEoJ2VudGl0eV9pZCcsIGVudGl0eUlkKVxuICAgIC5lcSgnaXNfYWN0aXZlJywgdHJ1ZSlcblxuICBpZiAoYWNjb3VudHNFcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGFjY291bnRzIGZvciByZWNlaXZhYmxlczonLCBhY2NvdW50c0Vycm9yKVxuICAgIHJldHVybiB7IHRvdGFsOiAwLCBvdmVyZHVlX3RvdGFsOiAwLCBsb2FuczogW10gfVxuICB9XG5cbiAgY29uc3QgYWNjb3VudElkcyA9IGFjY291bnRzPy5tYXAoYSA9PiBhLmFjY291bnRfaWQpIHx8IFtdXG5cbiAgaWYgKGFjY291bnRJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHsgdG90YWw6IDAsIG92ZXJkdWVfdG90YWw6IDAsIGxvYW5zOiBbXSB9XG4gIH1cblxuICAvLyBHZXQgbG9hbiBkaXNidXJzZW1lbnRzIChtb25leSB3ZSBsZW50IG91dClcbiAgY29uc3QgeyBkYXRhOiBsb2FucywgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ2xvYW5fZGlzYnVyc2VtZW50JylcbiAgICAuc2VsZWN0KGBcbiAgICAgIGxvYW5fZGlzYnVyc2VtZW50X2lkLFxuICAgICAgYm9ycm93ZXJfbmFtZSxcbiAgICAgIHJlbWFpbmluZ19iYWxhbmNlLFxuICAgICAgZHVlX2RhdGUsXG4gICAgICBzdGF0dXNcbiAgICBgKVxuICAgIC5pbignYWNjb3VudF9pZCcsIGFjY291bnRJZHMpXG4gICAgLmVxKCdzdGF0dXMnLCAnYWN0aXZlJylcblxuICBpZiAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyByZWNlaXZhYmxlczonLCBlcnJvcilcbiAgICByZXR1cm4geyB0b3RhbDogMCwgb3ZlcmR1ZV90b3RhbDogMCwgbG9hbnM6IFtdIH1cbiAgfVxuXG4gIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKVxuICBjb25zdCByZWNlaXZhYmxlTG9hbnM6IFJlY2VpdmFibGVMb2FuW10gPSAobG9hbnMgfHwgW10pLm1hcCgobG9hbjogYW55KSA9PiB7XG4gICAgY29uc3QgZHVlRGF0ZSA9IGxvYW4uZHVlX2RhdGUgPyBuZXcgRGF0ZShsb2FuLmR1ZV9kYXRlKSA6IG51bGxcbiAgICBjb25zdCBpc092ZXJkdWUgPSBkdWVEYXRlID8gZHVlRGF0ZSA8IHRvZGF5IDogZmFsc2VcbiAgICBjb25zdCBkYXlzT3ZlcmR1ZSA9IGlzT3ZlcmR1ZSAmJiBkdWVEYXRlIFxuICAgICAgPyBNYXRoLmZsb29yKCh0b2RheS5nZXRUaW1lKCkgLSBkdWVEYXRlLmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpXG4gICAgICA6IDBcblxuICAgIHJldHVybiB7XG4gICAgICBsb2FuX2Rpc2J1cnNlbWVudF9pZDogbG9hbi5sb2FuX2Rpc2J1cnNlbWVudF9pZCxcbiAgICAgIGJvcnJvd2VyX25hbWU6IGxvYW4uYm9ycm93ZXJfbmFtZSxcbiAgICAgIHJlbWFpbmluZ19iYWxhbmNlOiBsb2FuLnJlbWFpbmluZ19iYWxhbmNlIHx8IDAsXG4gICAgICBkdWVfZGF0ZTogbG9hbi5kdWVfZGF0ZSxcbiAgICAgIGlzX292ZXJkdWU6IGlzT3ZlcmR1ZSxcbiAgICAgIGRheXNfb3ZlcmR1ZTogZGF5c092ZXJkdWVcbiAgICB9XG4gIH0pXG5cbiAgY29uc3QgdG90YWwgPSByZWNlaXZhYmxlTG9hbnMucmVkdWNlKChzdW0sIGwpID0+IHN1bSArIGwucmVtYWluaW5nX2JhbGFuY2UsIDApXG4gIGNvbnN0IG92ZXJkdWVUb3RhbCA9IHJlY2VpdmFibGVMb2Fuc1xuICAgIC5maWx0ZXIobCA9PiBsLmlzX292ZXJkdWUpXG4gICAgLnJlZHVjZSgoc3VtLCBsKSA9PiBzdW0gKyBsLnJlbWFpbmluZ19iYWxhbmNlLCAwKVxuXG4gIHJldHVybiB7IFxuICAgIHRvdGFsLCBcbiAgICBvdmVyZHVlX3RvdGFsOiBvdmVyZHVlVG90YWwsXG4gICAgbG9hbnM6IHJlY2VpdmFibGVMb2FucyBcbiAgfVxufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBjb21wbGV0ZSBsaXF1aWRpdHkgcG9zaXRpb25cbiAqIFxuICogQHBhcmFtIGVudGl0eUlkIC0gVGhlIGVudGl0eSB0byBhbmFseXplXG4gKiBAcmV0dXJucyBDb21wbGV0ZSBsaXF1aWRpdHkgYW5hbHlzaXNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFuYWx5emVMaXF1aWRpdHlQb3NpdGlvbihcbiAgZW50aXR5SWQ6IHN0cmluZ1xuKTogUHJvbWlzZTxMaXF1aWRpdHlQb3NpdGlvbj4ge1xuICAvLyBHZXQgYWNjb3VudCBiYWxhbmNlcyBieSB0eXBlXG4gIGNvbnN0IHtcbiAgICBjYXNoOiBjYXNoQWNjb3VudHMsXG4gICAgaW52ZXN0bWVudHM6IGludmVzdG1lbnRBY2NvdW50cyxcbiAgICB0b3RhbF9jYXNoLFxuICAgIHRvdGFsX2ludmVzdG1lbnRzXG4gIH0gPSBhd2FpdCBnZXRBY2NvdW50QmFsYW5jZXNCeVR5cGUoZW50aXR5SWQpXG4gIFxuICAvLyBHZXQgcmVjZWl2YWJsZXNcbiAgY29uc3QgeyB0b3RhbDogdG90YWxSZWNlaXZhYmxlcywgb3ZlcmR1ZV90b3RhbCwgbG9hbnMgfSA9IGF3YWl0IGFuYWx5emVSZWNlaXZhYmxlcyhlbnRpdHlJZClcblxuICBjb25zdCB0b3RhbExpcXVpZEFzc2V0cyA9IHRvdGFsX2Nhc2ggKyB0b3RhbF9pbnZlc3RtZW50cyArIHRvdGFsUmVjZWl2YWJsZXNcbiAgY29uc3Qgb3ZlcmR1ZUNvdW50ID0gbG9hbnMuZmlsdGVyKGwgPT4gbC5pc19vdmVyZHVlKS5sZW5ndGhcblxuICByZXR1cm4ge1xuICAgIGNhc2hfYmFsYW5jZTogdG90YWxfY2FzaCxcbiAgICBjYXNoX2FjY291bnRzOiBjYXNoQWNjb3VudHMsXG4gICAgaW52ZXN0bWVudF9iYWxhbmNlOiB0b3RhbF9pbnZlc3RtZW50cyxcbiAgICBpbnZlc3RtZW50X2FjY291bnRzOiBpbnZlc3RtZW50QWNjb3VudHMsXG4gICAgcmVjZWl2YWJsZXNfYmFsYW5jZTogdG90YWxSZWNlaXZhYmxlcyxcbiAgICByZWNlaXZhYmxlczogbG9hbnMsXG4gICAgb3ZlcmR1ZV9yZWNlaXZhYmxlczogb3ZlcmR1ZV90b3RhbCxcbiAgICBvdmVyZHVlX2NvdW50OiBvdmVyZHVlQ291bnQsXG4gICAgdG90YWxfbGlxdWlkX2Fzc2V0czogdG90YWxMaXF1aWRBc3NldHNcbiAgfVxufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBydW53YXkgYW5hbHlzaXNcbiAqIFxuICogQHBhcmFtIGxpcXVpZGl0eSAtIExpcXVpZGl0eSBwb3NpdGlvblxuICogQHBhcmFtIG1vbnRobHlCdXJuUmF0ZSAtIEF2ZXJhZ2UgbW9udGhseSBleHBlbnNlc1xuICogQHBhcmFtIG1vbnRobHlJbmNvbWUgLSBBdmVyYWdlIG1vbnRobHkgaW5jb21lXG4gKiBAcGFyYW0gbW9udGhzQWhlYWQgLSBOdW1iZXIgb2YgbW9udGhzIHRvIHByb2plY3RcbiAqIEByZXR1cm5zIFJ1bndheSBhbmFseXNpcyB3aXRoIGRlcGxldGlvbiB3YXJuaW5nc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlUnVud2F5QW5hbHlzaXMoXG4gIGxpcXVpZGl0eTogTGlxdWlkaXR5UG9zaXRpb24sXG4gIG1vbnRobHlCdXJuUmF0ZTogbnVtYmVyLFxuICBtb250aGx5SW5jb21lOiBudW1iZXIsXG4gIG1vbnRoc0FoZWFkOiBudW1iZXIgPSA2XG4pOiBSdW53YXlBbmFseXNpcyB7XG4gIGNvbnN0IG5ldE1vbnRobHlCdXJuID0gbW9udGhseUJ1cm5SYXRlIC0gbW9udGhseUluY29tZVxuXG4gIC8vIElmIGluY29tZSA+IGV4cGVuc2VzLCBpbmZpbml0ZSBydW53YXlcbiAgaWYgKG5ldE1vbnRobHlCdXJuIDw9IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgbW9udGhseV9idXJuX3JhdGU6IG5ldE1vbnRobHlCdXJuLFxuICAgICAgY2FzaF9ydW53YXlfbW9udGhzOiBJbmZpbml0eSxcbiAgICAgIGxpcXVpZGl0eV9ydW53YXlfbW9udGhzOiBJbmZpbml0eSxcbiAgICAgIHF1aWNrX3JhdGlvOiBJbmZpbml0eSxcbiAgICAgIHdpbGxfcnVuX291dF9vZl9jYXNoOiBmYWxzZSxcbiAgICAgIGNhc2hfZGVwbGV0aW9uX21vbnRoOiBudWxsLFxuICAgICAgbGlxdWlkaXR5X2J1ZmZlcjogSW5maW5pdHlcbiAgICB9XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgY2FzaCBydW53YXlcbiAgY29uc3QgY2FzaFJ1bndheSA9IGxpcXVpZGl0eS5jYXNoX2JhbGFuY2UgLyBuZXRNb250aGx5QnVyblxuXG4gIC8vIENhbGN1bGF0ZSB0b3RhbCBsaXF1aWRpdHkgcnVud2F5XG4gIGNvbnN0IGxpcXVpZGl0eVJ1bndheSA9IGxpcXVpZGl0eS50b3RhbF9saXF1aWRfYXNzZXRzIC8gbmV0TW9udGhseUJ1cm5cblxuICAvLyBRdWljayByYXRpbyAobGlxdWlkIGFzc2V0cyAvIG1vbnRobHkgb2JsaWdhdGlvbnMpXG4gIGNvbnN0IHF1aWNrUmF0aW8gPSBsaXF1aWRpdHkudG90YWxfbGlxdWlkX2Fzc2V0cyAvIG1vbnRobHlCdXJuUmF0ZVxuXG4gIC8vIERldGVybWluZSBjYXNoIGRlcGxldGlvbiBtb250aFxuICBsZXQgY2FzaERlcGxldGlvbk1vbnRoOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICBpZiAoY2FzaFJ1bndheSA8IG1vbnRoc0FoZWFkKSB7XG4gICAgY29uc3QgZGVwbGV0aW9uRGF0ZSA9IG5ldyBEYXRlKClcbiAgICBkZXBsZXRpb25EYXRlLnNldE1vbnRoKGRlcGxldGlvbkRhdGUuZ2V0TW9udGgoKSArIE1hdGguZmxvb3IoY2FzaFJ1bndheSkpXG4gICAgY2FzaERlcGxldGlvbk1vbnRoID0gZm9ybWF0KGRlcGxldGlvbkRhdGUsICd5eXl5LU1NJylcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbW9udGhseV9idXJuX3JhdGU6IG5ldE1vbnRobHlCdXJuLFxuICAgIGNhc2hfcnVud2F5X21vbnRoczogY2FzaFJ1bndheSxcbiAgICBsaXF1aWRpdHlfcnVud2F5X21vbnRoczogbGlxdWlkaXR5UnVud2F5LFxuICAgIHF1aWNrX3JhdGlvOiBxdWlja1JhdGlvLFxuICAgIHdpbGxfcnVuX291dF9vZl9jYXNoOiBjYXNoUnVud2F5IDwgbW9udGhzQWhlYWQsXG4gICAgY2FzaF9kZXBsZXRpb25fbW9udGg6IGNhc2hEZXBsZXRpb25Nb250aCxcbiAgICBsaXF1aWRpdHlfYnVmZmVyOiBsaXF1aWRpdHlSdW53YXkgLSBjYXNoUnVud2F5XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVTdXBhYmFzZVNlcnZlckNsaWVudCIsInN0YXJ0T2ZNb250aCIsImVuZE9mTW9udGgiLCJzdWJNb250aHMiLCJmb3JtYXQiLCJwYXJzZUlTTyIsImFuYWx5emVIaXN0b3JpY2FsSW5jb21lIiwiZW50aXR5SWQiLCJtb250aHNCYWNrIiwic3VwYWJhc2UiLCJzdGFydERhdGUiLCJEYXRlIiwiZW5kRGF0ZSIsIlBBR0VfU0laRSIsImFsbFRyYW5zYWN0aW9ucyIsIm9mZnNldCIsImhhc01vcmUiLCJkYXRhIiwicGFnZURhdGEiLCJlcnJvciIsInBhZ2VFcnJvciIsImZyb20iLCJzZWxlY3QiLCJlcSIsImd0ZSIsImx0ZSIsIm5vdCIsIm9yZGVyIiwiYXNjZW5kaW5nIiwicmFuZ2UiLCJjb25zb2xlIiwibGVuZ3RoIiwiY29uY2F0Iiwid2FybiIsInRyYW5zYWN0aW9ucyIsImxvZyIsImluY29tZVRyYW5zYWN0aW9ucyIsImNhdGVnb3J5TWFwIiwiTWFwIiwiZm9yRWFjaCIsInR4IiwiY2F0ZWdvcnlJZCIsImNhdGVnb3J5X2lkIiwiY2F0ZWdvcnlOYW1lIiwiY2F0ZWdvcnlfbmFtZSIsImFtb3VudCIsIm1vbnRoIiwidHJhbnNhY3Rpb25fZGF0ZSIsImhhcyIsInNldCIsImFtb3VudHMiLCJtb250aHMiLCJTZXQiLCJlbnRyeSIsImdldCIsInB1c2giLCJhZGQiLCJwcmVkaWN0aW9ucyIsIkFycmF5IiwidmFsdWVzIiwibWFwIiwiY2F0ZWdvcnkiLCJtb250aHNPZkRhdGEiLCJzaXplIiwidG90YWxBbW91bnQiLCJyZWR1Y2UiLCJzdW0iLCJhbXQiLCJtb250aGx5QXZlcmFnZSIsIk1hdGgiLCJtYXgiLCJtZWFuIiwidmFyaWFuY2UiLCJwb3ciLCJzdGREZXYiLCJzcXJ0IiwidmFyaWFuY2VQZXJjZW50YWdlIiwiYXBwZWFyYW5jZVJhdGUiLCJpc1JlY3VycmluZyIsImNvbmZpZGVuY2UiLCJzb3VyY2UiLCJtb250aGx5X2F2ZXJhZ2UiLCJtb250aHNfb2ZfZGF0YSIsImlzX3JlY3VycmluZyIsImZpbHRlciIsInAiLCJnZXRDYXRlZ29yaWVzV2l0aFNjaGVkdWxlZFBheW1lbnRzIiwibW9udGhLZXkiLCJtb250aFN0YXJ0IiwibW9udGhFbmQiLCJzY2hlZHVsZWRQYXltZW50cyIsImluIiwiY2F0ZWdvcnlJZHMiLCJzcCIsInNjaGVkdWxlZF9wYXltZW50cyIsImdldFNjaGVkdWxlZEFtb3VudHNCeUNhdGVnb3J5IiwiaW5zdGFuY2VzIiwiY2F0ZWdvcnlBbW91bnRzIiwiaW5zdCIsImN1cnJlbnRUb3RhbCIsImFuYWx5emVIaXN0b3JpY2FsRXhwZW5zZXMiLCJzY2hlZHVsZWRDYXRlZ29yaWVzIiwiZXhwZW5zZVRyYW5zYWN0aW9ucyIsInZhcmlhbmNlX3BlcmNlbnRhZ2UiLCJoYXNfc2NoZWR1bGVkX3BheW1lbnQiLCJjYWxjdWxhdGVQcmVkaWN0ZWRJbmNvbWUiLCJpbmNvbWVEYXRhIiwiYnJlYWtkb3duIiwiaW5jb21lIiwidG90YWwiLCJjYWxjdWxhdGVQcmVkaWN0ZWRFeHBlbnNlcyIsImV4cGVuc2VEYXRhIiwic2NoZWR1bGVkQW1vdW50cyIsImV4cGVuc2UiLCJzY2hlZHVsZWRBbW91bnQiLCJoaXN0b3JpY2FsQXZlcmFnZSIsImhpc3RvcmljYWxfYXZlcmFnZSIsImhhc19nYXAiLCJnYXBBbW91bnQiLCJzY2hlZHVsZWRfYW1vdW50IiwiY29tcGFyZUJ1ZGdldHMiLCJwcmVkaWN0ZWRFeHBlbnNlcyIsImJ1ZGdldHMiLCJ3YXJuaW5ncyIsImJ1ZGdldE1hcCIsImJ1ZGdldCIsImJ1ZGdldF9hbW91bnQiLCJidWRnZXRBbW91bnQiLCJwcm9qZWN0ZWQiLCJnZXRBY2NvdW50QmFsYW5jZXNCeVR5cGUiLCJhY2NvdW50cyIsImFjY291bnRzRXJyb3IiLCJjYXNoIiwiaW52ZXN0bWVudHMiLCJ0b3RhbF9jYXNoIiwidG90YWxfaW52ZXN0bWVudHMiLCJhIiwiYWNjb3VudF9uYW1lIiwiYWNjb3VudF90eXBlIiwiam9pbiIsImFjY291bnRJZHMiLCJhY2NvdW50X2lkIiwidG9kYXkiLCJ0b0lTT1N0cmluZyIsInNwbGl0IiwiYWNjb3VudHNXaXRoQmFsYW5jZXMiLCJhY2MiLCJiYWxhbmNlIiwiYmFsYW5jZUVycm9yIiwicnBjIiwicF9hY2NvdW50X2lkIiwicF91cF90b19kYXRlIiwiSlNPTiIsInN0cmluZ2lmeSIsImN1cnJlbnRfYmFsYW5jZSIsImNhc2hBY2NvdW50cyIsImludmVzdG1lbnRBY2NvdW50cyIsInRvdGFsQ2FzaCIsInRvdGFsSW52ZXN0bWVudHMiLCJhbmFseXplUmVjZWl2YWJsZXMiLCJvdmVyZHVlX3RvdGFsIiwibG9hbnMiLCJyZWNlaXZhYmxlTG9hbnMiLCJsb2FuIiwiZHVlRGF0ZSIsImR1ZV9kYXRlIiwiaXNPdmVyZHVlIiwiZGF5c092ZXJkdWUiLCJmbG9vciIsImdldFRpbWUiLCJsb2FuX2Rpc2J1cnNlbWVudF9pZCIsImJvcnJvd2VyX25hbWUiLCJyZW1haW5pbmdfYmFsYW5jZSIsImlzX292ZXJkdWUiLCJkYXlzX292ZXJkdWUiLCJsIiwib3ZlcmR1ZVRvdGFsIiwiYW5hbHl6ZUxpcXVpZGl0eVBvc2l0aW9uIiwidG90YWxSZWNlaXZhYmxlcyIsInRvdGFsTGlxdWlkQXNzZXRzIiwib3ZlcmR1ZUNvdW50IiwiY2FzaF9iYWxhbmNlIiwiY2FzaF9hY2NvdW50cyIsImludmVzdG1lbnRfYmFsYW5jZSIsImludmVzdG1lbnRfYWNjb3VudHMiLCJyZWNlaXZhYmxlc19iYWxhbmNlIiwicmVjZWl2YWJsZXMiLCJvdmVyZHVlX3JlY2VpdmFibGVzIiwib3ZlcmR1ZV9jb3VudCIsInRvdGFsX2xpcXVpZF9hc3NldHMiLCJjYWxjdWxhdGVSdW53YXlBbmFseXNpcyIsImxpcXVpZGl0eSIsIm1vbnRobHlCdXJuUmF0ZSIsIm1vbnRobHlJbmNvbWUiLCJtb250aHNBaGVhZCIsIm5ldE1vbnRobHlCdXJuIiwibW9udGhseV9idXJuX3JhdGUiLCJjYXNoX3J1bndheV9tb250aHMiLCJJbmZpbml0eSIsImxpcXVpZGl0eV9ydW53YXlfbW9udGhzIiwicXVpY2tfcmF0aW8iLCJ3aWxsX3J1bl9vdXRfb2ZfY2FzaCIsImNhc2hfZGVwbGV0aW9uX21vbnRoIiwibGlxdWlkaXR5X2J1ZmZlciIsImNhc2hSdW53YXkiLCJsaXF1aWRpdHlSdW53YXkiLCJxdWlja1JhdGlvIiwiY2FzaERlcGxldGlvbk1vbnRoIiwiZGVwbGV0aW9uRGF0ZSIsInNldE1vbnRoIiwiZ2V0TW9udGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/cash-flow-analyzer.ts\n");

/***/ }),

/***/ "(rsc)/./lib/supabase-server.ts":
/*!********************************!*\
  !*** ./lib/supabase-server.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSupabaseServerClient: () => (/* binding */ createSupabaseServerClient),\n/* harmony export */   getCurrentUser: () => (/* binding */ getCurrentUser),\n/* harmony export */   requireAuth: () => (/* binding */ requireAuth)\n/* harmony export */ });\n/* harmony import */ var _supabase_ssr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/ssr */ \"(rsc)/../../node_modules/@supabase/ssr/dist/module/index.js\");\n/* harmony import */ var next_headers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/headers */ \"(rsc)/../../node_modules/next/dist/api/headers.js\");\n\n\nfunction createSupabaseServerClient() {\n    const cookieStore = (0,next_headers__WEBPACK_IMPORTED_MODULE_1__.cookies)();\n    return (0,_supabase_ssr__WEBPACK_IMPORTED_MODULE_0__.createServerClient)(\"https://mflyrbzriksgjutlalkf.supabase.co\", \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1mbHlyYnpyaWtzZ2p1dGxhbGtmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjIyMjQ3MjcsImV4cCI6MjA3NzgwMDcyN30.O9hwKR6Vxb_vJhPrYedwQWkTCvfApcvBfnasSLt1vyY\", {\n        cookies: {\n            get (name) {\n                return cookieStore.get(name)?.value;\n            },\n            set (name, value, options) {\n                try {\n                    cookieStore.set({\n                        name,\n                        value,\n                        ...options\n                    });\n                } catch (error) {\n                // The `set` method was called from a Server Component.\n                // This can be ignored if you have middleware refreshing\n                // user sessions.\n                }\n            },\n            remove (name, options) {\n                try {\n                    cookieStore.set({\n                        name,\n                        value: \"\",\n                        ...options\n                    });\n                } catch (error) {\n                // The `delete` method was called from a Server Component.\n                // This can be ignored if you have middleware refreshing\n                // user sessions.\n                }\n            }\n        }\n    });\n}\n// Helper function to get the current user from server components\nasync function getCurrentUser() {\n    const supabase = createSupabaseServerClient();\n    const { data: { user }, error } = await supabase.auth.getUser();\n    if (error || !user) {\n        return null;\n    }\n    return user;\n}\n// Helper function to check if user is authenticated\nasync function requireAuth() {\n    const user = await getCurrentUser();\n    if (!user) {\n        throw new Error(\"Unauthorized\");\n    }\n    return user;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvc3VwYWJhc2Utc2VydmVyLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXNFO0FBQ2hDO0FBRS9CLFNBQVNFO0lBQ2QsTUFBTUMsY0FBY0YscURBQU9BO0lBRTNCLE9BQU9ELGlFQUFrQkEsQ0FDdkJJLDBDQUFvQyxFQUNwQ0Esa05BQXlDLEVBQ3pDO1FBQ0VILFNBQVM7WUFDUE8sS0FBSUMsSUFBWTtnQkFDZCxPQUFPTixZQUFZSyxHQUFHLENBQUNDLE9BQU9DO1lBQ2hDO1lBQ0FDLEtBQUlGLElBQVksRUFBRUMsS0FBYSxFQUFFRSxPQUFzQjtnQkFDckQsSUFBSTtvQkFDRlQsWUFBWVEsR0FBRyxDQUFDO3dCQUFFRjt3QkFBTUM7d0JBQU8sR0FBR0UsT0FBTztvQkFBQztnQkFDNUMsRUFBRSxPQUFPQyxPQUFPO2dCQUNkLHVEQUF1RDtnQkFDdkQsd0RBQXdEO2dCQUN4RCxpQkFBaUI7Z0JBQ25CO1lBQ0Y7WUFDQUMsUUFBT0wsSUFBWSxFQUFFRyxPQUFzQjtnQkFDekMsSUFBSTtvQkFDRlQsWUFBWVEsR0FBRyxDQUFDO3dCQUFFRjt3QkFBTUMsT0FBTzt3QkFBSSxHQUFHRSxPQUFPO29CQUFDO2dCQUNoRCxFQUFFLE9BQU9DLE9BQU87Z0JBQ2QsMERBQTBEO2dCQUMxRCx3REFBd0Q7Z0JBQ3hELGlCQUFpQjtnQkFDbkI7WUFDRjtRQUNGO0lBQ0Y7QUFFSjtBQUVBLGlFQUFpRTtBQUMxRCxlQUFlRTtJQUNwQixNQUFNQyxXQUFXZDtJQUNqQixNQUFNLEVBQUVlLE1BQU0sRUFBRUMsSUFBSSxFQUFFLEVBQUVMLEtBQUssRUFBRSxHQUFHLE1BQU1HLFNBQVNHLElBQUksQ0FBQ0MsT0FBTztJQUU3RCxJQUFJUCxTQUFTLENBQUNLLE1BQU07UUFDbEIsT0FBTztJQUNUO0lBRUEsT0FBT0E7QUFDVDtBQUVBLG9EQUFvRDtBQUM3QyxlQUFlRztJQUNwQixNQUFNSCxPQUFPLE1BQU1IO0lBRW5CLElBQUksQ0FBQ0csTUFBTTtRQUNULE1BQU0sSUFBSUksTUFBTTtJQUNsQjtJQUVBLE9BQU9KO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZmluYW5jZWFwcC93ZWIvLi9saWIvc3VwYWJhc2Utc2VydmVyLnRzPzA5NGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlU2VydmVyQ2xpZW50LCB0eXBlIENvb2tpZU9wdGlvbnMgfSBmcm9tICdAc3VwYWJhc2Uvc3NyJ1xuaW1wb3J0IHsgY29va2llcyB9IGZyb20gJ25leHQvaGVhZGVycydcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN1cGFiYXNlU2VydmVyQ2xpZW50KCkge1xuICBjb25zdCBjb29raWVTdG9yZSA9IGNvb2tpZXMoKVxuXG4gIHJldHVybiBjcmVhdGVTZXJ2ZXJDbGllbnQoXG4gICAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMISxcbiAgICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSEsXG4gICAge1xuICAgICAgY29va2llczoge1xuICAgICAgICBnZXQobmFtZTogc3RyaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIGNvb2tpZVN0b3JlLmdldChuYW1lKT8udmFsdWVcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZywgb3B0aW9uczogQ29va2llT3B0aW9ucykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb29raWVTdG9yZS5zZXQoeyBuYW1lLCB2YWx1ZSwgLi4ub3B0aW9ucyB9KVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBUaGUgYHNldGAgbWV0aG9kIHdhcyBjYWxsZWQgZnJvbSBhIFNlcnZlciBDb21wb25lbnQuXG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBiZSBpZ25vcmVkIGlmIHlvdSBoYXZlIG1pZGRsZXdhcmUgcmVmcmVzaGluZ1xuICAgICAgICAgICAgLy8gdXNlciBzZXNzaW9ucy5cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZShuYW1lOiBzdHJpbmcsIG9wdGlvbnM6IENvb2tpZU9wdGlvbnMpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29va2llU3RvcmUuc2V0KHsgbmFtZSwgdmFsdWU6ICcnLCAuLi5vcHRpb25zIH0pXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFRoZSBgZGVsZXRlYCBtZXRob2Qgd2FzIGNhbGxlZCBmcm9tIGEgU2VydmVyIENvbXBvbmVudC5cbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIGJlIGlnbm9yZWQgaWYgeW91IGhhdmUgbWlkZGxld2FyZSByZWZyZXNoaW5nXG4gICAgICAgICAgICAvLyB1c2VyIHNlc3Npb25zLlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfVxuICApXG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGN1cnJlbnQgdXNlciBmcm9tIHNlcnZlciBjb21wb25lbnRzXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3VycmVudFVzZXIoKSB7XG4gIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlU3VwYWJhc2VTZXJ2ZXJDbGllbnQoKVxuICBjb25zdCB7IGRhdGE6IHsgdXNlciB9LCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKClcblxuICBpZiAoZXJyb3IgfHwgIXVzZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIHVzZXJcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNoZWNrIGlmIHVzZXIgaXMgYXV0aGVudGljYXRlZFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlcXVpcmVBdXRoKCkge1xuICBjb25zdCB1c2VyID0gYXdhaXQgZ2V0Q3VycmVudFVzZXIoKVxuXG4gIGlmICghdXNlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5hdXRob3JpemVkJylcbiAgfVxuXG4gIHJldHVybiB1c2VyXG59XG4iXSwibmFtZXMiOlsiY3JlYXRlU2VydmVyQ2xpZW50IiwiY29va2llcyIsImNyZWF0ZVN1cGFiYXNlU2VydmVyQ2xpZW50IiwiY29va2llU3RvcmUiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJnZXQiLCJuYW1lIiwidmFsdWUiLCJzZXQiLCJvcHRpb25zIiwiZXJyb3IiLCJyZW1vdmUiLCJnZXRDdXJyZW50VXNlciIsInN1cGFiYXNlIiwiZGF0YSIsInVzZXIiLCJhdXRoIiwiZ2V0VXNlciIsInJlcXVpcmVBdXRoIiwiRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/supabase-server.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/@supabase","vendor-chunks/next","vendor-chunks/tslib","vendor-chunks/iceberg-js","vendor-chunks/cookie","vendor-chunks/date-fns"], () => (__webpack_exec__("(rsc)/../../node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fcash-flow-projection%2Froute&page=%2Fapi%2Fcash-flow-projection%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fcash-flow-projection%2Froute.ts&appDir=%2FUsers%2Ftrunghuynh%2FDeveloper%2FFinanceapp%2Fapps%2Fweb%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Ftrunghuynh%2FDeveloper%2FFinanceapp%2Fapps%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();