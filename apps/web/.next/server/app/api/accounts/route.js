"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/accounts/route";
exports.ids = ["app/api/accounts/route"];
exports.modules = {

/***/ "../../client/components/action-async-storage.external":
/*!*******************************************************************************!*\
  !*** external "next/dist/client/components/action-async-storage.external.js" ***!
  \*******************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/client/components/action-async-storage.external.js");

/***/ }),

/***/ "../../client/components/request-async-storage.external":
/*!********************************************************************************!*\
  !*** external "next/dist/client/components/request-async-storage.external.js" ***!
  \********************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/client/components/request-async-storage.external.js");

/***/ }),

/***/ "../../client/components/static-generation-async-storage.external":
/*!******************************************************************************************!*\
  !*** external "next/dist/client/components/static-generation-async-storage.external.js" ***!
  \******************************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/client/components/static-generation-async-storage.external.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "(rsc)/../../node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Faccounts%2Froute&page=%2Fapi%2Faccounts%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Faccounts%2Froute.ts&appDir=%2FUsers%2Ftrunghuynh%2FDeveloper%2FFinanceapp%2Fapps%2Fweb%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Ftrunghuynh%2FDeveloper%2FFinanceapp%2Fapps%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Faccounts%2Froute&page=%2Fapi%2Faccounts%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Faccounts%2Froute.ts&appDir=%2FUsers%2Ftrunghuynh%2FDeveloper%2FFinanceapp%2Fapps%2Fweb%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Ftrunghuynh%2FDeveloper%2FFinanceapp%2Fapps%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/../../node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/../../node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/../../node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Users_trunghuynh_Developer_Financeapp_apps_web_app_api_accounts_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/accounts/route.ts */ \"(rsc)/./app/api/accounts/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/accounts/route\",\n        pathname: \"/api/accounts\",\n        filename: \"route\",\n        bundlePath: \"app/api/accounts/route\"\n    },\n    resolvedPagePath: \"/Users/trunghuynh/Developer/Financeapp/apps/web/app/api/accounts/route.ts\",\n    nextConfigOutput,\n    userland: _Users_trunghuynh_Developer_Financeapp_apps_web_app_api_accounts_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/accounts/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1hcHAtbG9hZGVyLmpzP25hbWU9YXBwJTJGYXBpJTJGYWNjb3VudHMlMkZyb3V0ZSZwYWdlPSUyRmFwaSUyRmFjY291bnRzJTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGYWNjb3VudHMlMkZyb3V0ZS50cyZhcHBEaXI9JTJGVXNlcnMlMkZ0cnVuZ2h1eW5oJTJGRGV2ZWxvcGVyJTJGRmluYW5jZWFwcCUyRmFwcHMlMkZ3ZWIlMkZhcHAmcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyZyb290RGlyPSUyRlVzZXJzJTJGdHJ1bmdodXluaCUyRkRldmVsb3BlciUyRkZpbmFuY2VhcHAlMkZhcHBzJTJGd2ViJmlzRGV2PXRydWUmdHNjb25maWdQYXRoPXRzY29uZmlnLmpzb24mYmFzZVBhdGg9JmFzc2V0UHJlZml4PSZuZXh0Q29uZmlnT3V0cHV0PSZwcmVmZXJyZWRSZWdpb249Jm1pZGRsZXdhcmVDb25maWc9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBc0c7QUFDdkM7QUFDYztBQUN5QjtBQUN0RztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0hBQW1CO0FBQzNDO0FBQ0EsY0FBYyx5RUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWTtBQUNaLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFpRTtBQUN6RTtBQUNBO0FBQ0EsV0FBVyw0RUFBVztBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ3VIOztBQUV2SCIsInNvdXJjZXMiOlsid2VicGFjazovL0BmaW5hbmNlYXBwL3dlYi8/ZGMyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcHBSb3V0ZVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvYXBwLXJvdXRlL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IHBhdGNoRmV0Y2ggYXMgX3BhdGNoRmV0Y2ggfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvcGF0Y2gtZmV0Y2hcIjtcbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCIvVXNlcnMvdHJ1bmdodXluaC9EZXZlbG9wZXIvRmluYW5jZWFwcC9hcHBzL3dlYi9hcHAvYXBpL2FjY291bnRzL3JvdXRlLnRzXCI7XG4vLyBXZSBpbmplY3QgdGhlIG5leHRDb25maWdPdXRwdXQgaGVyZSBzbyB0aGF0IHdlIGNhbiB1c2UgdGhlbSBpbiB0aGUgcm91dGVcbi8vIG1vZHVsZS5cbmNvbnN0IG5leHRDb25maWdPdXRwdXQgPSBcIlwiXG5jb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBBcHBSb3V0ZVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9hY2NvdW50cy9yb3V0ZVwiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL2FjY291bnRzXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS9hY2NvdW50cy9yb3V0ZVwiXG4gICAgfSxcbiAgICByZXNvbHZlZFBhZ2VQYXRoOiBcIi9Vc2Vycy90cnVuZ2h1eW5oL0RldmVsb3Blci9GaW5hbmNlYXBwL2FwcHMvd2ViL2FwcC9hcGkvYWNjb3VudHMvcm91dGUudHNcIixcbiAgICBuZXh0Q29uZmlnT3V0cHV0LFxuICAgIHVzZXJsYW5kXG59KTtcbi8vIFB1bGwgb3V0IHRoZSBleHBvcnRzIHRoYXQgd2UgbmVlZCB0byBleHBvc2UgZnJvbSB0aGUgbW9kdWxlLiBUaGlzIHNob3VsZFxuLy8gYmUgZWxpbWluYXRlZCB3aGVuIHdlJ3ZlIG1vdmVkIHRoZSBvdGhlciByb3V0ZXMgdG8gdGhlIG5ldyBmb3JtYXQuIFRoZXNlXG4vLyBhcmUgdXNlZCB0byBob29rIGludG8gdGhlIHJvdXRlLlxuY29uc3QgeyByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcyB9ID0gcm91dGVNb2R1bGU7XG5jb25zdCBvcmlnaW5hbFBhdGhuYW1lID0gXCIvYXBpL2FjY291bnRzL3JvdXRlXCI7XG5mdW5jdGlvbiBwYXRjaEZldGNoKCkge1xuICAgIHJldHVybiBfcGF0Y2hGZXRjaCh7XG4gICAgICAgIHNlcnZlckhvb2tzLFxuICAgICAgICBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlXG4gICAgfSk7XG59XG5leHBvcnQgeyByb3V0ZU1vZHVsZSwgcmVxdWVzdEFzeW5jU3RvcmFnZSwgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MsIG9yaWdpbmFsUGF0aG5hbWUsIHBhdGNoRmV0Y2gsICB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtcm91dGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Faccounts%2Froute&page=%2Fapi%2Faccounts%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Faccounts%2Froute.ts&appDir=%2FUsers%2Ftrunghuynh%2FDeveloper%2FFinanceapp%2Fapps%2Fweb%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Ftrunghuynh%2FDeveloper%2FFinanceapp%2Fapps%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./app/api/accounts/route.ts":
/*!***********************************!*\
  !*** ./app/api/accounts/route.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/../../node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_supabase_server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/supabase-server */ \"(rsc)/./lib/supabase-server.ts\");\n/* harmony import */ var _lib_checkpoint_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/checkpoint-service */ \"(rsc)/./lib/checkpoint-service.ts\");\n\n\n\n// GET /api/accounts - List all accounts with filters and calculated balances\nasync function GET(request) {\n    try {\n        const supabase = (0,_lib_supabase_server__WEBPACK_IMPORTED_MODULE_1__.createSupabaseServerClient)();\n        const searchParams = request.nextUrl.searchParams;\n        const entityId = searchParams.get(\"entity_id\");\n        const accountTypes = searchParams.get(\"account_type\")?.split(\",\");\n        const isActive = searchParams.get(\"is_active\");\n        const search = searchParams.get(\"search\");\n        const page = parseInt(searchParams.get(\"page\") || \"1\");\n        const limit = parseInt(searchParams.get(\"limit\") || \"20\");\n        // Start building query - fetch accounts with entities (NO balance join)\n        let query = supabase.from(\"accounts\").select(`\n        *,\n        entity:entities(id, name, type)\n      `);\n        // Apply filters\n        if (entityId) {\n            query = query.eq(\"entity_id\", entityId);\n        }\n        if (accountTypes && accountTypes.length > 0) {\n            query = query.in(\"account_type\", accountTypes);\n        }\n        if (isActive !== null && isActive !== undefined) {\n            query = query.eq(\"is_active\", isActive === \"true\");\n        }\n        if (search) {\n            query = query.or(`account_name.ilike.%${search}%,bank_name.ilike.%${search}%`);\n        }\n        // Apply pagination\n        const from = (page - 1) * limit;\n        const to = from + limit - 1;\n        // Execute query with pagination\n        const { data: accounts, error, count } = await query.order(\"created_at\", {\n            ascending: false\n        }).range(from, to);\n        if (error) {\n            console.error(\"Error fetching accounts:\", error);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: error.message\n            }, {\n                status: 500\n            });\n        }\n        // Calculate balance for each account from ALL transactions\n        const accountsWithBalances = await Promise.all((accounts || []).map(async (account)=>{\n            // Calculate balance from ALL transactions INCLUDING adjustments\n            let totalCredits = 0;\n            let totalDebits = 0;\n            // Try using RPC function first (if migration was run)\n            const { data: rpcData, error: rpcError } = await supabase.rpc(\"calculate_account_balance\", {\n                p_account_id: account.account_id\n            });\n            if (!rpcError && rpcData !== null) {\n                // RPC function exists and worked\n                const calculatedBalance = rpcData;\n                // Fetch unresolved checkpoint count (where is_reconciled = false)\n                const { count: unresolvedCount } = await supabase.from(\"balance_checkpoints\").select(\"*\", {\n                    count: \"exact\",\n                    head: true\n                }).eq(\"account_id\", account.account_id).eq(\"is_reconciled\", false);\n                return {\n                    ...account,\n                    balance: {\n                        current_balance: calculatedBalance,\n                        last_updated: new Date().toISOString()\n                    },\n                    unresolved_checkpoints_count: unresolvedCount || 0\n                };\n            }\n            // Fallback: Fetch all transactions with pagination to avoid 1000 row limit\n            let page = 0;\n            const pageSize = 1000;\n            while(true){\n                const { data: transactions, error: txError } = await supabase.from(\"original_transaction\").select(\"credit_amount, debit_amount\").eq(\"account_id\", account.account_id).range(page * pageSize, (page + 1) * pageSize - 1);\n                if (txError) {\n                    console.error(`Error fetching transactions for account ${account.account_id}:`, txError);\n                    // Return account with 0 balance if transaction fetch fails\n                    return {\n                        ...account,\n                        balance: {\n                            current_balance: 0,\n                            last_updated: new Date().toISOString()\n                        },\n                        unresolved_checkpoints_count: 0\n                    };\n                }\n                if (!transactions || transactions.length === 0) {\n                    break;\n                }\n                // Sum this page of transactions\n                for (const tx of transactions){\n                    if (tx.credit_amount) {\n                        totalCredits += tx.credit_amount;\n                    }\n                    if (tx.debit_amount) {\n                        totalDebits += tx.debit_amount;\n                    }\n                }\n                if (transactions.length < pageSize) {\n                    break;\n                }\n                page++;\n            }\n            const calculatedBalance = totalCredits - totalDebits;\n            // Fetch unresolved checkpoint count (where is_reconciled = false)\n            const { count: unresolvedCount } = await supabase.from(\"balance_checkpoints\").select(\"*\", {\n                count: \"exact\",\n                head: true\n            }).eq(\"account_id\", account.account_id).eq(\"is_reconciled\", false);\n            // Return account with calculated balance and checkpoint count\n            return {\n                ...account,\n                balance: {\n                    current_balance: calculatedBalance,\n                    last_updated: new Date().toISOString()\n                },\n                unresolved_checkpoints_count: unresolvedCount || 0\n            };\n        }));\n        // Get total count\n        const { count: totalCount } = await supabase.from(\"accounts\").select(\"*\", {\n            count: \"exact\",\n            head: true\n        });\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            data: accountsWithBalances || [],\n            pagination: {\n                page,\n                limit,\n                total: totalCount || 0,\n                totalPages: Math.ceil((totalCount || 0) / limit)\n            }\n        });\n    } catch (error) {\n        console.error(\"Unexpected error:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: \"An unexpected error occurred\"\n        }, {\n            status: 500\n        });\n    }\n}\n// POST /api/accounts - Create new account\nasync function POST(request) {\n    try {\n        const supabase = (0,_lib_supabase_server__WEBPACK_IMPORTED_MODULE_1__.createSupabaseServerClient)();\n        const body = await request.json();\n        // Validate required fields\n        if (!body.entity_id || !body.account_name || !body.account_type) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Missing required fields: entity_id, account_name, account_type\"\n            }, {\n                status: 400\n            });\n        }\n        // Check for duplicate account (same name + type + entity)\n        const { data: existingAccounts } = await supabase.from(\"accounts\").select(\"account_id\").eq(\"entity_id\", body.entity_id).eq(\"account_name\", body.account_name).eq(\"account_type\", body.account_type);\n        if (existingAccounts && existingAccounts.length > 0) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"An account with this name and type already exists for this entity\"\n            }, {\n                status: 409\n            });\n        }\n        // Create account\n        const { data: newAccount, error: accountError } = await supabase.from(\"accounts\").insert([\n            {\n                entity_id: body.entity_id,\n                account_name: body.account_name,\n                account_type: body.account_type,\n                account_number: body.account_number || null,\n                bank_name: body.bank_name || null,\n                currency: body.currency || \"VND\",\n                credit_limit: body.credit_limit || null,\n                loan_reference: body.loan_reference || null\n            }\n        ]).select().single();\n        if (accountError) {\n            console.error(\"Error creating account:\", accountError);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: accountError.message\n            }, {\n                status: 500\n            });\n        }\n        // Set initial balance if provided\n        let checkpointWarning = null;\n        if (body.initial_balance !== undefined && body.initial_balance !== 0) {\n            // If opening_balance_date is provided, create a checkpoint\n            // This follows the \"No money without origin\" principle\n            if (body.opening_balance_date) {\n                try {\n                    console.log(\"Creating checkpoint with params:\", {\n                        account_id: newAccount.account_id,\n                        checkpoint_date: body.opening_balance_date,\n                        declared_balance: body.initial_balance,\n                        notes: body.opening_balance_notes || \"Opening balance\"\n                    });\n                    const checkpoint = await (0,_lib_checkpoint_service__WEBPACK_IMPORTED_MODULE_2__.createOrUpdateCheckpoint)({\n                        account_id: newAccount.account_id,\n                        checkpoint_date: new Date(body.opening_balance_date),\n                        declared_balance: body.initial_balance,\n                        notes: body.opening_balance_notes || \"Opening balance\"\n                    });\n                    console.log(\"✅ Checkpoint created successfully:\", checkpoint);\n                } catch (checkpointError) {\n                    console.error(\"❌ Error creating opening balance checkpoint:\", checkpointError);\n                    console.error(\"Error details:\", {\n                        message: checkpointError.message,\n                        stack: checkpointError.stack\n                    });\n                    checkpointWarning = `Account created successfully, but checkpoint creation failed: ${checkpointError.message}. Please check server logs.`;\n                }\n            } else {\n                // No opening_balance_date provided - skip initial balance\n                // Account will start with 0 balance\n                console.log(\"No opening_balance_date provided, account starts with 0 balance\");\n            }\n        }\n        // Fetch the complete account with entity\n        const { data: completeAccount } = await supabase.from(\"accounts\").select(`\n        *,\n        entity:entities(id, name, type)\n      `).eq(\"account_id\", newAccount.account_id).single();\n        // Return account with optional warning about checkpoint creation\n        if (checkpointWarning) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                ...completeAccount,\n                warning: checkpointWarning\n            }, {\n                status: 201\n            });\n        }\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(completeAccount, {\n            status: 201\n        });\n    } catch (error) {\n        console.error(\"Unexpected error:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: \"An unexpected error occurred\"\n        }, {\n            status: 500\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZDtRQUNGO1FBRUEseUNBQXlDO1FBQ3pDLE1BQU0sRUFBRTlELE1BQU1zRSxlQUFlLEVBQUUsR0FBRyxNQUFNM0YsU0FDckNhLElBQUksQ0FBQyxZQUNMQyxNQUFNLENBQUMsQ0FBQzs7O01BR1QsQ0FBQyxFQUNBQyxFQUFFLENBQUMsY0FBY3dELFdBQVc1QixVQUFVLEVBQ3RDb0MsTUFBTTtRQUVULGlFQUFpRTtRQUNqRSxJQUFJQyxtQkFBbUI7WUFDckIsT0FBT3JGLHFEQUFZQSxDQUFDa0MsSUFBSSxDQUN0QjtnQkFDRSxHQUFHOEQsZUFBZTtnQkFDbEJDLFNBQVNaO1lBQ1gsR0FDQTtnQkFBRWpELFFBQVE7WUFBSTtRQUVsQjtRQUVBLE9BQU9wQyxxREFBWUEsQ0FBQ2tDLElBQUksQ0FBQzhELGlCQUFpQjtZQUFFNUQsUUFBUTtRQUFJO0lBQzFELEVBQUUsT0FBT1IsT0FBTztRQUNkSyxRQUFRTCxLQUFLLENBQUMscUJBQXFCQTtRQUNuQyxPQUFPNUIscURBQVlBLENBQUNrQyxJQUFJLENBQ3RCO1lBQUVOLE9BQU87UUFBK0IsR0FDeEM7WUFBRVEsUUFBUTtRQUFJO0lBRWxCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZmluYW5jZWFwcC93ZWIvLi9hcHAvYXBpL2FjY291bnRzL3JvdXRlLnRzPzFhMWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dFJlcXVlc3QsIE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJ1xuaW1wb3J0IHsgY3JlYXRlU3VwYWJhc2VTZXJ2ZXJDbGllbnQgfSBmcm9tICdAL2xpYi9zdXBhYmFzZS1zZXJ2ZXInXG5pbXBvcnQgdHlwZSB7IENyZWF0ZUFjY291bnRJbnB1dCB9IGZyb20gJ0AvdHlwZXMvYWNjb3VudCdcbmltcG9ydCB7IGNyZWF0ZU9yVXBkYXRlQ2hlY2twb2ludCB9IGZyb20gJ0AvbGliL2NoZWNrcG9pbnQtc2VydmljZSdcblxuLy8gR0VUIC9hcGkvYWNjb3VudHMgLSBMaXN0IGFsbCBhY2NvdW50cyB3aXRoIGZpbHRlcnMgYW5kIGNhbGN1bGF0ZWQgYmFsYW5jZXNcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBHRVQocmVxdWVzdDogTmV4dFJlcXVlc3QpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZVN1cGFiYXNlU2VydmVyQ2xpZW50KClcblxuICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IHJlcXVlc3QubmV4dFVybC5zZWFyY2hQYXJhbXNcbiAgICBjb25zdCBlbnRpdHlJZCA9IHNlYXJjaFBhcmFtcy5nZXQoJ2VudGl0eV9pZCcpXG4gICAgY29uc3QgYWNjb3VudFR5cGVzID0gc2VhcmNoUGFyYW1zLmdldCgnYWNjb3VudF90eXBlJyk/LnNwbGl0KCcsJylcbiAgICBjb25zdCBpc0FjdGl2ZSA9IHNlYXJjaFBhcmFtcy5nZXQoJ2lzX2FjdGl2ZScpXG4gICAgY29uc3Qgc2VhcmNoID0gc2VhcmNoUGFyYW1zLmdldCgnc2VhcmNoJylcbiAgICBjb25zdCBwYWdlID0gcGFyc2VJbnQoc2VhcmNoUGFyYW1zLmdldCgncGFnZScpIHx8ICcxJylcbiAgICBjb25zdCBsaW1pdCA9IHBhcnNlSW50KHNlYXJjaFBhcmFtcy5nZXQoJ2xpbWl0JykgfHwgJzIwJylcblxuICAgIC8vIFN0YXJ0IGJ1aWxkaW5nIHF1ZXJ5IC0gZmV0Y2ggYWNjb3VudHMgd2l0aCBlbnRpdGllcyAoTk8gYmFsYW5jZSBqb2luKVxuICAgIGxldCBxdWVyeSA9IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnYWNjb3VudHMnKVxuICAgICAgLnNlbGVjdChgXG4gICAgICAgICosXG4gICAgICAgIGVudGl0eTplbnRpdGllcyhpZCwgbmFtZSwgdHlwZSlcbiAgICAgIGApXG5cbiAgICAvLyBBcHBseSBmaWx0ZXJzXG4gICAgaWYgKGVudGl0eUlkKSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdlbnRpdHlfaWQnLCBlbnRpdHlJZClcbiAgICB9XG5cbiAgICBpZiAoYWNjb3VudFR5cGVzICYmIGFjY291bnRUeXBlcy5sZW5ndGggPiAwKSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5LmluKCdhY2NvdW50X3R5cGUnLCBhY2NvdW50VHlwZXMpXG4gICAgfVxuXG4gICAgaWYgKGlzQWN0aXZlICE9PSBudWxsICYmIGlzQWN0aXZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHF1ZXJ5ID0gcXVlcnkuZXEoJ2lzX2FjdGl2ZScsIGlzQWN0aXZlID09PSAndHJ1ZScpXG4gICAgfVxuXG4gICAgaWYgKHNlYXJjaCkge1xuICAgICAgcXVlcnkgPSBxdWVyeS5vcihgYWNjb3VudF9uYW1lLmlsaWtlLiUke3NlYXJjaH0lLGJhbmtfbmFtZS5pbGlrZS4lJHtzZWFyY2h9JWApXG4gICAgfVxuXG4gICAgLy8gQXBwbHkgcGFnaW5hdGlvblxuICAgIGNvbnN0IGZyb20gPSAocGFnZSAtIDEpICogbGltaXRcbiAgICBjb25zdCB0byA9IGZyb20gKyBsaW1pdCAtIDFcblxuICAgIC8vIEV4ZWN1dGUgcXVlcnkgd2l0aCBwYWdpbmF0aW9uXG4gICAgY29uc3QgeyBkYXRhOiBhY2NvdW50cywgZXJyb3IsIGNvdW50IH0gPSBhd2FpdCBxdWVyeVxuICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG4gICAgICAucmFuZ2UoZnJvbSwgdG8pXG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGFjY291bnRzOicsIGVycm9yKVxuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSwgeyBzdGF0dXM6IDUwMCB9KVxuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBiYWxhbmNlIGZvciBlYWNoIGFjY291bnQgZnJvbSBBTEwgdHJhbnNhY3Rpb25zXG4gICAgY29uc3QgYWNjb3VudHNXaXRoQmFsYW5jZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIChhY2NvdW50cyB8fCBbXSkubWFwKGFzeW5jIChhY2NvdW50KSA9PiB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBiYWxhbmNlIGZyb20gQUxMIHRyYW5zYWN0aW9ucyBJTkNMVURJTkcgYWRqdXN0bWVudHNcbiAgICAgICAgbGV0IHRvdGFsQ3JlZGl0cyA9IDBcbiAgICAgICAgbGV0IHRvdGFsRGViaXRzID0gMFxuXG4gICAgICAgIC8vIFRyeSB1c2luZyBSUEMgZnVuY3Rpb24gZmlyc3QgKGlmIG1pZ3JhdGlvbiB3YXMgcnVuKVxuICAgICAgICBjb25zdCB7IGRhdGE6IHJwY0RhdGEsIGVycm9yOiBycGNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UucnBjKCdjYWxjdWxhdGVfYWNjb3VudF9iYWxhbmNlJywge1xuICAgICAgICAgIHBfYWNjb3VudF9pZDogYWNjb3VudC5hY2NvdW50X2lkXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFycGNFcnJvciAmJiBycGNEYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gUlBDIGZ1bmN0aW9uIGV4aXN0cyBhbmQgd29ya2VkXG4gICAgICAgICAgY29uc3QgY2FsY3VsYXRlZEJhbGFuY2UgPSBycGNEYXRhXG5cbiAgICAgICAgICAvLyBGZXRjaCB1bnJlc29sdmVkIGNoZWNrcG9pbnQgY291bnQgKHdoZXJlIGlzX3JlY29uY2lsZWQgPSBmYWxzZSlcbiAgICAgICAgICBjb25zdCB7IGNvdW50OiB1bnJlc29sdmVkQ291bnQgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAuZnJvbSgnYmFsYW5jZV9jaGVja3BvaW50cycpXG4gICAgICAgICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxuICAgICAgICAgICAgLmVxKCdhY2NvdW50X2lkJywgYWNjb3VudC5hY2NvdW50X2lkKVxuICAgICAgICAgICAgLmVxKCdpc19yZWNvbmNpbGVkJywgZmFsc2UpXG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uYWNjb3VudCxcbiAgICAgICAgICAgIGJhbGFuY2U6IHtcbiAgICAgICAgICAgICAgY3VycmVudF9iYWxhbmNlOiBjYWxjdWxhdGVkQmFsYW5jZSxcbiAgICAgICAgICAgICAgbGFzdF91cGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5yZXNvbHZlZF9jaGVja3BvaW50c19jb3VudDogdW5yZXNvbHZlZENvdW50IHx8IDAsXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmFsbGJhY2s6IEZldGNoIGFsbCB0cmFuc2FjdGlvbnMgd2l0aCBwYWdpbmF0aW9uIHRvIGF2b2lkIDEwMDAgcm93IGxpbWl0XG4gICAgICAgIGxldCBwYWdlID0gMFxuICAgICAgICBjb25zdCBwYWdlU2l6ZSA9IDEwMDBcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IHsgZGF0YTogdHJhbnNhY3Rpb25zLCBlcnJvcjogdHhFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgIC5mcm9tKCdvcmlnaW5hbF90cmFuc2FjdGlvbicpXG4gICAgICAgICAgICAuc2VsZWN0KCdjcmVkaXRfYW1vdW50LCBkZWJpdF9hbW91bnQnKVxuICAgICAgICAgICAgLmVxKCdhY2NvdW50X2lkJywgYWNjb3VudC5hY2NvdW50X2lkKVxuICAgICAgICAgICAgLnJhbmdlKHBhZ2UgKiBwYWdlU2l6ZSwgKHBhZ2UgKyAxKSAqIHBhZ2VTaXplIC0gMSlcblxuICAgICAgICAgIGlmICh0eEVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyB0cmFuc2FjdGlvbnMgZm9yIGFjY291bnQgJHthY2NvdW50LmFjY291bnRfaWR9OmAsIHR4RXJyb3IpXG4gICAgICAgICAgICAvLyBSZXR1cm4gYWNjb3VudCB3aXRoIDAgYmFsYW5jZSBpZiB0cmFuc2FjdGlvbiBmZXRjaCBmYWlsc1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uYWNjb3VudCxcbiAgICAgICAgICAgICAgYmFsYW5jZTogeyBjdXJyZW50X2JhbGFuY2U6IDAsIGxhc3RfdXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH0sXG4gICAgICAgICAgICAgIHVucmVzb2x2ZWRfY2hlY2twb2ludHNfY291bnQ6IDAsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0cmFuc2FjdGlvbnMgfHwgdHJhbnNhY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTdW0gdGhpcyBwYWdlIG9mIHRyYW5zYWN0aW9uc1xuICAgICAgICAgIGZvciAoY29uc3QgdHggb2YgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICBpZiAodHguY3JlZGl0X2Ftb3VudCkge1xuICAgICAgICAgICAgICB0b3RhbENyZWRpdHMgKz0gdHguY3JlZGl0X2Ftb3VudFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR4LmRlYml0X2Ftb3VudCkge1xuICAgICAgICAgICAgICB0b3RhbERlYml0cyArPSB0eC5kZWJpdF9hbW91bnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHJhbnNhY3Rpb25zLmxlbmd0aCA8IHBhZ2VTaXplKSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhZ2UrK1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2FsY3VsYXRlZEJhbGFuY2UgPSB0b3RhbENyZWRpdHMgLSB0b3RhbERlYml0c1xuXG4gICAgICAgIC8vIEZldGNoIHVucmVzb2x2ZWQgY2hlY2twb2ludCBjb3VudCAod2hlcmUgaXNfcmVjb25jaWxlZCA9IGZhbHNlKVxuICAgICAgICBjb25zdCB7IGNvdW50OiB1bnJlc29sdmVkQ291bnQgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2JhbGFuY2VfY2hlY2twb2ludHMnKVxuICAgICAgICAgIC5zZWxlY3QoJyonLCB7IGNvdW50OiAnZXhhY3QnLCBoZWFkOiB0cnVlIH0pXG4gICAgICAgICAgLmVxKCdhY2NvdW50X2lkJywgYWNjb3VudC5hY2NvdW50X2lkKVxuICAgICAgICAgIC5lcSgnaXNfcmVjb25jaWxlZCcsIGZhbHNlKVxuXG4gICAgICAgIC8vIFJldHVybiBhY2NvdW50IHdpdGggY2FsY3VsYXRlZCBiYWxhbmNlIGFuZCBjaGVja3BvaW50IGNvdW50XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uYWNjb3VudCxcbiAgICAgICAgICBiYWxhbmNlOiB7XG4gICAgICAgICAgICBjdXJyZW50X2JhbGFuY2U6IGNhbGN1bGF0ZWRCYWxhbmNlLFxuICAgICAgICAgICAgbGFzdF91cGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1bnJlc29sdmVkX2NoZWNrcG9pbnRzX2NvdW50OiB1bnJlc29sdmVkQ291bnQgfHwgMCxcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApXG5cbiAgICAvLyBHZXQgdG90YWwgY291bnRcbiAgICBjb25zdCB7IGNvdW50OiB0b3RhbENvdW50IH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2FjY291bnRzJylcbiAgICAgIC5zZWxlY3QoJyonLCB7IGNvdW50OiAnZXhhY3QnLCBoZWFkOiB0cnVlIH0pXG5cbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgZGF0YTogYWNjb3VudHNXaXRoQmFsYW5jZXMgfHwgW10sXG4gICAgICBwYWdpbmF0aW9uOiB7XG4gICAgICAgIHBhZ2UsXG4gICAgICAgIGxpbWl0LFxuICAgICAgICB0b3RhbDogdG90YWxDb3VudCB8fCAwLFxuICAgICAgICB0b3RhbFBhZ2VzOiBNYXRoLmNlaWwoKHRvdGFsQ291bnQgfHwgMCkgLyBsaW1pdCksXG4gICAgICB9LFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignVW5leHBlY3RlZCBlcnJvcjonLCBlcnJvcilcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICB7IGVycm9yOiAnQW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZCcgfSxcbiAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgIClcbiAgfVxufVxuXG4vLyBQT1NUIC9hcGkvYWNjb3VudHMgLSBDcmVhdGUgbmV3IGFjY291bnRcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBQT1NUKHJlcXVlc3Q6IE5leHRSZXF1ZXN0KSB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVTdXBhYmFzZVNlcnZlckNsaWVudCgpXG5cbiAgICBjb25zdCBib2R5OiBDcmVhdGVBY2NvdW50SW5wdXQgPSBhd2FpdCByZXF1ZXN0Lmpzb24oKVxuXG4gICAgLy8gVmFsaWRhdGUgcmVxdWlyZWQgZmllbGRzXG4gICAgaWYgKCFib2R5LmVudGl0eV9pZCB8fCAhYm9keS5hY2NvdW50X25hbWUgfHwgIWJvZHkuYWNjb3VudF90eXBlKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdNaXNzaW5nIHJlcXVpcmVkIGZpZWxkczogZW50aXR5X2lkLCBhY2NvdW50X25hbWUsIGFjY291bnRfdHlwZScgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGR1cGxpY2F0ZSBhY2NvdW50IChzYW1lIG5hbWUgKyB0eXBlICsgZW50aXR5KVxuICAgIGNvbnN0IHsgZGF0YTogZXhpc3RpbmdBY2NvdW50cyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdhY2NvdW50cycpXG4gICAgICAuc2VsZWN0KCdhY2NvdW50X2lkJylcbiAgICAgIC5lcSgnZW50aXR5X2lkJywgYm9keS5lbnRpdHlfaWQpXG4gICAgICAuZXEoJ2FjY291bnRfbmFtZScsIGJvZHkuYWNjb3VudF9uYW1lKVxuICAgICAgLmVxKCdhY2NvdW50X3R5cGUnLCBib2R5LmFjY291bnRfdHlwZSlcblxuICAgIGlmIChleGlzdGluZ0FjY291bnRzICYmIGV4aXN0aW5nQWNjb3VudHMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnQW4gYWNjb3VudCB3aXRoIHRoaXMgbmFtZSBhbmQgdHlwZSBhbHJlYWR5IGV4aXN0cyBmb3IgdGhpcyBlbnRpdHknIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDkgfVxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhY2NvdW50XG4gICAgY29uc3QgeyBkYXRhOiBuZXdBY2NvdW50LCBlcnJvcjogYWNjb3VudEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2FjY291bnRzJylcbiAgICAgIC5pbnNlcnQoW1xuICAgICAgICB7XG4gICAgICAgICAgZW50aXR5X2lkOiBib2R5LmVudGl0eV9pZCxcbiAgICAgICAgICBhY2NvdW50X25hbWU6IGJvZHkuYWNjb3VudF9uYW1lLFxuICAgICAgICAgIGFjY291bnRfdHlwZTogYm9keS5hY2NvdW50X3R5cGUsXG4gICAgICAgICAgYWNjb3VudF9udW1iZXI6IGJvZHkuYWNjb3VudF9udW1iZXIgfHwgbnVsbCxcbiAgICAgICAgICBiYW5rX25hbWU6IGJvZHkuYmFua19uYW1lIHx8IG51bGwsXG4gICAgICAgICAgY3VycmVuY3k6IGJvZHkuY3VycmVuY3kgfHwgJ1ZORCcsXG4gICAgICAgICAgY3JlZGl0X2xpbWl0OiBib2R5LmNyZWRpdF9saW1pdCB8fCBudWxsLFxuICAgICAgICAgIGxvYW5fcmVmZXJlbmNlOiBib2R5LmxvYW5fcmVmZXJlbmNlIHx8IG51bGwsXG4gICAgICAgIH0sXG4gICAgICBdKVxuICAgICAgLnNlbGVjdCgpXG4gICAgICAuc2luZ2xlKClcblxuICAgIGlmIChhY2NvdW50RXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIGFjY291bnQ6JywgYWNjb3VudEVycm9yKVxuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgZXJyb3I6IGFjY291bnRFcnJvci5tZXNzYWdlIH0sIHsgc3RhdHVzOiA1MDAgfSlcbiAgICB9XG5cbiAgICAvLyBTZXQgaW5pdGlhbCBiYWxhbmNlIGlmIHByb3ZpZGVkXG4gICAgbGV0IGNoZWNrcG9pbnRXYXJuaW5nOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuXG4gICAgaWYgKGJvZHkuaW5pdGlhbF9iYWxhbmNlICE9PSB1bmRlZmluZWQgJiYgYm9keS5pbml0aWFsX2JhbGFuY2UgIT09IDApIHtcbiAgICAgIC8vIElmIG9wZW5pbmdfYmFsYW5jZV9kYXRlIGlzIHByb3ZpZGVkLCBjcmVhdGUgYSBjaGVja3BvaW50XG4gICAgICAvLyBUaGlzIGZvbGxvd3MgdGhlIFwiTm8gbW9uZXkgd2l0aG91dCBvcmlnaW5cIiBwcmluY2lwbGVcbiAgICAgIGlmIChib2R5Lm9wZW5pbmdfYmFsYW5jZV9kYXRlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIGNoZWNrcG9pbnQgd2l0aCBwYXJhbXM6Jywge1xuICAgICAgICAgICAgYWNjb3VudF9pZDogbmV3QWNjb3VudC5hY2NvdW50X2lkLFxuICAgICAgICAgICAgY2hlY2twb2ludF9kYXRlOiBib2R5Lm9wZW5pbmdfYmFsYW5jZV9kYXRlLFxuICAgICAgICAgICAgZGVjbGFyZWRfYmFsYW5jZTogYm9keS5pbml0aWFsX2JhbGFuY2UsXG4gICAgICAgICAgICBub3RlczogYm9keS5vcGVuaW5nX2JhbGFuY2Vfbm90ZXMgfHwgJ09wZW5pbmcgYmFsYW5jZScsXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGNvbnN0IGNoZWNrcG9pbnQgPSBhd2FpdCBjcmVhdGVPclVwZGF0ZUNoZWNrcG9pbnQoe1xuICAgICAgICAgICAgYWNjb3VudF9pZDogbmV3QWNjb3VudC5hY2NvdW50X2lkLFxuICAgICAgICAgICAgY2hlY2twb2ludF9kYXRlOiBuZXcgRGF0ZShib2R5Lm9wZW5pbmdfYmFsYW5jZV9kYXRlKSxcbiAgICAgICAgICAgIGRlY2xhcmVkX2JhbGFuY2U6IGJvZHkuaW5pdGlhbF9iYWxhbmNlLFxuICAgICAgICAgICAgbm90ZXM6IGJvZHkub3BlbmluZ19iYWxhbmNlX25vdGVzIHx8ICdPcGVuaW5nIGJhbGFuY2UnLFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIENoZWNrcG9pbnQgY3JlYXRlZCBzdWNjZXNzZnVsbHk6JywgY2hlY2twb2ludClcbiAgICAgICAgfSBjYXRjaCAoY2hlY2twb2ludEVycm9yOiBhbnkpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgY3JlYXRpbmcgb3BlbmluZyBiYWxhbmNlIGNoZWNrcG9pbnQ6JywgY2hlY2twb2ludEVycm9yKVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGFpbHM6Jywge1xuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2twb2ludEVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBzdGFjazogY2hlY2twb2ludEVycm9yLnN0YWNrLFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBjaGVja3BvaW50V2FybmluZyA9IGBBY2NvdW50IGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5LCBidXQgY2hlY2twb2ludCBjcmVhdGlvbiBmYWlsZWQ6ICR7Y2hlY2twb2ludEVycm9yLm1lc3NhZ2V9LiBQbGVhc2UgY2hlY2sgc2VydmVyIGxvZ3MuYFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBObyBvcGVuaW5nX2JhbGFuY2VfZGF0ZSBwcm92aWRlZCAtIHNraXAgaW5pdGlhbCBiYWxhbmNlXG4gICAgICAgIC8vIEFjY291bnQgd2lsbCBzdGFydCB3aXRoIDAgYmFsYW5jZVxuICAgICAgICBjb25zb2xlLmxvZygnTm8gb3BlbmluZ19iYWxhbmNlX2RhdGUgcHJvdmlkZWQsIGFjY291bnQgc3RhcnRzIHdpdGggMCBiYWxhbmNlJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGZXRjaCB0aGUgY29tcGxldGUgYWNjb3VudCB3aXRoIGVudGl0eVxuICAgIGNvbnN0IHsgZGF0YTogY29tcGxldGVBY2NvdW50IH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2FjY291bnRzJylcbiAgICAgIC5zZWxlY3QoYFxuICAgICAgICAqLFxuICAgICAgICBlbnRpdHk6ZW50aXRpZXMoaWQsIG5hbWUsIHR5cGUpXG4gICAgICBgKVxuICAgICAgLmVxKCdhY2NvdW50X2lkJywgbmV3QWNjb3VudC5hY2NvdW50X2lkKVxuICAgICAgLnNpbmdsZSgpXG5cbiAgICAvLyBSZXR1cm4gYWNjb3VudCB3aXRoIG9wdGlvbmFsIHdhcm5pbmcgYWJvdXQgY2hlY2twb2ludCBjcmVhdGlvblxuICAgIGlmIChjaGVja3BvaW50V2FybmluZykge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7XG4gICAgICAgICAgLi4uY29tcGxldGVBY2NvdW50LFxuICAgICAgICAgIHdhcm5pbmc6IGNoZWNrcG9pbnRXYXJuaW5nLFxuICAgICAgICB9LFxuICAgICAgICB7IHN0YXR1czogMjAxIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oY29tcGxldGVBY2NvdW50LCB7IHN0YXR1czogMjAxIH0pXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignVW5leHBlY3RlZCBlcnJvcjonLCBlcnJvcilcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICB7IGVycm9yOiAnQW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZCcgfSxcbiAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgIClcbiAgfVxufVxuIl0sIm5hbWVzIjpbIk5leHRSZXNwb25zZSIsImNyZWF0ZVN1cGFiYXNlU2VydmVyQ2xpZW50IiwiY3JlYXRlT3JVcGRhdGVDaGVja3BvaW50IiwiR0VUIiwicmVxdWVzdCIsInN1cGFiYXNlIiwic2VhcmNoUGFyYW1zIiwibmV4dFVybCIsImVudGl0eUlkIiwiZ2V0IiwiYWNjb3VudFR5cGVzIiwic3BsaXQiLCJpc0FjdGl2ZSIsInNlYXJjaCIsInBhZ2UiLCJwYXJzZUludCIsImxpbWl0IiwicXVlcnkiLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJsZW5ndGgiLCJpbiIsInVuZGVmaW5lZCIsIm9yIiwidG8iLCJkYXRhIiwiYWNjb3VudHMiLCJlcnJvciIsImNvdW50Iiwib3JkZXIiLCJhc2NlbmRpbmciLCJyYW5nZSIsImNvbnNvbGUiLCJqc29uIiwibWVzc2FnZSIsInN0YXR1cyIsImFjY291bnRzV2l0aEJhbGFuY2VzIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsImFjY291bnQiLCJ0b3RhbENyZWRpdHMiLCJ0b3RhbERlYml0cyIsInJwY0RhdGEiLCJycGNFcnJvciIsInJwYyIsInBfYWNjb3VudF9pZCIsImFjY291bnRfaWQiLCJjYWxjdWxhdGVkQmFsYW5jZSIsInVucmVzb2x2ZWRDb3VudCIsImhlYWQiLCJiYWxhbmNlIiwiY3VycmVudF9iYWxhbmNlIiwibGFzdF91cGRhdGVkIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwidW5yZXNvbHZlZF9jaGVja3BvaW50c19jb3VudCIsInBhZ2VTaXplIiwidHJhbnNhY3Rpb25zIiwidHhFcnJvciIsInR4IiwiY3JlZGl0X2Ftb3VudCIsImRlYml0X2Ftb3VudCIsInRvdGFsQ291bnQiLCJwYWdpbmF0aW9uIiwidG90YWwiLCJ0b3RhbFBhZ2VzIiwiTWF0aCIsImNlaWwiLCJQT1NUIiwiYm9keSIsImVudGl0eV9pZCIsImFjY291bnRfbmFtZSIsImFjY291bnRfdHlwZSIsImV4aXN0aW5nQWNjb3VudHMiLCJuZXdBY2NvdW50IiwiYWNjb3VudEVycm9yIiwiaW5zZXJ0IiwiYWNjb3VudF9udW1iZXIiLCJiYW5rX25hbWUiLCJjdXJyZW5jeSIsImNyZWRpdF9saW1pdCIsImxvYW5fcmVmZXJlbmNlIiwic2luZ2xlIiwiY2hlY2twb2ludFdhcm5pbmciLCJpbml0aWFsX2JhbGFuY2UiLCJvcGVuaW5nX2JhbGFuY2VfZGF0ZSIsImxvZyIsImNoZWNrcG9pbnRfZGF0ZSIsImRlY2xhcmVkX2JhbGFuY2UiLCJub3RlcyIsIm9wZW5pbmdfYmFsYW5jZV9ub3RlcyIsImNoZWNrcG9pbnQiLCJjaGVja3BvaW50RXJyb3IiLCJzdGFjayIsImNvbXBsZXRlQWNjb3VudCIsIndhcm5pbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./app/api/accounts/route.ts\n");

/***/ }),

/***/ "(rsc)/./lib/checkpoint-service.ts":
/*!***********************************!*\
  !*** ./lib/checkpoint-service.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateBalanceUpToDate: () => (/* binding */ calculateBalanceUpToDate),\n/* harmony export */   createOrUpdateBalanceAdjustmentTransaction: () => (/* binding */ createOrUpdateBalanceAdjustmentTransaction),\n/* harmony export */   createOrUpdateCheckpoint: () => (/* binding */ createOrUpdateCheckpoint),\n/* harmony export */   deleteCheckpoint: () => (/* binding */ deleteCheckpoint),\n/* harmony export */   getAccountCheckpoints: () => (/* binding */ getAccountCheckpoints),\n/* harmony export */   getCheckpointById: () => (/* binding */ getCheckpointById),\n/* harmony export */   getCheckpointSummary: () => (/* binding */ getCheckpointSummary),\n/* harmony export */   getFlaggedTransactions: () => (/* binding */ getFlaggedTransactions),\n/* harmony export */   recalculateAllCheckpoints: () => (/* binding */ recalculateAllCheckpoints),\n/* harmony export */   updateAccountOpeningBalanceDate: () => (/* binding */ updateAccountOpeningBalanceDate)\n/* harmony export */ });\n/* harmony import */ var _supabase_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabase-server */ \"(rsc)/./lib/supabase-server.ts\");\n/* harmony import */ var _types_checkpoint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/types/checkpoint */ \"(rsc)/./types/checkpoint.ts\");\n/**\n * Balance Checkpoint Service\n * Implements core business logic for the \"No money without origin\" principle\n */ \n\n// ==============================================================================\n// Helper Functions\n// ==============================================================================\n/**\n * Converts a Date object to ISO date string (YYYY-MM-DD) without timezone conversion\n * This is timezone-safe: 2025-03-01 midnight GMT+7 → \"2025-03-01\" (not \"2025-02-28\"!)\n */ function toISODateString(date) {\n    const year = date.getFullYear();\n    const month = String(date.getMonth() + 1).padStart(2, \"0\");\n    const day = String(date.getDate()).padStart(2, \"0\");\n    return `${year}-${month}-${day}`;\n}\n// ==============================================================================\n// Core Function 1: Calculate Balance Up To Date\n// ==============================================================================\n/**\n * Calculates account balance from all transactions up to (and including) a specific date\n * Excludes balance adjustment transactions from the calculation\n */ async function calculateBalanceUpToDate(accountId, upToDate) {\n    const supabase = (0,_supabase_server__WEBPACK_IMPORTED_MODULE_0__.createSupabaseServerClient)();\n    try {\n        const upToDateStr = toISODateString(upToDate);\n        // Use the database function for accurate calculation\n        const { data, error } = await supabase.rpc(\"calculate_balance_up_to_date\", {\n            p_account_id: accountId,\n            p_up_to_date: upToDateStr\n        });\n        if (error) {\n            console.error(\"Error calculating balance:\", error);\n            throw new Error(`Failed to calculate balance: ${error.message}`);\n        }\n        // Also get transaction count for metadata\n        const { count } = await supabase.from(\"original_transaction\").select(\"*\", {\n            count: \"exact\",\n            head: true\n        }).eq(\"account_id\", accountId).lte(\"transaction_date\", upToDateStr).eq(\"is_balance_adjustment\", false);\n        return {\n            account_id: accountId,\n            up_to_date: upToDateStr,\n            calculated_balance: data || 0,\n            transaction_count: count || 0\n        };\n    } catch (error) {\n        console.error(\"Error in calculateBalanceUpToDate:\", error);\n        throw error;\n    }\n}\n// ==============================================================================\n// Core Function 2: Create or Update Balance Adjustment Transaction\n// ==============================================================================\n/**\n * Creates or updates a balance adjustment transaction for a checkpoint\n * For normal accounts: Positive adjustment = Credit (missing income), Negative = Debit (missing expense)\n * For credit accounts: Positive adjustment = Debit (missing borrowing), Negative = Credit (excess debt/payment)\n */ async function createOrUpdateBalanceAdjustmentTransaction(checkpoint) {\n    const supabase = (0,_supabase_server__WEBPACK_IMPORTED_MODULE_0__.createSupabaseServerClient)();\n    try {\n        const { checkpoint_id, account_id, checkpoint_date, adjustment_amount } = checkpoint;\n        // Fetch account to check type\n        const { data: account, error: accountError } = await supabase.from(\"accounts\").select(\"account_type\").eq(\"account_id\", account_id).single();\n        if (accountError) {\n            throw new Error(`Failed to fetch account: ${accountError.message}`);\n        }\n        const isCreditAccount = [\n            \"credit_line\",\n            \"term_loan\",\n            \"credit_card\"\n        ].includes(account.account_type);\n        // Check if adjustment transaction already exists\n        const { data: existing, error: fetchError } = await supabase.from(\"original_transaction\").select(\"*\").eq(\"checkpoint_id\", checkpoint_id).maybeSingle();\n        if (fetchError) {\n            throw new Error(`Failed to fetch existing transaction: ${fetchError.message}`);\n        }\n        // If adjustment is effectively 0 (within threshold), delete existing transaction\n        if (Math.abs(adjustment_amount) < _types_checkpoint__WEBPACK_IMPORTED_MODULE_1__.CHECKPOINT_CONFIG.RECONCILIATION_THRESHOLD) {\n            if (existing) {\n                const { error: deleteError } = await supabase.from(\"original_transaction\").delete().eq(\"checkpoint_id\", checkpoint_id);\n                if (deleteError) {\n                    throw new Error(`Failed to delete adjustment transaction: ${deleteError.message}`);\n                }\n            }\n            return;\n        }\n        // Prepare transaction data\n        // NOTE: Database constraint requires that either debit OR credit is NULL, not 0\n        // For credit accounts, invert the debit/credit logic\n        const creditAmount = isCreditAccount ? adjustment_amount < 0 ? Math.abs(adjustment_amount) : null // Inverted\n         : adjustment_amount > 0 ? adjustment_amount : null // Normal\n        ;\n        const debitAmount = isCreditAccount ? adjustment_amount > 0 ? adjustment_amount : null // Inverted\n         : adjustment_amount < 0 ? Math.abs(adjustment_amount) : null // Normal\n        ;\n        const transactionData = {\n            account_id,\n            transaction_date: checkpoint_date,\n            description: _types_checkpoint__WEBPACK_IMPORTED_MODULE_1__.CHECKPOINT_CONFIG.BALANCE_ADJUSTMENT_DESCRIPTION,\n            credit_amount: creditAmount,\n            debit_amount: debitAmount,\n            checkpoint_id,\n            is_balance_adjustment: true,\n            is_flagged: true\n        };\n        if (existing) {\n            // Update existing transaction\n            // NOTE: Must use null (not 0) for the unused amount field\n            const { error: updateError } = await supabase.from(\"original_transaction\").update({\n                credit_amount: transactionData.credit_amount,\n                debit_amount: transactionData.debit_amount,\n                updated_at: new Date().toISOString()\n            }).eq(\"checkpoint_id\", checkpoint_id);\n            if (updateError) {\n                throw new Error(`Failed to update adjustment transaction: ${updateError.message}`);\n            }\n        } else {\n            // Create new transaction\n            // Generate unique transaction ID for balance adjustment\n            const raw_transaction_id = `BAL-ADJ-${checkpoint_id}`;\n            const { error: insertError } = await supabase.from(\"original_transaction\").insert({\n                raw_transaction_id: raw_transaction_id,\n                account_id: transactionData.account_id,\n                transaction_date: transactionData.transaction_date,\n                description: transactionData.description,\n                credit_amount: transactionData.credit_amount,\n                debit_amount: transactionData.debit_amount,\n                transaction_source: \"auto_adjustment\",\n                checkpoint_id: transactionData.checkpoint_id,\n                is_balance_adjustment: transactionData.is_balance_adjustment,\n                is_flagged: transactionData.is_flagged\n            });\n            if (insertError) {\n                throw new Error(`Failed to create adjustment transaction: ${insertError.message}`);\n            }\n        }\n    } catch (error) {\n        console.error(\"Error in createOrUpdateBalanceAdjustmentTransaction:\", error);\n        throw error;\n    }\n}\n// ==============================================================================\n// Core Function 3: Create or Update Checkpoint\n// ==============================================================================\n/**\n * Creates or updates a balance checkpoint for an account\n * This is the main entry point for checkpoint management\n *\n * IMPORTANT: After creating/updating, this triggers recalculation of ALL checkpoints\n * to ensure adjustments are correct regardless of creation order\n */ async function createOrUpdateCheckpoint(params) {\n    const supabase = (0,_supabase_server__WEBPACK_IMPORTED_MODULE_0__.createSupabaseServerClient)();\n    const { account_id, checkpoint_date, declared_balance, notes = null, import_batch_id = null, user_id = null } = params;\n    try {\n        // Step 1: Check if checkpoint already exists for this account, date, AND import_batch_id\n        // For import checkpoints: each import batch gets its own checkpoint (even on same date)\n        // For manual checkpoints (import_batch_id = null): only one per date\n        const checkpointDateStr = toISODateString(checkpoint_date);\n        let existingQuery = supabase.from(\"balance_checkpoints\").select(\"*\").eq(\"account_id\", account_id).eq(\"checkpoint_date\", checkpointDateStr);\n        // If this is an import checkpoint, check for exact match (same batch)\n        // If this is a manual checkpoint, check for any manual checkpoint on that date\n        if (import_batch_id !== null) {\n            existingQuery = existingQuery.eq(\"import_batch_id\", import_batch_id);\n        } else {\n            existingQuery = existingQuery.is(\"import_batch_id\", null);\n        }\n        const { data: existing, error: fetchError } = await existingQuery.maybeSingle();\n        if (fetchError) {\n            throw new Error(`Failed to check for existing checkpoint: ${fetchError.message}`);\n        }\n        let checkpoint;\n        if (existing) {\n            // Update existing checkpoint (same date + same import_batch_id)\n            const { data: updated, error: updateError } = await supabase.from(\"balance_checkpoints\").update({\n                declared_balance,\n                notes,\n                updated_at: new Date().toISOString()\n            }).eq(\"checkpoint_id\", existing.checkpoint_id).select().single();\n            if (updateError || !updated) {\n                throw new Error(`Failed to update checkpoint: ${updateError?.message || \"No data returned\"}`);\n            }\n            checkpoint = updated;\n        } else {\n            // Create new checkpoint (calculated values will be set by recalculation)\n            const { data: created, error: insertError } = await supabase.from(\"balance_checkpoints\").insert({\n                account_id,\n                checkpoint_date: checkpointDateStr,\n                declared_balance,\n                calculated_balance: 0,\n                adjustment_amount: 0,\n                is_reconciled: false,\n                notes,\n                import_batch_id,\n                created_by_user_id: user_id\n            }).select().single();\n            if (insertError || !created) {\n                throw new Error(`Failed to create checkpoint: ${insertError?.message || \"No data returned\"}`);\n            }\n            checkpoint = created;\n        }\n        // Step 2: Recalculate ALL checkpoints for this account\n        // This ensures adjustments are correct regardless of creation order\n        await recalculateAllCheckpoints({\n            account_id\n        });\n        // Step 3: Fetch the updated checkpoint after recalculation\n        const { data: finalCheckpoint, error: finalError } = await supabase.from(\"balance_checkpoints\").select(\"*\").eq(\"checkpoint_id\", checkpoint.checkpoint_id).single();\n        if (finalError || !finalCheckpoint) {\n            throw new Error(`Failed to fetch recalculated checkpoint: ${finalError?.message}`);\n        }\n        // Step 4: Update account opening balance date\n        await updateAccountOpeningBalanceDate(account_id);\n        return finalCheckpoint;\n    } catch (error) {\n        console.error(\"Error in createOrUpdateCheckpoint:\", error);\n        throw error;\n    }\n}\n// ==============================================================================\n// Core Function 3: Recalculate All Checkpoints\n// ==============================================================================\n/**\n * Recalculates all checkpoints for an account IN CHRONOLOGICAL ORDER\n * This ensures adjustments are calculated correctly regardless of creation order\n *\n * Key algorithm:\n * 1. Process all checkpoints sorted by checkpoint_date ASC\n * 2. For each checkpoint, calculate balance from:\n *    - All non-adjustment transactions up to checkpoint date\n *    - Adjustment transactions from PREVIOUS checkpoints only (by date, not creation time)\n * 3. This ensures that a checkpoint dated Oct 5 created AFTER a checkpoint dated Oct 15\n *    will have the correct adjustment amount\n */ async function recalculateAllCheckpoints(params) {\n    const supabase = (0,_supabase_server__WEBPACK_IMPORTED_MODULE_0__.createSupabaseServerClient)();\n    const { account_id, from_date, to_date, checkpoint_ids } = params;\n    try {\n        // Fetch account to check type (for credit account logic)\n        const { data: account, error: accountError } = await supabase.from(\"accounts\").select(\"account_type\").eq(\"account_id\", account_id).single();\n        if (accountError) {\n            throw new Error(`Failed to fetch account: ${accountError.message}`);\n        }\n        // Check if this is a credit-type account (where positive balance = debt owed)\n        const isCreditAccount = [\n            \"credit_line\",\n            \"term_loan\",\n            \"credit_card\"\n        ].includes(account.account_type);\n        // Fetch ALL checkpoints for the account in chronological order\n        // We need to recalculate all, not just filtered ones, to get correct adjustment chain\n        const { data: allCheckpoints, error: fetchError } = await supabase.from(\"balance_checkpoints\").select(\"*\").eq(\"account_id\", account_id).order(\"checkpoint_date\", {\n            ascending: true\n        }).order(\"checkpoint_id\", {\n            ascending: true\n        }) // Tie-breaker for same dates\n        ;\n        if (fetchError) {\n            throw new Error(`Failed to fetch checkpoints: ${fetchError.message}`);\n        }\n        if (!allCheckpoints || allCheckpoints.length === 0) {\n            return [];\n        }\n        // Determine which checkpoints to actually recalculate (for return results)\n        let checkpointsToRecalculate = allCheckpoints;\n        if (from_date || to_date || checkpoint_ids) {\n            checkpointsToRecalculate = allCheckpoints.filter((cp)=>{\n                const cpDate = new Date(cp.checkpoint_date);\n                if (from_date && cpDate < from_date) return false;\n                if (to_date && cpDate > to_date) return false;\n                if (checkpoint_ids && !checkpoint_ids.includes(cp.checkpoint_id)) return false;\n                return true;\n            });\n        }\n        const results = [];\n        // Process each checkpoint in chronological order\n        for (const checkpoint of allCheckpoints){\n            // checkpoint_date is already a date string from database\n            const checkpointDateStr = checkpoint.checkpoint_date;\n            // Calculate balance from:\n            // 1. Non-adjustment transactions up to checkpoint date\n            // Fetch ALL transactions using pagination to avoid 1000 row limit\n            let totalCredits = 0;\n            let totalDebits = 0;\n            let page = 0;\n            const pageSize = 1000;\n            while(true){\n                const { data: nonAdjustmentTxs, error: txError } = await supabase.from(\"original_transaction\").select(\"credit_amount, debit_amount\").eq(\"account_id\", account_id).eq(\"is_balance_adjustment\", false).lte(\"transaction_date\", checkpointDateStr).range(page * pageSize, (page + 1) * pageSize - 1);\n                if (txError) {\n                    throw new Error(`Failed to fetch transactions: ${txError.message}`);\n                }\n                if (!nonAdjustmentTxs || nonAdjustmentTxs.length === 0) {\n                    break;\n                }\n                // Sum this page of transactions\n                for (const tx of nonAdjustmentTxs){\n                    if (tx.credit_amount) totalCredits += tx.credit_amount;\n                    if (tx.debit_amount) totalDebits += tx.debit_amount;\n                }\n                if (nonAdjustmentTxs.length < pageSize) {\n                    break;\n                }\n                page++;\n            }\n            // 2. Adjustment transactions from PREVIOUS checkpoints only (by date)\n            // Get checkpoints with earlier dates\n            // checkpoint_date is already a date string, can compare directly\n            const previousCheckpoints = allCheckpoints.filter((cp)=>cp.checkpoint_date < checkpointDateStr);\n            if (previousCheckpoints.length > 0) {\n                const previousCheckpointIds = previousCheckpoints.map((cp)=>cp.checkpoint_id);\n                const { data: previousAdjustments, error: adjError } = await supabase.from(\"original_transaction\").select(\"credit_amount, debit_amount\").eq(\"account_id\", account_id).eq(\"is_balance_adjustment\", true).in(\"checkpoint_id\", previousCheckpointIds);\n                if (adjError) {\n                    throw new Error(`Failed to fetch previous adjustments: ${adjError.message}`);\n                }\n                // Sum previous adjustments\n                if (previousAdjustments && previousAdjustments.length > 0) {\n                    for (const tx of previousAdjustments){\n                        if (tx.credit_amount) totalCredits += tx.credit_amount;\n                        if (tx.debit_amount) totalDebits += tx.debit_amount;\n                    }\n                }\n            }\n            const newCalculatedBalance = totalCredits - totalDebits;\n            const newAdjustmentAmount = checkpoint.declared_balance - newCalculatedBalance;\n            const newIsReconciled = Math.abs(newAdjustmentAmount) < _types_checkpoint__WEBPACK_IMPORTED_MODULE_1__.CHECKPOINT_CONFIG.RECONCILIATION_THRESHOLD;\n            // Store old values for results\n            const oldCalculatedBalance = checkpoint.calculated_balance;\n            const oldAdjustmentAmount = checkpoint.adjustment_amount;\n            const oldIsReconciled = checkpoint.is_reconciled;\n            // Update checkpoint record\n            const { error: updateError } = await supabase.from(\"balance_checkpoints\").update({\n                calculated_balance: newCalculatedBalance,\n                adjustment_amount: newAdjustmentAmount,\n                is_reconciled: newIsReconciled,\n                updated_at: new Date().toISOString()\n            }).eq(\"checkpoint_id\", checkpoint.checkpoint_id);\n            if (updateError) {\n                throw new Error(`Failed to update checkpoint ${checkpoint.checkpoint_id}: ${updateError.message}`);\n            }\n            // Delete old adjustment transaction\n            await supabase.from(\"original_transaction\").delete().eq(\"checkpoint_id\", checkpoint.checkpoint_id).eq(\"is_balance_adjustment\", true);\n            // Create new adjustment transaction if needed\n            if (Math.abs(newAdjustmentAmount) >= _types_checkpoint__WEBPACK_IMPORTED_MODULE_1__.CHECKPOINT_CONFIG.RECONCILIATION_THRESHOLD) {\n                const raw_transaction_id = `BAL-ADJ-${checkpoint.checkpoint_id}`;\n                // For credit accounts (credit_line, term_loan, credit_card):\n                // - Positive balance = debt owed (increases with DEBITS, not credits)\n                // - Positive adjustment means need more debt → DEBIT\n                // - Negative adjustment means too much debt → CREDIT (payment)\n                // For normal accounts (bank, cash):\n                // - Positive balance = asset (increases with CREDITS)\n                // - Positive adjustment means missing income → CREDIT\n                // - Negative adjustment means missing expense → DEBIT\n                const creditAmount = isCreditAccount ? newAdjustmentAmount < 0 ? Math.abs(newAdjustmentAmount) : null // Inverted\n                 : newAdjustmentAmount > 0 ? newAdjustmentAmount : null // Normal\n                ;\n                const debitAmount = isCreditAccount ? newAdjustmentAmount > 0 ? newAdjustmentAmount : null // Inverted\n                 : newAdjustmentAmount < 0 ? Math.abs(newAdjustmentAmount) : null // Normal\n                ;\n                const { error: insertError } = await supabase.from(\"original_transaction\").insert({\n                    raw_transaction_id,\n                    account_id,\n                    transaction_date: checkpointDateStr,\n                    description: _types_checkpoint__WEBPACK_IMPORTED_MODULE_1__.CHECKPOINT_CONFIG.BALANCE_ADJUSTMENT_DESCRIPTION,\n                    credit_amount: creditAmount,\n                    debit_amount: debitAmount,\n                    transaction_source: \"auto_adjustment\",\n                    checkpoint_id: checkpoint.checkpoint_id,\n                    is_balance_adjustment: true,\n                    is_flagged: true\n                });\n                if (insertError) {\n                    throw new Error(`Failed to create adjustment transaction: ${insertError.message}`);\n                }\n            }\n            // Add to results if this checkpoint was requested for recalculation\n            if (checkpointsToRecalculate.find((cp)=>cp.checkpoint_id === checkpoint.checkpoint_id)) {\n                results.push({\n                    checkpoint_id: checkpoint.checkpoint_id,\n                    old_calculated_balance: oldCalculatedBalance,\n                    new_calculated_balance: newCalculatedBalance,\n                    old_adjustment_amount: oldAdjustmentAmount,\n                    new_adjustment_amount: newAdjustmentAmount,\n                    old_is_reconciled: oldIsReconciled,\n                    new_is_reconciled: newIsReconciled,\n                    adjustment_transaction_updated: true\n                });\n            }\n        }\n        // Update account opening balance date\n        await updateAccountOpeningBalanceDate(account_id);\n        return results;\n    } catch (error) {\n        console.error(\"Error in recalculateAllCheckpoints:\", error);\n        throw error;\n    }\n}\n// ==============================================================================\n// Core Function 5: Update Account Opening Balance Date\n// ==============================================================================\n/**\n * Updates account opening balance date to be before the earliest transaction\n */ async function updateAccountOpeningBalanceDate(accountId) {\n    const supabase = (0,_supabase_server__WEBPACK_IMPORTED_MODULE_0__.createSupabaseServerClient)();\n    try {\n        // Use the database function for accurate calculation\n        const { error } = await supabase.rpc(\"update_account_opening_balance_date\", {\n            p_account_id: accountId\n        });\n        if (error) {\n            throw new Error(`Failed to update account opening balance date: ${error.message}`);\n        }\n    } catch (error) {\n        console.error(\"Error in updateAccountOpeningBalanceDate:\", error);\n        throw error;\n    }\n}\n// ==============================================================================\n// Helper Functions\n// ==============================================================================\n/**\n * Get all checkpoints for an account\n */ async function getAccountCheckpoints(accountId, options) {\n    const supabase = (0,_supabase_server__WEBPACK_IMPORTED_MODULE_0__.createSupabaseServerClient)();\n    try {\n        let query = supabase.from(\"balance_checkpoints\").select(\"*\").eq(\"account_id\", accountId);\n        // Filter reconciled if requested\n        if (options?.includeReconciled === false) {\n            query = query.eq(\"is_reconciled\", false);\n        }\n        // Apply ordering\n        const ascending = options?.orderBy === \"date_asc\";\n        query = query.order(\"checkpoint_date\", {\n            ascending\n        });\n        // Apply pagination\n        if (options?.limit) {\n            const from = options.offset || 0;\n            const to = from + options.limit - 1;\n            query = query.range(from, to);\n        }\n        const { data, error } = await query;\n        if (error) {\n            throw new Error(`Failed to fetch checkpoints: ${error.message}`);\n        }\n        return data || [];\n    } catch (error) {\n        console.error(\"Error in getAccountCheckpoints:\", error);\n        throw error;\n    }\n}\n/**\n * Get a single checkpoint by ID\n */ async function getCheckpointById(checkpointId) {\n    const supabase = (0,_supabase_server__WEBPACK_IMPORTED_MODULE_0__.createSupabaseServerClient)();\n    try {\n        const { data, error } = await supabase.from(\"balance_checkpoints\").select(\"*\").eq(\"checkpoint_id\", checkpointId).maybeSingle();\n        if (error) {\n            throw new Error(`Failed to fetch checkpoint: ${error.message}`);\n        }\n        return data;\n    } catch (error) {\n        console.error(\"Error in getCheckpointById:\", error);\n        throw error;\n    }\n}\n/**\n * Delete a checkpoint and its associated balance adjustment transaction\n * After deletion, recalculates all remaining checkpoints\n */ async function deleteCheckpoint(checkpointId) {\n    const supabase = (0,_supabase_server__WEBPACK_IMPORTED_MODULE_0__.createSupabaseServerClient)();\n    try {\n        // Get the checkpoint to find the account_id\n        const checkpoint = await getCheckpointById(checkpointId);\n        if (!checkpoint) {\n            throw new Error(`Checkpoint ${checkpointId} not found`);\n        }\n        const accountId = checkpoint.account_id;\n        // IMPORTANT: Delete the adjustment transaction FIRST\n        // We do this explicitly because CASCADE may not be set up in the database\n        const { error: txDeleteError } = await supabase.from(\"original_transaction\").delete().eq(\"checkpoint_id\", checkpointId).eq(\"is_balance_adjustment\", true);\n        if (txDeleteError) {\n            console.error(\"Error deleting adjustment transaction:\", txDeleteError);\n        // Continue anyway - the checkpoint deletion is more important\n        }\n        // Delete the checkpoint\n        const { error: checkpointDeleteError } = await supabase.from(\"balance_checkpoints\").delete().eq(\"checkpoint_id\", checkpointId);\n        if (checkpointDeleteError) {\n            throw new Error(`Failed to delete checkpoint: ${checkpointDeleteError.message}`);\n        }\n        // Recalculate all remaining checkpoints\n        // This ensures that if we deleted a checkpoint with an earlier date,\n        // later checkpoints get their adjustments recalculated correctly\n        await recalculateAllCheckpoints({\n            account_id: accountId\n        });\n        // Update account opening balance date\n        await updateAccountOpeningBalanceDate(accountId);\n    } catch (error) {\n        console.error(\"Error in deleteCheckpoint:\", error);\n        throw error;\n    }\n}\n/**\n * Get all flagged (balance adjustment) transactions for an account\n */ async function getFlaggedTransactions(accountId) {\n    const supabase = (0,_supabase_server__WEBPACK_IMPORTED_MODULE_0__.createSupabaseServerClient)();\n    try {\n        const { data, error } = await supabase.from(\"original_transaction\").select(`\n        *,\n        checkpoint:balance_checkpoints(\n          checkpoint_id,\n          checkpoint_date,\n          declared_balance,\n          adjustment_amount,\n          is_reconciled\n        )\n      `).eq(\"account_id\", accountId).eq(\"is_flagged\", true).order(\"transaction_date\", {\n            ascending: false\n        });\n        if (error) {\n            throw new Error(`Failed to fetch flagged transactions: ${error.message}`);\n        }\n        return data || [];\n    } catch (error) {\n        console.error(\"Error in getFlaggedTransactions:\", error);\n        throw error;\n    }\n}\n/**\n * Get checkpoint summary statistics for an account\n */ async function getCheckpointSummary(accountId) {\n    const supabase = (0,_supabase_server__WEBPACK_IMPORTED_MODULE_0__.createSupabaseServerClient)();\n    try {\n        const { data, error } = await supabase.from(\"balance_checkpoints\").select(\"*\").eq(\"account_id\", accountId);\n        if (error) {\n            throw new Error(`Failed to fetch checkpoint summary: ${error.message}`);\n        }\n        if (!data || data.length === 0) {\n            return {\n                total_checkpoints: 0,\n                reconciled_checkpoints: 0,\n                unreconciled_checkpoints: 0,\n                total_adjustment_amount: 0,\n                earliest_checkpoint_date: null,\n                latest_checkpoint_date: null\n            };\n        }\n        const reconciledCount = data.filter((cp)=>cp.is_reconciled).length;\n        const totalAdjustment = data.reduce((sum, cp)=>sum + cp.adjustment_amount, 0);\n        // checkpoint_date is already a string (YYYY-MM-DD), can compare directly\n        const dates = data.map((cp)=>cp.checkpoint_date).sort();\n        return {\n            total_checkpoints: data.length,\n            reconciled_checkpoints: reconciledCount,\n            unreconciled_checkpoints: data.length - reconciledCount,\n            total_adjustment_amount: totalAdjustment,\n            earliest_checkpoint_date: dates[0],\n            latest_checkpoint_date: dates[dates.length - 1]\n        };\n    } catch (error) {\n        console.error(\"Error in getCheckpointSummary:\", error);\n        throw error;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RCx3QkFBd0JLO1lBQ3hCSiwwQkFBMEJuSSxLQUFLK0UsTUFBTSxHQUFHd0Q7WUFDeENILHlCQUF5Qkk7WUFDekJILDBCQUEwQk0sS0FBSyxDQUFDLEVBQUU7WUFDbENMLHdCQUF3QkssS0FBSyxDQUFDQSxNQUFNNUQsTUFBTSxHQUFHLEVBQUU7UUFDakQ7SUFDRixFQUFFLE9BQU85RSxPQUFPO1FBQ2RJLFFBQVFKLEtBQUssQ0FBQyxrQ0FBa0NBO1FBQ2hELE1BQU1BO0lBQ1I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BmaW5hbmNlYXBwL3dlYi8uL2xpYi9jaGVja3BvaW50LXNlcnZpY2UudHM/MTc4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEJhbGFuY2UgQ2hlY2twb2ludCBTZXJ2aWNlXG4gKiBJbXBsZW1lbnRzIGNvcmUgYnVzaW5lc3MgbG9naWMgZm9yIHRoZSBcIk5vIG1vbmV5IHdpdGhvdXQgb3JpZ2luXCIgcHJpbmNpcGxlXG4gKi9cblxuaW1wb3J0IHsgY3JlYXRlU3VwYWJhc2VTZXJ2ZXJDbGllbnQgfSBmcm9tICcuL3N1cGFiYXNlLXNlcnZlcidcbmltcG9ydCB0eXBlIHtcbiAgQmFsYW5jZUNoZWNrcG9pbnQsXG4gIENyZWF0ZU9yVXBkYXRlQ2hlY2twb2ludFBhcmFtcyxcbiAgUmVjYWxjdWxhdGVDaGVja3BvaW50c1BhcmFtcyxcbiAgQmFsYW5jZUFkanVzdG1lbnRUcmFuc2FjdGlvbkRhdGEsXG4gIENoZWNrcG9pbnRSZWNhbGN1bGF0aW9uUmVzdWx0LFxuICBCYWxhbmNlQ2FsY3VsYXRpb24sXG59IGZyb20gJ0AvdHlwZXMvY2hlY2twb2ludCdcbmltcG9ydCB7IENIRUNLUE9JTlRfQ09ORklHIH0gZnJvbSAnQC90eXBlcy9jaGVja3BvaW50J1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEhlbHBlciBGdW5jdGlvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIENvbnZlcnRzIGEgRGF0ZSBvYmplY3QgdG8gSVNPIGRhdGUgc3RyaW5nIChZWVlZLU1NLUREKSB3aXRob3V0IHRpbWV6b25lIGNvbnZlcnNpb25cbiAqIFRoaXMgaXMgdGltZXpvbmUtc2FmZTogMjAyNS0wMy0wMSBtaWRuaWdodCBHTVQrNyDihpIgXCIyMDI1LTAzLTAxXCIgKG5vdCBcIjIwMjUtMDItMjhcIiEpXG4gKi9cbmZ1bmN0aW9uIHRvSVNPRGF0ZVN0cmluZyhkYXRlOiBEYXRlKTogc3RyaW5nIHtcbiAgY29uc3QgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKVxuICBjb25zdCBtb250aCA9IFN0cmluZyhkYXRlLmdldE1vbnRoKCkgKyAxKS5wYWRTdGFydCgyLCAnMCcpXG4gIGNvbnN0IGRheSA9IFN0cmluZyhkYXRlLmdldERhdGUoKSkucGFkU3RhcnQoMiwgJzAnKVxuICByZXR1cm4gYCR7eWVhcn0tJHttb250aH0tJHtkYXl9YFxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIENvcmUgRnVuY3Rpb24gMTogQ2FsY3VsYXRlIEJhbGFuY2UgVXAgVG8gRGF0ZVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBhY2NvdW50IGJhbGFuY2UgZnJvbSBhbGwgdHJhbnNhY3Rpb25zIHVwIHRvIChhbmQgaW5jbHVkaW5nKSBhIHNwZWNpZmljIGRhdGVcbiAqIEV4Y2x1ZGVzIGJhbGFuY2UgYWRqdXN0bWVudCB0cmFuc2FjdGlvbnMgZnJvbSB0aGUgY2FsY3VsYXRpb25cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNhbGN1bGF0ZUJhbGFuY2VVcFRvRGF0ZShcbiAgYWNjb3VudElkOiBudW1iZXIsXG4gIHVwVG9EYXRlOiBEYXRlXG4pOiBQcm9taXNlPEJhbGFuY2VDYWxjdWxhdGlvbj4ge1xuICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZVN1cGFiYXNlU2VydmVyQ2xpZW50KClcbiAgdHJ5IHtcbiAgICBjb25zdCB1cFRvRGF0ZVN0ciA9IHRvSVNPRGF0ZVN0cmluZyh1cFRvRGF0ZSlcblxuICAgIC8vIFVzZSB0aGUgZGF0YWJhc2UgZnVuY3Rpb24gZm9yIGFjY3VyYXRlIGNhbGN1bGF0aW9uXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UucnBjKCdjYWxjdWxhdGVfYmFsYW5jZV91cF90b19kYXRlJywge1xuICAgICAgcF9hY2NvdW50X2lkOiBhY2NvdW50SWQsXG4gICAgICBwX3VwX3RvX2RhdGU6IHVwVG9EYXRlU3RyLFxuICAgIH0pXG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNhbGN1bGF0aW5nIGJhbGFuY2U6JywgZXJyb3IpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjYWxjdWxhdGUgYmFsYW5jZTogJHtlcnJvci5tZXNzYWdlfWApXG4gICAgfVxuXG4gICAgLy8gQWxzbyBnZXQgdHJhbnNhY3Rpb24gY291bnQgZm9yIG1ldGFkYXRhXG4gICAgY29uc3QgeyBjb3VudCB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdvcmlnaW5hbF90cmFuc2FjdGlvbicpXG4gICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxuICAgICAgLmVxKCdhY2NvdW50X2lkJywgYWNjb3VudElkKVxuICAgICAgLmx0ZSgndHJhbnNhY3Rpb25fZGF0ZScsIHVwVG9EYXRlU3RyKVxuICAgICAgLmVxKCdpc19iYWxhbmNlX2FkanVzdG1lbnQnLCBmYWxzZSlcblxuICAgIHJldHVybiB7XG4gICAgICBhY2NvdW50X2lkOiBhY2NvdW50SWQsXG4gICAgICB1cF90b19kYXRlOiB1cFRvRGF0ZVN0cixcbiAgICAgIGNhbGN1bGF0ZWRfYmFsYW5jZTogZGF0YSB8fCAwLFxuICAgICAgdHJhbnNhY3Rpb25fY291bnQ6IGNvdW50IHx8IDAsXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGNhbGN1bGF0ZUJhbGFuY2VVcFRvRGF0ZTonLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gQ29yZSBGdW5jdGlvbiAyOiBDcmVhdGUgb3IgVXBkYXRlIEJhbGFuY2UgQWRqdXN0bWVudCBUcmFuc2FjdGlvblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogQ3JlYXRlcyBvciB1cGRhdGVzIGEgYmFsYW5jZSBhZGp1c3RtZW50IHRyYW5zYWN0aW9uIGZvciBhIGNoZWNrcG9pbnRcbiAqIEZvciBub3JtYWwgYWNjb3VudHM6IFBvc2l0aXZlIGFkanVzdG1lbnQgPSBDcmVkaXQgKG1pc3NpbmcgaW5jb21lKSwgTmVnYXRpdmUgPSBEZWJpdCAobWlzc2luZyBleHBlbnNlKVxuICogRm9yIGNyZWRpdCBhY2NvdW50czogUG9zaXRpdmUgYWRqdXN0bWVudCA9IERlYml0IChtaXNzaW5nIGJvcnJvd2luZyksIE5lZ2F0aXZlID0gQ3JlZGl0IChleGNlc3MgZGVidC9wYXltZW50KVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVCYWxhbmNlQWRqdXN0bWVudFRyYW5zYWN0aW9uKFxuICBjaGVja3BvaW50OiBCYWxhbmNlQ2hlY2twb2ludFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlU3VwYWJhc2VTZXJ2ZXJDbGllbnQoKVxuICB0cnkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNoZWNrcG9pbnRfaWQsXG4gICAgICBhY2NvdW50X2lkLFxuICAgICAgY2hlY2twb2ludF9kYXRlLFxuICAgICAgYWRqdXN0bWVudF9hbW91bnQsXG4gICAgfSA9IGNoZWNrcG9pbnRcblxuICAgIC8vIEZldGNoIGFjY291bnQgdG8gY2hlY2sgdHlwZVxuICAgIGNvbnN0IHsgZGF0YTogYWNjb3VudCwgZXJyb3I6IGFjY291bnRFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdhY2NvdW50cycpXG4gICAgICAuc2VsZWN0KCdhY2NvdW50X3R5cGUnKVxuICAgICAgLmVxKCdhY2NvdW50X2lkJywgYWNjb3VudF9pZClcbiAgICAgIC5zaW5nbGUoKVxuXG4gICAgaWYgKGFjY291bnRFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggYWNjb3VudDogJHthY2NvdW50RXJyb3IubWVzc2FnZX1gKVxuICAgIH1cblxuICAgIGNvbnN0IGlzQ3JlZGl0QWNjb3VudCA9IFsnY3JlZGl0X2xpbmUnLCAndGVybV9sb2FuJywgJ2NyZWRpdF9jYXJkJ10uaW5jbHVkZXMoYWNjb3VudC5hY2NvdW50X3R5cGUpXG5cbiAgICAvLyBDaGVjayBpZiBhZGp1c3RtZW50IHRyYW5zYWN0aW9uIGFscmVhZHkgZXhpc3RzXG4gICAgY29uc3QgeyBkYXRhOiBleGlzdGluZywgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnb3JpZ2luYWxfdHJhbnNhY3Rpb24nKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ2NoZWNrcG9pbnRfaWQnLCBjaGVja3BvaW50X2lkKVxuICAgICAgLm1heWJlU2luZ2xlKClcblxuICAgIGlmIChmZXRjaEVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBleGlzdGluZyB0cmFuc2FjdGlvbjogJHtmZXRjaEVycm9yLm1lc3NhZ2V9YClcbiAgICB9XG5cbiAgICAvLyBJZiBhZGp1c3RtZW50IGlzIGVmZmVjdGl2ZWx5IDAgKHdpdGhpbiB0aHJlc2hvbGQpLCBkZWxldGUgZXhpc3RpbmcgdHJhbnNhY3Rpb25cbiAgICBpZiAoTWF0aC5hYnMoYWRqdXN0bWVudF9hbW91bnQpIDwgQ0hFQ0tQT0lOVF9DT05GSUcuUkVDT05DSUxJQVRJT05fVEhSRVNIT0xEKSB7XG4gICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgY29uc3QgeyBlcnJvcjogZGVsZXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ29yaWdpbmFsX3RyYW5zYWN0aW9uJylcbiAgICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgICAuZXEoJ2NoZWNrcG9pbnRfaWQnLCBjaGVja3BvaW50X2lkKVxuXG4gICAgICAgIGlmIChkZWxldGVFcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGRlbGV0ZSBhZGp1c3RtZW50IHRyYW5zYWN0aW9uOiAke2RlbGV0ZUVycm9yLm1lc3NhZ2V9YClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gUHJlcGFyZSB0cmFuc2FjdGlvbiBkYXRhXG4gICAgLy8gTk9URTogRGF0YWJhc2UgY29uc3RyYWludCByZXF1aXJlcyB0aGF0IGVpdGhlciBkZWJpdCBPUiBjcmVkaXQgaXMgTlVMTCwgbm90IDBcbiAgICAvLyBGb3IgY3JlZGl0IGFjY291bnRzLCBpbnZlcnQgdGhlIGRlYml0L2NyZWRpdCBsb2dpY1xuICAgIGNvbnN0IGNyZWRpdEFtb3VudCA9IGlzQ3JlZGl0QWNjb3VudFxuICAgICAgPyAoYWRqdXN0bWVudF9hbW91bnQgPCAwID8gTWF0aC5hYnMoYWRqdXN0bWVudF9hbW91bnQpIDogbnVsbCkgIC8vIEludmVydGVkXG4gICAgICA6IChhZGp1c3RtZW50X2Ftb3VudCA+IDAgPyBhZGp1c3RtZW50X2Ftb3VudCA6IG51bGwpICAgICAgICAgICAgIC8vIE5vcm1hbFxuXG4gICAgY29uc3QgZGViaXRBbW91bnQgPSBpc0NyZWRpdEFjY291bnRcbiAgICAgID8gKGFkanVzdG1lbnRfYW1vdW50ID4gMCA/IGFkanVzdG1lbnRfYW1vdW50IDogbnVsbCkgICAgICAgICAgICAgLy8gSW52ZXJ0ZWRcbiAgICAgIDogKGFkanVzdG1lbnRfYW1vdW50IDwgMCA/IE1hdGguYWJzKGFkanVzdG1lbnRfYW1vdW50KSA6IG51bGwpICAvLyBOb3JtYWxcblxuICAgIGNvbnN0IHRyYW5zYWN0aW9uRGF0YSA9IHtcbiAgICAgIGFjY291bnRfaWQsXG4gICAgICB0cmFuc2FjdGlvbl9kYXRlOiBjaGVja3BvaW50X2RhdGUsICAvLyBBbHJlYWR5IElTTyBkYXRlIHN0cmluZyBmb3JtYXRcbiAgICAgIGRlc2NyaXB0aW9uOiBDSEVDS1BPSU5UX0NPTkZJRy5CQUxBTkNFX0FESlVTVE1FTlRfREVTQ1JJUFRJT04sXG4gICAgICBjcmVkaXRfYW1vdW50OiBjcmVkaXRBbW91bnQsXG4gICAgICBkZWJpdF9hbW91bnQ6IGRlYml0QW1vdW50LFxuICAgICAgY2hlY2twb2ludF9pZCxcbiAgICAgIGlzX2JhbGFuY2VfYWRqdXN0bWVudDogdHJ1ZSxcbiAgICAgIGlzX2ZsYWdnZWQ6IHRydWUsXG4gICAgfVxuXG4gICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgdHJhbnNhY3Rpb25cbiAgICAgIC8vIE5PVEU6IE11c3QgdXNlIG51bGwgKG5vdCAwKSBmb3IgdGhlIHVudXNlZCBhbW91bnQgZmllbGRcbiAgICAgIGNvbnN0IHsgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnb3JpZ2luYWxfdHJhbnNhY3Rpb24nKVxuICAgICAgICAudXBkYXRlKHtcbiAgICAgICAgICBjcmVkaXRfYW1vdW50OiB0cmFuc2FjdGlvbkRhdGEuY3JlZGl0X2Ftb3VudCxcbiAgICAgICAgICBkZWJpdF9hbW91bnQ6IHRyYW5zYWN0aW9uRGF0YS5kZWJpdF9hbW91bnQsXG4gICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KVxuICAgICAgICAuZXEoJ2NoZWNrcG9pbnRfaWQnLCBjaGVja3BvaW50X2lkKVxuXG4gICAgICBpZiAodXBkYXRlRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gdXBkYXRlIGFkanVzdG1lbnQgdHJhbnNhY3Rpb246ICR7dXBkYXRlRXJyb3IubWVzc2FnZX1gKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDcmVhdGUgbmV3IHRyYW5zYWN0aW9uXG4gICAgICAvLyBHZW5lcmF0ZSB1bmlxdWUgdHJhbnNhY3Rpb24gSUQgZm9yIGJhbGFuY2UgYWRqdXN0bWVudFxuICAgICAgY29uc3QgcmF3X3RyYW5zYWN0aW9uX2lkID0gYEJBTC1BREotJHtjaGVja3BvaW50X2lkfWBcblxuICAgICAgY29uc3QgeyBlcnJvcjogaW5zZXJ0RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdvcmlnaW5hbF90cmFuc2FjdGlvbicpXG4gICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgIHJhd190cmFuc2FjdGlvbl9pZDogcmF3X3RyYW5zYWN0aW9uX2lkLFxuICAgICAgICAgIGFjY291bnRfaWQ6IHRyYW5zYWN0aW9uRGF0YS5hY2NvdW50X2lkLFxuICAgICAgICAgIHRyYW5zYWN0aW9uX2RhdGU6IHRyYW5zYWN0aW9uRGF0YS50cmFuc2FjdGlvbl9kYXRlLCAgLy8gQWxyZWFkeSBhIGRhdGUgc3RyaW5nXG4gICAgICAgICAgZGVzY3JpcHRpb246IHRyYW5zYWN0aW9uRGF0YS5kZXNjcmlwdGlvbixcbiAgICAgICAgICBjcmVkaXRfYW1vdW50OiB0cmFuc2FjdGlvbkRhdGEuY3JlZGl0X2Ftb3VudCxcbiAgICAgICAgICBkZWJpdF9hbW91bnQ6IHRyYW5zYWN0aW9uRGF0YS5kZWJpdF9hbW91bnQsXG4gICAgICAgICAgdHJhbnNhY3Rpb25fc291cmNlOiAnYXV0b19hZGp1c3RtZW50JywgIC8vIE1hcmsgYXMgc3lzdGVtLWdlbmVyYXRlZCBhZGp1c3RtZW50XG4gICAgICAgICAgY2hlY2twb2ludF9pZDogdHJhbnNhY3Rpb25EYXRhLmNoZWNrcG9pbnRfaWQsXG4gICAgICAgICAgaXNfYmFsYW5jZV9hZGp1c3RtZW50OiB0cmFuc2FjdGlvbkRhdGEuaXNfYmFsYW5jZV9hZGp1c3RtZW50LFxuICAgICAgICAgIGlzX2ZsYWdnZWQ6IHRyYW5zYWN0aW9uRGF0YS5pc19mbGFnZ2VkLFxuICAgICAgICB9KVxuXG4gICAgICBpZiAoaW5zZXJ0RXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIGFkanVzdG1lbnQgdHJhbnNhY3Rpb246ICR7aW5zZXJ0RXJyb3IubWVzc2FnZX1gKVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBjcmVhdGVPclVwZGF0ZUJhbGFuY2VBZGp1c3RtZW50VHJhbnNhY3Rpb246JywgZXJyb3IpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIENvcmUgRnVuY3Rpb24gMzogQ3JlYXRlIG9yIFVwZGF0ZSBDaGVja3BvaW50XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBDcmVhdGVzIG9yIHVwZGF0ZXMgYSBiYWxhbmNlIGNoZWNrcG9pbnQgZm9yIGFuIGFjY291bnRcbiAqIFRoaXMgaXMgdGhlIG1haW4gZW50cnkgcG9pbnQgZm9yIGNoZWNrcG9pbnQgbWFuYWdlbWVudFxuICpcbiAqIElNUE9SVEFOVDogQWZ0ZXIgY3JlYXRpbmcvdXBkYXRpbmcsIHRoaXMgdHJpZ2dlcnMgcmVjYWxjdWxhdGlvbiBvZiBBTEwgY2hlY2twb2ludHNcbiAqIHRvIGVuc3VyZSBhZGp1c3RtZW50cyBhcmUgY29ycmVjdCByZWdhcmRsZXNzIG9mIGNyZWF0aW9uIG9yZGVyXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZUNoZWNrcG9pbnQoXG4gIHBhcmFtczogQ3JlYXRlT3JVcGRhdGVDaGVja3BvaW50UGFyYW1zXG4pOiBQcm9taXNlPEJhbGFuY2VDaGVja3BvaW50PiB7XG4gIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlU3VwYWJhc2VTZXJ2ZXJDbGllbnQoKVxuXG4gIGNvbnN0IHtcbiAgICBhY2NvdW50X2lkLFxuICAgIGNoZWNrcG9pbnRfZGF0ZSxcbiAgICBkZWNsYXJlZF9iYWxhbmNlLFxuICAgIG5vdGVzID0gbnVsbCxcbiAgICBpbXBvcnRfYmF0Y2hfaWQgPSBudWxsLFxuICAgIHVzZXJfaWQgPSBudWxsLFxuICB9ID0gcGFyYW1zXG5cbiAgdHJ5IHtcbiAgICAvLyBTdGVwIDE6IENoZWNrIGlmIGNoZWNrcG9pbnQgYWxyZWFkeSBleGlzdHMgZm9yIHRoaXMgYWNjb3VudCwgZGF0ZSwgQU5EIGltcG9ydF9iYXRjaF9pZFxuICAgIC8vIEZvciBpbXBvcnQgY2hlY2twb2ludHM6IGVhY2ggaW1wb3J0IGJhdGNoIGdldHMgaXRzIG93biBjaGVja3BvaW50IChldmVuIG9uIHNhbWUgZGF0ZSlcbiAgICAvLyBGb3IgbWFudWFsIGNoZWNrcG9pbnRzIChpbXBvcnRfYmF0Y2hfaWQgPSBudWxsKTogb25seSBvbmUgcGVyIGRhdGVcbiAgICBjb25zdCBjaGVja3BvaW50RGF0ZVN0ciA9IHRvSVNPRGF0ZVN0cmluZyhjaGVja3BvaW50X2RhdGUpXG5cbiAgICBsZXQgZXhpc3RpbmdRdWVyeSA9IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnYmFsYW5jZV9jaGVja3BvaW50cycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgnYWNjb3VudF9pZCcsIGFjY291bnRfaWQpXG4gICAgICAuZXEoJ2NoZWNrcG9pbnRfZGF0ZScsIGNoZWNrcG9pbnREYXRlU3RyKVxuXG4gICAgLy8gSWYgdGhpcyBpcyBhbiBpbXBvcnQgY2hlY2twb2ludCwgY2hlY2sgZm9yIGV4YWN0IG1hdGNoIChzYW1lIGJhdGNoKVxuICAgIC8vIElmIHRoaXMgaXMgYSBtYW51YWwgY2hlY2twb2ludCwgY2hlY2sgZm9yIGFueSBtYW51YWwgY2hlY2twb2ludCBvbiB0aGF0IGRhdGVcbiAgICBpZiAoaW1wb3J0X2JhdGNoX2lkICE9PSBudWxsKSB7XG4gICAgICBleGlzdGluZ1F1ZXJ5ID0gZXhpc3RpbmdRdWVyeS5lcSgnaW1wb3J0X2JhdGNoX2lkJywgaW1wb3J0X2JhdGNoX2lkKVxuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZ1F1ZXJ5ID0gZXhpc3RpbmdRdWVyeS5pcygnaW1wb3J0X2JhdGNoX2lkJywgbnVsbClcbiAgICB9XG5cbiAgICBjb25zdCB7IGRhdGE6IGV4aXN0aW5nLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgZXhpc3RpbmdRdWVyeS5tYXliZVNpbmdsZSgpXG5cbiAgICBpZiAoZmV0Y2hFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY2hlY2sgZm9yIGV4aXN0aW5nIGNoZWNrcG9pbnQ6ICR7ZmV0Y2hFcnJvci5tZXNzYWdlfWApXG4gICAgfVxuXG4gICAgbGV0IGNoZWNrcG9pbnQ6IEJhbGFuY2VDaGVja3BvaW50XG5cbiAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBjaGVja3BvaW50IChzYW1lIGRhdGUgKyBzYW1lIGltcG9ydF9iYXRjaF9pZClcbiAgICAgIGNvbnN0IHsgZGF0YTogdXBkYXRlZCwgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnYmFsYW5jZV9jaGVja3BvaW50cycpXG4gICAgICAgIC51cGRhdGUoe1xuICAgICAgICAgIGRlY2xhcmVkX2JhbGFuY2UsXG4gICAgICAgICAgbm90ZXMsXG4gICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KVxuICAgICAgICAuZXEoJ2NoZWNrcG9pbnRfaWQnLCBleGlzdGluZy5jaGVja3BvaW50X2lkKVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgIGlmICh1cGRhdGVFcnJvciB8fCAhdXBkYXRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB1cGRhdGUgY2hlY2twb2ludDogJHt1cGRhdGVFcnJvcj8ubWVzc2FnZSB8fCAnTm8gZGF0YSByZXR1cm5lZCd9YClcbiAgICAgIH1cblxuICAgICAgY2hlY2twb2ludCA9IHVwZGF0ZWRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ3JlYXRlIG5ldyBjaGVja3BvaW50IChjYWxjdWxhdGVkIHZhbHVlcyB3aWxsIGJlIHNldCBieSByZWNhbGN1bGF0aW9uKVxuICAgICAgY29uc3QgeyBkYXRhOiBjcmVhdGVkLCBlcnJvcjogaW5zZXJ0RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdiYWxhbmNlX2NoZWNrcG9pbnRzJylcbiAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgYWNjb3VudF9pZCxcbiAgICAgICAgICBjaGVja3BvaW50X2RhdGU6IGNoZWNrcG9pbnREYXRlU3RyLCAgLy8gQWxyZWFkeSBjb252ZXJ0ZWQgdG8gZGF0ZSBzdHJpbmdcbiAgICAgICAgICBkZWNsYXJlZF9iYWxhbmNlLFxuICAgICAgICAgIGNhbGN1bGF0ZWRfYmFsYW5jZTogMCwgLy8gV2lsbCBiZSByZWNhbGN1bGF0ZWRcbiAgICAgICAgICBhZGp1c3RtZW50X2Ftb3VudDogMCwgICAvLyBXaWxsIGJlIHJlY2FsY3VsYXRlZFxuICAgICAgICAgIGlzX3JlY29uY2lsZWQ6IGZhbHNlLCAgIC8vIFdpbGwgYmUgcmVjYWxjdWxhdGVkXG4gICAgICAgICAgbm90ZXMsXG4gICAgICAgICAgaW1wb3J0X2JhdGNoX2lkLFxuICAgICAgICAgIGNyZWF0ZWRfYnlfdXNlcl9pZDogdXNlcl9pZCxcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBpZiAoaW5zZXJ0RXJyb3IgfHwgIWNyZWF0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIGNoZWNrcG9pbnQ6ICR7aW5zZXJ0RXJyb3I/Lm1lc3NhZ2UgfHwgJ05vIGRhdGEgcmV0dXJuZWQnfWApXG4gICAgICB9XG5cbiAgICAgIGNoZWNrcG9pbnQgPSBjcmVhdGVkXG4gICAgfVxuXG4gICAgLy8gU3RlcCAyOiBSZWNhbGN1bGF0ZSBBTEwgY2hlY2twb2ludHMgZm9yIHRoaXMgYWNjb3VudFxuICAgIC8vIFRoaXMgZW5zdXJlcyBhZGp1c3RtZW50cyBhcmUgY29ycmVjdCByZWdhcmRsZXNzIG9mIGNyZWF0aW9uIG9yZGVyXG4gICAgYXdhaXQgcmVjYWxjdWxhdGVBbGxDaGVja3BvaW50cyh7IGFjY291bnRfaWQgfSlcblxuICAgIC8vIFN0ZXAgMzogRmV0Y2ggdGhlIHVwZGF0ZWQgY2hlY2twb2ludCBhZnRlciByZWNhbGN1bGF0aW9uXG4gICAgY29uc3QgeyBkYXRhOiBmaW5hbENoZWNrcG9pbnQsIGVycm9yOiBmaW5hbEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2JhbGFuY2VfY2hlY2twb2ludHMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ2NoZWNrcG9pbnRfaWQnLCBjaGVja3BvaW50LmNoZWNrcG9pbnRfaWQpXG4gICAgICAuc2luZ2xlKClcblxuICAgIGlmIChmaW5hbEVycm9yIHx8ICFmaW5hbENoZWNrcG9pbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIHJlY2FsY3VsYXRlZCBjaGVja3BvaW50OiAke2ZpbmFsRXJyb3I/Lm1lc3NhZ2V9YClcbiAgICB9XG5cbiAgICAvLyBTdGVwIDQ6IFVwZGF0ZSBhY2NvdW50IG9wZW5pbmcgYmFsYW5jZSBkYXRlXG4gICAgYXdhaXQgdXBkYXRlQWNjb3VudE9wZW5pbmdCYWxhbmNlRGF0ZShhY2NvdW50X2lkKVxuXG4gICAgcmV0dXJuIGZpbmFsQ2hlY2twb2ludFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGNyZWF0ZU9yVXBkYXRlQ2hlY2twb2ludDonLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gQ29yZSBGdW5jdGlvbiAzOiBSZWNhbGN1bGF0ZSBBbGwgQ2hlY2twb2ludHNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIFJlY2FsY3VsYXRlcyBhbGwgY2hlY2twb2ludHMgZm9yIGFuIGFjY291bnQgSU4gQ0hST05PTE9HSUNBTCBPUkRFUlxuICogVGhpcyBlbnN1cmVzIGFkanVzdG1lbnRzIGFyZSBjYWxjdWxhdGVkIGNvcnJlY3RseSByZWdhcmRsZXNzIG9mIGNyZWF0aW9uIG9yZGVyXG4gKlxuICogS2V5IGFsZ29yaXRobTpcbiAqIDEuIFByb2Nlc3MgYWxsIGNoZWNrcG9pbnRzIHNvcnRlZCBieSBjaGVja3BvaW50X2RhdGUgQVNDXG4gKiAyLiBGb3IgZWFjaCBjaGVja3BvaW50LCBjYWxjdWxhdGUgYmFsYW5jZSBmcm9tOlxuICogICAgLSBBbGwgbm9uLWFkanVzdG1lbnQgdHJhbnNhY3Rpb25zIHVwIHRvIGNoZWNrcG9pbnQgZGF0ZVxuICogICAgLSBBZGp1c3RtZW50IHRyYW5zYWN0aW9ucyBmcm9tIFBSRVZJT1VTIGNoZWNrcG9pbnRzIG9ubHkgKGJ5IGRhdGUsIG5vdCBjcmVhdGlvbiB0aW1lKVxuICogMy4gVGhpcyBlbnN1cmVzIHRoYXQgYSBjaGVja3BvaW50IGRhdGVkIE9jdCA1IGNyZWF0ZWQgQUZURVIgYSBjaGVja3BvaW50IGRhdGVkIE9jdCAxNVxuICogICAgd2lsbCBoYXZlIHRoZSBjb3JyZWN0IGFkanVzdG1lbnQgYW1vdW50XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWNhbGN1bGF0ZUFsbENoZWNrcG9pbnRzKFxuICBwYXJhbXM6IFJlY2FsY3VsYXRlQ2hlY2twb2ludHNQYXJhbXNcbik6IFByb21pc2U8Q2hlY2twb2ludFJlY2FsY3VsYXRpb25SZXN1bHRbXT4ge1xuICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZVN1cGFiYXNlU2VydmVyQ2xpZW50KClcbiAgY29uc3QgeyBhY2NvdW50X2lkLCBmcm9tX2RhdGUsIHRvX2RhdGUsIGNoZWNrcG9pbnRfaWRzIH0gPSBwYXJhbXNcblxuICB0cnkge1xuICAgIC8vIEZldGNoIGFjY291bnQgdG8gY2hlY2sgdHlwZSAoZm9yIGNyZWRpdCBhY2NvdW50IGxvZ2ljKVxuICAgIGNvbnN0IHsgZGF0YTogYWNjb3VudCwgZXJyb3I6IGFjY291bnRFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdhY2NvdW50cycpXG4gICAgICAuc2VsZWN0KCdhY2NvdW50X3R5cGUnKVxuICAgICAgLmVxKCdhY2NvdW50X2lkJywgYWNjb3VudF9pZClcbiAgICAgIC5zaW5nbGUoKVxuXG4gICAgaWYgKGFjY291bnRFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggYWNjb3VudDogJHthY2NvdW50RXJyb3IubWVzc2FnZX1gKVxuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBjcmVkaXQtdHlwZSBhY2NvdW50ICh3aGVyZSBwb3NpdGl2ZSBiYWxhbmNlID0gZGVidCBvd2VkKVxuICAgIGNvbnN0IGlzQ3JlZGl0QWNjb3VudCA9IFsnY3JlZGl0X2xpbmUnLCAndGVybV9sb2FuJywgJ2NyZWRpdF9jYXJkJ10uaW5jbHVkZXMoYWNjb3VudC5hY2NvdW50X3R5cGUpXG5cbiAgICAvLyBGZXRjaCBBTEwgY2hlY2twb2ludHMgZm9yIHRoZSBhY2NvdW50IGluIGNocm9ub2xvZ2ljYWwgb3JkZXJcbiAgICAvLyBXZSBuZWVkIHRvIHJlY2FsY3VsYXRlIGFsbCwgbm90IGp1c3QgZmlsdGVyZWQgb25lcywgdG8gZ2V0IGNvcnJlY3QgYWRqdXN0bWVudCBjaGFpblxuICAgIGNvbnN0IHsgZGF0YTogYWxsQ2hlY2twb2ludHMsIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2JhbGFuY2VfY2hlY2twb2ludHMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ2FjY291bnRfaWQnLCBhY2NvdW50X2lkKVxuICAgICAgLm9yZGVyKCdjaGVja3BvaW50X2RhdGUnLCB7IGFzY2VuZGluZzogdHJ1ZSB9KVxuICAgICAgLm9yZGVyKCdjaGVja3BvaW50X2lkJywgeyBhc2NlbmRpbmc6IHRydWUgfSkgLy8gVGllLWJyZWFrZXIgZm9yIHNhbWUgZGF0ZXNcblxuICAgIGlmIChmZXRjaEVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBjaGVja3BvaW50czogJHtmZXRjaEVycm9yLm1lc3NhZ2V9YClcbiAgICB9XG5cbiAgICBpZiAoIWFsbENoZWNrcG9pbnRzIHx8IGFsbENoZWNrcG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGNoZWNrcG9pbnRzIHRvIGFjdHVhbGx5IHJlY2FsY3VsYXRlIChmb3IgcmV0dXJuIHJlc3VsdHMpXG4gICAgbGV0IGNoZWNrcG9pbnRzVG9SZWNhbGN1bGF0ZSA9IGFsbENoZWNrcG9pbnRzXG4gICAgaWYgKGZyb21fZGF0ZSB8fCB0b19kYXRlIHx8IGNoZWNrcG9pbnRfaWRzKSB7XG4gICAgICBjaGVja3BvaW50c1RvUmVjYWxjdWxhdGUgPSBhbGxDaGVja3BvaW50cy5maWx0ZXIoY3AgPT4ge1xuICAgICAgICBjb25zdCBjcERhdGUgPSBuZXcgRGF0ZShjcC5jaGVja3BvaW50X2RhdGUpXG4gICAgICAgIGlmIChmcm9tX2RhdGUgJiYgY3BEYXRlIDwgZnJvbV9kYXRlKSByZXR1cm4gZmFsc2VcbiAgICAgICAgaWYgKHRvX2RhdGUgJiYgY3BEYXRlID4gdG9fZGF0ZSkgcmV0dXJuIGZhbHNlXG4gICAgICAgIGlmIChjaGVja3BvaW50X2lkcyAmJiAhY2hlY2twb2ludF9pZHMuaW5jbHVkZXMoY3AuY2hlY2twb2ludF9pZCkpIHJldHVybiBmYWxzZVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHRzOiBDaGVja3BvaW50UmVjYWxjdWxhdGlvblJlc3VsdFtdID0gW11cblxuICAgIC8vIFByb2Nlc3MgZWFjaCBjaGVja3BvaW50IGluIGNocm9ub2xvZ2ljYWwgb3JkZXJcbiAgICBmb3IgKGNvbnN0IGNoZWNrcG9pbnQgb2YgYWxsQ2hlY2twb2ludHMpIHtcbiAgICAgIC8vIGNoZWNrcG9pbnRfZGF0ZSBpcyBhbHJlYWR5IGEgZGF0ZSBzdHJpbmcgZnJvbSBkYXRhYmFzZVxuICAgICAgY29uc3QgY2hlY2twb2ludERhdGVTdHIgPSBjaGVja3BvaW50LmNoZWNrcG9pbnRfZGF0ZVxuXG4gICAgICAvLyBDYWxjdWxhdGUgYmFsYW5jZSBmcm9tOlxuICAgICAgLy8gMS4gTm9uLWFkanVzdG1lbnQgdHJhbnNhY3Rpb25zIHVwIHRvIGNoZWNrcG9pbnQgZGF0ZVxuICAgICAgLy8gRmV0Y2ggQUxMIHRyYW5zYWN0aW9ucyB1c2luZyBwYWdpbmF0aW9uIHRvIGF2b2lkIDEwMDAgcm93IGxpbWl0XG4gICAgICBsZXQgdG90YWxDcmVkaXRzID0gMFxuICAgICAgbGV0IHRvdGFsRGViaXRzID0gMFxuICAgICAgbGV0IHBhZ2UgPSAwXG4gICAgICBjb25zdCBwYWdlU2l6ZSA9IDEwMDBcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiBub25BZGp1c3RtZW50VHhzLCBlcnJvcjogdHhFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgnb3JpZ2luYWxfdHJhbnNhY3Rpb24nKVxuICAgICAgICAgIC5zZWxlY3QoJ2NyZWRpdF9hbW91bnQsIGRlYml0X2Ftb3VudCcpXG4gICAgICAgICAgLmVxKCdhY2NvdW50X2lkJywgYWNjb3VudF9pZClcbiAgICAgICAgICAuZXEoJ2lzX2JhbGFuY2VfYWRqdXN0bWVudCcsIGZhbHNlKVxuICAgICAgICAgIC5sdGUoJ3RyYW5zYWN0aW9uX2RhdGUnLCBjaGVja3BvaW50RGF0ZVN0cilcbiAgICAgICAgICAucmFuZ2UocGFnZSAqIHBhZ2VTaXplLCAocGFnZSArIDEpICogcGFnZVNpemUgLSAxKVxuXG4gICAgICAgIGlmICh0eEVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggdHJhbnNhY3Rpb25zOiAke3R4RXJyb3IubWVzc2FnZX1gKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFub25BZGp1c3RtZW50VHhzIHx8IG5vbkFkanVzdG1lbnRUeHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN1bSB0aGlzIHBhZ2Ugb2YgdHJhbnNhY3Rpb25zXG4gICAgICAgIGZvciAoY29uc3QgdHggb2Ygbm9uQWRqdXN0bWVudFR4cykge1xuICAgICAgICAgIGlmICh0eC5jcmVkaXRfYW1vdW50KSB0b3RhbENyZWRpdHMgKz0gdHguY3JlZGl0X2Ftb3VudFxuICAgICAgICAgIGlmICh0eC5kZWJpdF9hbW91bnQpIHRvdGFsRGViaXRzICs9IHR4LmRlYml0X2Ftb3VudFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vbkFkanVzdG1lbnRUeHMubGVuZ3RoIDwgcGFnZVNpemUpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgcGFnZSsrXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIEFkanVzdG1lbnQgdHJhbnNhY3Rpb25zIGZyb20gUFJFVklPVVMgY2hlY2twb2ludHMgb25seSAoYnkgZGF0ZSlcbiAgICAgIC8vIEdldCBjaGVja3BvaW50cyB3aXRoIGVhcmxpZXIgZGF0ZXNcbiAgICAgIC8vIGNoZWNrcG9pbnRfZGF0ZSBpcyBhbHJlYWR5IGEgZGF0ZSBzdHJpbmcsIGNhbiBjb21wYXJlIGRpcmVjdGx5XG4gICAgICBjb25zdCBwcmV2aW91c0NoZWNrcG9pbnRzID0gYWxsQ2hlY2twb2ludHMuZmlsdGVyKGNwID0+XG4gICAgICAgIGNwLmNoZWNrcG9pbnRfZGF0ZSA8IGNoZWNrcG9pbnREYXRlU3RyXG4gICAgICApXG5cbiAgICAgIGlmIChwcmV2aW91c0NoZWNrcG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNDaGVja3BvaW50SWRzID0gcHJldmlvdXNDaGVja3BvaW50cy5tYXAoY3AgPT4gY3AuY2hlY2twb2ludF9pZClcblxuICAgICAgICBjb25zdCB7IGRhdGE6IHByZXZpb3VzQWRqdXN0bWVudHMsIGVycm9yOiBhZGpFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgnb3JpZ2luYWxfdHJhbnNhY3Rpb24nKVxuICAgICAgICAgIC5zZWxlY3QoJ2NyZWRpdF9hbW91bnQsIGRlYml0X2Ftb3VudCcpXG4gICAgICAgICAgLmVxKCdhY2NvdW50X2lkJywgYWNjb3VudF9pZClcbiAgICAgICAgICAuZXEoJ2lzX2JhbGFuY2VfYWRqdXN0bWVudCcsIHRydWUpXG4gICAgICAgICAgLmluKCdjaGVja3BvaW50X2lkJywgcHJldmlvdXNDaGVja3BvaW50SWRzKVxuXG4gICAgICAgIGlmIChhZGpFcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIHByZXZpb3VzIGFkanVzdG1lbnRzOiAke2FkakVycm9yLm1lc3NhZ2V9YClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN1bSBwcmV2aW91cyBhZGp1c3RtZW50c1xuICAgICAgICBpZiAocHJldmlvdXNBZGp1c3RtZW50cyAmJiBwcmV2aW91c0FkanVzdG1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHR4IG9mIHByZXZpb3VzQWRqdXN0bWVudHMpIHtcbiAgICAgICAgICAgIGlmICh0eC5jcmVkaXRfYW1vdW50KSB0b3RhbENyZWRpdHMgKz0gdHguY3JlZGl0X2Ftb3VudFxuICAgICAgICAgICAgaWYgKHR4LmRlYml0X2Ftb3VudCkgdG90YWxEZWJpdHMgKz0gdHguZGViaXRfYW1vdW50XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld0NhbGN1bGF0ZWRCYWxhbmNlID0gdG90YWxDcmVkaXRzIC0gdG90YWxEZWJpdHNcbiAgICAgIGNvbnN0IG5ld0FkanVzdG1lbnRBbW91bnQgPSBjaGVja3BvaW50LmRlY2xhcmVkX2JhbGFuY2UgLSBuZXdDYWxjdWxhdGVkQmFsYW5jZVxuICAgICAgY29uc3QgbmV3SXNSZWNvbmNpbGVkID0gTWF0aC5hYnMobmV3QWRqdXN0bWVudEFtb3VudCkgPCBDSEVDS1BPSU5UX0NPTkZJRy5SRUNPTkNJTElBVElPTl9USFJFU0hPTERcblxuICAgICAgLy8gU3RvcmUgb2xkIHZhbHVlcyBmb3IgcmVzdWx0c1xuICAgICAgY29uc3Qgb2xkQ2FsY3VsYXRlZEJhbGFuY2UgPSBjaGVja3BvaW50LmNhbGN1bGF0ZWRfYmFsYW5jZVxuICAgICAgY29uc3Qgb2xkQWRqdXN0bWVudEFtb3VudCA9IGNoZWNrcG9pbnQuYWRqdXN0bWVudF9hbW91bnRcbiAgICAgIGNvbnN0IG9sZElzUmVjb25jaWxlZCA9IGNoZWNrcG9pbnQuaXNfcmVjb25jaWxlZFxuXG4gICAgICAvLyBVcGRhdGUgY2hlY2twb2ludCByZWNvcmRcbiAgICAgIGNvbnN0IHsgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnYmFsYW5jZV9jaGVja3BvaW50cycpXG4gICAgICAgIC51cGRhdGUoe1xuICAgICAgICAgIGNhbGN1bGF0ZWRfYmFsYW5jZTogbmV3Q2FsY3VsYXRlZEJhbGFuY2UsXG4gICAgICAgICAgYWRqdXN0bWVudF9hbW91bnQ6IG5ld0FkanVzdG1lbnRBbW91bnQsXG4gICAgICAgICAgaXNfcmVjb25jaWxlZDogbmV3SXNSZWNvbmNpbGVkLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSlcbiAgICAgICAgLmVxKCdjaGVja3BvaW50X2lkJywgY2hlY2twb2ludC5jaGVja3BvaW50X2lkKVxuXG4gICAgICBpZiAodXBkYXRlRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gdXBkYXRlIGNoZWNrcG9pbnQgJHtjaGVja3BvaW50LmNoZWNrcG9pbnRfaWR9OiAke3VwZGF0ZUVycm9yLm1lc3NhZ2V9YClcbiAgICAgIH1cblxuICAgICAgLy8gRGVsZXRlIG9sZCBhZGp1c3RtZW50IHRyYW5zYWN0aW9uXG4gICAgICBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnb3JpZ2luYWxfdHJhbnNhY3Rpb24nKVxuICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgLmVxKCdjaGVja3BvaW50X2lkJywgY2hlY2twb2ludC5jaGVja3BvaW50X2lkKVxuICAgICAgICAuZXEoJ2lzX2JhbGFuY2VfYWRqdXN0bWVudCcsIHRydWUpXG5cbiAgICAgIC8vIENyZWF0ZSBuZXcgYWRqdXN0bWVudCB0cmFuc2FjdGlvbiBpZiBuZWVkZWRcbiAgICAgIGlmIChNYXRoLmFicyhuZXdBZGp1c3RtZW50QW1vdW50KSA+PSBDSEVDS1BPSU5UX0NPTkZJRy5SRUNPTkNJTElBVElPTl9USFJFU0hPTEQpIHtcbiAgICAgICAgY29uc3QgcmF3X3RyYW5zYWN0aW9uX2lkID0gYEJBTC1BREotJHtjaGVja3BvaW50LmNoZWNrcG9pbnRfaWR9YFxuXG4gICAgICAgIC8vIEZvciBjcmVkaXQgYWNjb3VudHMgKGNyZWRpdF9saW5lLCB0ZXJtX2xvYW4sIGNyZWRpdF9jYXJkKTpcbiAgICAgICAgLy8gLSBQb3NpdGl2ZSBiYWxhbmNlID0gZGVidCBvd2VkIChpbmNyZWFzZXMgd2l0aCBERUJJVFMsIG5vdCBjcmVkaXRzKVxuICAgICAgICAvLyAtIFBvc2l0aXZlIGFkanVzdG1lbnQgbWVhbnMgbmVlZCBtb3JlIGRlYnQg4oaSIERFQklUXG4gICAgICAgIC8vIC0gTmVnYXRpdmUgYWRqdXN0bWVudCBtZWFucyB0b28gbXVjaCBkZWJ0IOKGkiBDUkVESVQgKHBheW1lbnQpXG4gICAgICAgIC8vIEZvciBub3JtYWwgYWNjb3VudHMgKGJhbmssIGNhc2gpOlxuICAgICAgICAvLyAtIFBvc2l0aXZlIGJhbGFuY2UgPSBhc3NldCAoaW5jcmVhc2VzIHdpdGggQ1JFRElUUylcbiAgICAgICAgLy8gLSBQb3NpdGl2ZSBhZGp1c3RtZW50IG1lYW5zIG1pc3NpbmcgaW5jb21lIOKGkiBDUkVESVRcbiAgICAgICAgLy8gLSBOZWdhdGl2ZSBhZGp1c3RtZW50IG1lYW5zIG1pc3NpbmcgZXhwZW5zZSDihpIgREVCSVRcbiAgICAgICAgY29uc3QgY3JlZGl0QW1vdW50ID0gaXNDcmVkaXRBY2NvdW50XG4gICAgICAgICAgPyAobmV3QWRqdXN0bWVudEFtb3VudCA8IDAgPyBNYXRoLmFicyhuZXdBZGp1c3RtZW50QW1vdW50KSA6IG51bGwpICAvLyBJbnZlcnRlZFxuICAgICAgICAgIDogKG5ld0FkanVzdG1lbnRBbW91bnQgPiAwID8gbmV3QWRqdXN0bWVudEFtb3VudCA6IG51bGwpICAgICAgICAgICAgIC8vIE5vcm1hbFxuXG4gICAgICAgIGNvbnN0IGRlYml0QW1vdW50ID0gaXNDcmVkaXRBY2NvdW50XG4gICAgICAgICAgPyAobmV3QWRqdXN0bWVudEFtb3VudCA+IDAgPyBuZXdBZGp1c3RtZW50QW1vdW50IDogbnVsbCkgICAgICAgICAgICAgLy8gSW52ZXJ0ZWRcbiAgICAgICAgICA6IChuZXdBZGp1c3RtZW50QW1vdW50IDwgMCA/IE1hdGguYWJzKG5ld0FkanVzdG1lbnRBbW91bnQpIDogbnVsbCkgIC8vIE5vcm1hbFxuXG4gICAgICAgIGNvbnN0IHsgZXJyb3I6IGluc2VydEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdvcmlnaW5hbF90cmFuc2FjdGlvbicpXG4gICAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgICByYXdfdHJhbnNhY3Rpb25faWQsXG4gICAgICAgICAgICBhY2NvdW50X2lkLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25fZGF0ZTogY2hlY2twb2ludERhdGVTdHIsICAvLyBBbHJlYWR5IGEgZGF0ZSBzdHJpbmdcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBDSEVDS1BPSU5UX0NPTkZJRy5CQUxBTkNFX0FESlVTVE1FTlRfREVTQ1JJUFRJT04sXG4gICAgICAgICAgICBjcmVkaXRfYW1vdW50OiBjcmVkaXRBbW91bnQsXG4gICAgICAgICAgICBkZWJpdF9hbW91bnQ6IGRlYml0QW1vdW50LFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25fc291cmNlOiAnYXV0b19hZGp1c3RtZW50JyxcbiAgICAgICAgICAgIGNoZWNrcG9pbnRfaWQ6IGNoZWNrcG9pbnQuY2hlY2twb2ludF9pZCxcbiAgICAgICAgICAgIGlzX2JhbGFuY2VfYWRqdXN0bWVudDogdHJ1ZSxcbiAgICAgICAgICAgIGlzX2ZsYWdnZWQ6IHRydWUsXG4gICAgICAgICAgfSlcblxuICAgICAgICBpZiAoaW5zZXJ0RXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgYWRqdXN0bWVudCB0cmFuc2FjdGlvbjogJHtpbnNlcnRFcnJvci5tZXNzYWdlfWApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWRkIHRvIHJlc3VsdHMgaWYgdGhpcyBjaGVja3BvaW50IHdhcyByZXF1ZXN0ZWQgZm9yIHJlY2FsY3VsYXRpb25cbiAgICAgIGlmIChjaGVja3BvaW50c1RvUmVjYWxjdWxhdGUuZmluZChjcCA9PiBjcC5jaGVja3BvaW50X2lkID09PSBjaGVja3BvaW50LmNoZWNrcG9pbnRfaWQpKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgY2hlY2twb2ludF9pZDogY2hlY2twb2ludC5jaGVja3BvaW50X2lkLFxuICAgICAgICAgIG9sZF9jYWxjdWxhdGVkX2JhbGFuY2U6IG9sZENhbGN1bGF0ZWRCYWxhbmNlLFxuICAgICAgICAgIG5ld19jYWxjdWxhdGVkX2JhbGFuY2U6IG5ld0NhbGN1bGF0ZWRCYWxhbmNlLFxuICAgICAgICAgIG9sZF9hZGp1c3RtZW50X2Ftb3VudDogb2xkQWRqdXN0bWVudEFtb3VudCxcbiAgICAgICAgICBuZXdfYWRqdXN0bWVudF9hbW91bnQ6IG5ld0FkanVzdG1lbnRBbW91bnQsXG4gICAgICAgICAgb2xkX2lzX3JlY29uY2lsZWQ6IG9sZElzUmVjb25jaWxlZCxcbiAgICAgICAgICBuZXdfaXNfcmVjb25jaWxlZDogbmV3SXNSZWNvbmNpbGVkLFxuICAgICAgICAgIGFkanVzdG1lbnRfdHJhbnNhY3Rpb25fdXBkYXRlZDogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgYWNjb3VudCBvcGVuaW5nIGJhbGFuY2UgZGF0ZVxuICAgIGF3YWl0IHVwZGF0ZUFjY291bnRPcGVuaW5nQmFsYW5jZURhdGUoYWNjb3VudF9pZClcblxuICAgIHJldHVybiByZXN1bHRzXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gcmVjYWxjdWxhdGVBbGxDaGVja3BvaW50czonLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gQ29yZSBGdW5jdGlvbiA1OiBVcGRhdGUgQWNjb3VudCBPcGVuaW5nIEJhbGFuY2UgRGF0ZVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogVXBkYXRlcyBhY2NvdW50IG9wZW5pbmcgYmFsYW5jZSBkYXRlIHRvIGJlIGJlZm9yZSB0aGUgZWFybGllc3QgdHJhbnNhY3Rpb25cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUFjY291bnRPcGVuaW5nQmFsYW5jZURhdGUoXG4gIGFjY291bnRJZDogbnVtYmVyXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVTdXBhYmFzZVNlcnZlckNsaWVudCgpXG4gIHRyeSB7XG4gICAgLy8gVXNlIHRoZSBkYXRhYmFzZSBmdW5jdGlvbiBmb3IgYWNjdXJhdGUgY2FsY3VsYXRpb25cbiAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5ycGMoJ3VwZGF0ZV9hY2NvdW50X29wZW5pbmdfYmFsYW5jZV9kYXRlJywge1xuICAgICAgcF9hY2NvdW50X2lkOiBhY2NvdW50SWQsXG4gICAgfSlcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gdXBkYXRlIGFjY291bnQgb3BlbmluZyBiYWxhbmNlIGRhdGU6ICR7ZXJyb3IubWVzc2FnZX1gKVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiB1cGRhdGVBY2NvdW50T3BlbmluZ0JhbGFuY2VEYXRlOicsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBIZWxwZXIgRnVuY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBHZXQgYWxsIGNoZWNrcG9pbnRzIGZvciBhbiBhY2NvdW50XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBY2NvdW50Q2hlY2twb2ludHMoXG4gIGFjY291bnRJZDogbnVtYmVyLFxuICBvcHRpb25zPzoge1xuICAgIGluY2x1ZGVSZWNvbmNpbGVkPzogYm9vbGVhblxuICAgIG9yZGVyQnk/OiAnZGF0ZV9hc2MnIHwgJ2RhdGVfZGVzYydcbiAgICBsaW1pdD86IG51bWJlclxuICAgIG9mZnNldD86IG51bWJlclxuICB9XG4pOiBQcm9taXNlPEJhbGFuY2VDaGVja3BvaW50W10+IHtcbiAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVTdXBhYmFzZVNlcnZlckNsaWVudCgpXG4gIHRyeSB7XG4gICAgbGV0IHF1ZXJ5ID0gc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdiYWxhbmNlX2NoZWNrcG9pbnRzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdhY2NvdW50X2lkJywgYWNjb3VudElkKVxuXG4gICAgLy8gRmlsdGVyIHJlY29uY2lsZWQgaWYgcmVxdWVzdGVkXG4gICAgaWYgKG9wdGlvbnM/LmluY2x1ZGVSZWNvbmNpbGVkID09PSBmYWxzZSkge1xuICAgICAgcXVlcnkgPSBxdWVyeS5lcSgnaXNfcmVjb25jaWxlZCcsIGZhbHNlKVxuICAgIH1cblxuICAgIC8vIEFwcGx5IG9yZGVyaW5nXG4gICAgY29uc3QgYXNjZW5kaW5nID0gb3B0aW9ucz8ub3JkZXJCeSA9PT0gJ2RhdGVfYXNjJ1xuICAgIHF1ZXJ5ID0gcXVlcnkub3JkZXIoJ2NoZWNrcG9pbnRfZGF0ZScsIHsgYXNjZW5kaW5nIH0pXG5cbiAgICAvLyBBcHBseSBwYWdpbmF0aW9uXG4gICAgaWYgKG9wdGlvbnM/LmxpbWl0KSB7XG4gICAgICBjb25zdCBmcm9tID0gb3B0aW9ucy5vZmZzZXQgfHwgMFxuICAgICAgY29uc3QgdG8gPSBmcm9tICsgb3B0aW9ucy5saW1pdCAtIDFcbiAgICAgIHF1ZXJ5ID0gcXVlcnkucmFuZ2UoZnJvbSwgdG8pXG4gICAgfVxuXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgcXVlcnlcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggY2hlY2twb2ludHM6ICR7ZXJyb3IubWVzc2FnZX1gKVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhIHx8IFtdXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZ2V0QWNjb3VudENoZWNrcG9pbnRzOicsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYSBzaW5nbGUgY2hlY2twb2ludCBieSBJRFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2hlY2twb2ludEJ5SWQoXG4gIGNoZWNrcG9pbnRJZDogbnVtYmVyXG4pOiBQcm9taXNlPEJhbGFuY2VDaGVja3BvaW50IHwgbnVsbD4ge1xuICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZVN1cGFiYXNlU2VydmVyQ2xpZW50KClcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2JhbGFuY2VfY2hlY2twb2ludHMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ2NoZWNrcG9pbnRfaWQnLCBjaGVja3BvaW50SWQpXG4gICAgICAubWF5YmVTaW5nbGUoKVxuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBjaGVja3BvaW50OiAke2Vycm9yLm1lc3NhZ2V9YClcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdldENoZWNrcG9pbnRCeUlkOicsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLyoqXG4gKiBEZWxldGUgYSBjaGVja3BvaW50IGFuZCBpdHMgYXNzb2NpYXRlZCBiYWxhbmNlIGFkanVzdG1lbnQgdHJhbnNhY3Rpb25cbiAqIEFmdGVyIGRlbGV0aW9uLCByZWNhbGN1bGF0ZXMgYWxsIHJlbWFpbmluZyBjaGVja3BvaW50c1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQ2hlY2twb2ludChjaGVja3BvaW50SWQ6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZVN1cGFiYXNlU2VydmVyQ2xpZW50KClcbiAgdHJ5IHtcbiAgICAvLyBHZXQgdGhlIGNoZWNrcG9pbnQgdG8gZmluZCB0aGUgYWNjb3VudF9pZFxuICAgIGNvbnN0IGNoZWNrcG9pbnQgPSBhd2FpdCBnZXRDaGVja3BvaW50QnlJZChjaGVja3BvaW50SWQpXG5cbiAgICBpZiAoIWNoZWNrcG9pbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2hlY2twb2ludCAke2NoZWNrcG9pbnRJZH0gbm90IGZvdW5kYClcbiAgICB9XG5cbiAgICBjb25zdCBhY2NvdW50SWQgPSBjaGVja3BvaW50LmFjY291bnRfaWRcblxuICAgIC8vIElNUE9SVEFOVDogRGVsZXRlIHRoZSBhZGp1c3RtZW50IHRyYW5zYWN0aW9uIEZJUlNUXG4gICAgLy8gV2UgZG8gdGhpcyBleHBsaWNpdGx5IGJlY2F1c2UgQ0FTQ0FERSBtYXkgbm90IGJlIHNldCB1cCBpbiB0aGUgZGF0YWJhc2VcbiAgICBjb25zdCB7IGVycm9yOiB0eERlbGV0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ29yaWdpbmFsX3RyYW5zYWN0aW9uJylcbiAgICAgIC5kZWxldGUoKVxuICAgICAgLmVxKCdjaGVja3BvaW50X2lkJywgY2hlY2twb2ludElkKVxuICAgICAgLmVxKCdpc19iYWxhbmNlX2FkanVzdG1lbnQnLCB0cnVlKVxuXG4gICAgaWYgKHR4RGVsZXRlRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIGFkanVzdG1lbnQgdHJhbnNhY3Rpb246JywgdHhEZWxldGVFcnJvcilcbiAgICAgIC8vIENvbnRpbnVlIGFueXdheSAtIHRoZSBjaGVja3BvaW50IGRlbGV0aW9uIGlzIG1vcmUgaW1wb3J0YW50XG4gICAgfVxuXG4gICAgLy8gRGVsZXRlIHRoZSBjaGVja3BvaW50XG4gICAgY29uc3QgeyBlcnJvcjogY2hlY2twb2ludERlbGV0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2JhbGFuY2VfY2hlY2twb2ludHMnKVxuICAgICAgLmRlbGV0ZSgpXG4gICAgICAuZXEoJ2NoZWNrcG9pbnRfaWQnLCBjaGVja3BvaW50SWQpXG5cbiAgICBpZiAoY2hlY2twb2ludERlbGV0ZUVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBkZWxldGUgY2hlY2twb2ludDogJHtjaGVja3BvaW50RGVsZXRlRXJyb3IubWVzc2FnZX1gKVxuICAgIH1cblxuICAgIC8vIFJlY2FsY3VsYXRlIGFsbCByZW1haW5pbmcgY2hlY2twb2ludHNcbiAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdCBpZiB3ZSBkZWxldGVkIGEgY2hlY2twb2ludCB3aXRoIGFuIGVhcmxpZXIgZGF0ZSxcbiAgICAvLyBsYXRlciBjaGVja3BvaW50cyBnZXQgdGhlaXIgYWRqdXN0bWVudHMgcmVjYWxjdWxhdGVkIGNvcnJlY3RseVxuICAgIGF3YWl0IHJlY2FsY3VsYXRlQWxsQ2hlY2twb2ludHMoeyBhY2NvdW50X2lkOiBhY2NvdW50SWQgfSlcblxuICAgIC8vIFVwZGF0ZSBhY2NvdW50IG9wZW5pbmcgYmFsYW5jZSBkYXRlXG4gICAgYXdhaXQgdXBkYXRlQWNjb3VudE9wZW5pbmdCYWxhbmNlRGF0ZShhY2NvdW50SWQpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZGVsZXRlQ2hlY2twb2ludDonLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbi8qKlxuICogR2V0IGFsbCBmbGFnZ2VkIChiYWxhbmNlIGFkanVzdG1lbnQpIHRyYW5zYWN0aW9ucyBmb3IgYW4gYWNjb3VudFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RmxhZ2dlZFRyYW5zYWN0aW9ucyhhY2NvdW50SWQ6IG51bWJlcikge1xuICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZVN1cGFiYXNlU2VydmVyQ2xpZW50KClcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ29yaWdpbmFsX3RyYW5zYWN0aW9uJylcbiAgICAgIC5zZWxlY3QoYFxuICAgICAgICAqLFxuICAgICAgICBjaGVja3BvaW50OmJhbGFuY2VfY2hlY2twb2ludHMoXG4gICAgICAgICAgY2hlY2twb2ludF9pZCxcbiAgICAgICAgICBjaGVja3BvaW50X2RhdGUsXG4gICAgICAgICAgZGVjbGFyZWRfYmFsYW5jZSxcbiAgICAgICAgICBhZGp1c3RtZW50X2Ftb3VudCxcbiAgICAgICAgICBpc19yZWNvbmNpbGVkXG4gICAgICAgIClcbiAgICAgIGApXG4gICAgICAuZXEoJ2FjY291bnRfaWQnLCBhY2NvdW50SWQpXG4gICAgICAuZXEoJ2lzX2ZsYWdnZWQnLCB0cnVlKVxuICAgICAgLm9yZGVyKCd0cmFuc2FjdGlvbl9kYXRlJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIGZsYWdnZWQgdHJhbnNhY3Rpb25zOiAke2Vycm9yLm1lc3NhZ2V9YClcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YSB8fCBbXVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdldEZsYWdnZWRUcmFuc2FjdGlvbnM6JywgZXJyb3IpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vKipcbiAqIEdldCBjaGVja3BvaW50IHN1bW1hcnkgc3RhdGlzdGljcyBmb3IgYW4gYWNjb3VudFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2hlY2twb2ludFN1bW1hcnkoYWNjb3VudElkOiBudW1iZXIpIHtcbiAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVTdXBhYmFzZVNlcnZlckNsaWVudCgpXG4gIHRyeSB7XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdiYWxhbmNlX2NoZWNrcG9pbnRzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdhY2NvdW50X2lkJywgYWNjb3VudElkKVxuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBjaGVja3BvaW50IHN1bW1hcnk6ICR7ZXJyb3IubWVzc2FnZX1gKVxuICAgIH1cblxuICAgIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG90YWxfY2hlY2twb2ludHM6IDAsXG4gICAgICAgIHJlY29uY2lsZWRfY2hlY2twb2ludHM6IDAsXG4gICAgICAgIHVucmVjb25jaWxlZF9jaGVja3BvaW50czogMCxcbiAgICAgICAgdG90YWxfYWRqdXN0bWVudF9hbW91bnQ6IDAsXG4gICAgICAgIGVhcmxpZXN0X2NoZWNrcG9pbnRfZGF0ZTogbnVsbCxcbiAgICAgICAgbGF0ZXN0X2NoZWNrcG9pbnRfZGF0ZTogbnVsbCxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZWNvbmNpbGVkQ291bnQgPSBkYXRhLmZpbHRlcihjcCA9PiBjcC5pc19yZWNvbmNpbGVkKS5sZW5ndGhcbiAgICBjb25zdCB0b3RhbEFkanVzdG1lbnQgPSBkYXRhLnJlZHVjZSgoc3VtLCBjcCkgPT4gc3VtICsgY3AuYWRqdXN0bWVudF9hbW91bnQsIDApXG4gICAgLy8gY2hlY2twb2ludF9kYXRlIGlzIGFscmVhZHkgYSBzdHJpbmcgKFlZWVktTU0tREQpLCBjYW4gY29tcGFyZSBkaXJlY3RseVxuICAgIGNvbnN0IGRhdGVzID0gZGF0YS5tYXAoY3AgPT4gY3AuY2hlY2twb2ludF9kYXRlKS5zb3J0KClcblxuICAgIHJldHVybiB7XG4gICAgICB0b3RhbF9jaGVja3BvaW50czogZGF0YS5sZW5ndGgsXG4gICAgICByZWNvbmNpbGVkX2NoZWNrcG9pbnRzOiByZWNvbmNpbGVkQ291bnQsXG4gICAgICB1bnJlY29uY2lsZWRfY2hlY2twb2ludHM6IGRhdGEubGVuZ3RoIC0gcmVjb25jaWxlZENvdW50LFxuICAgICAgdG90YWxfYWRqdXN0bWVudF9hbW91bnQ6IHRvdGFsQWRqdXN0bWVudCxcbiAgICAgIGVhcmxpZXN0X2NoZWNrcG9pbnRfZGF0ZTogZGF0ZXNbMF0sICAvLyBBbHJlYWR5IGEgZGF0ZSBzdHJpbmdcbiAgICAgIGxhdGVzdF9jaGVja3BvaW50X2RhdGU6IGRhdGVzW2RhdGVzLmxlbmd0aCAtIDFdLCAgLy8gQWxyZWFkeSBhIGRhdGUgc3RyaW5nXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdldENoZWNrcG9pbnRTdW1tYXJ5OicsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVTdXBhYmFzZVNlcnZlckNsaWVudCIsIkNIRUNLUE9JTlRfQ09ORklHIiwidG9JU09EYXRlU3RyaW5nIiwiZGF0ZSIsInllYXIiLCJnZXRGdWxsWWVhciIsIm1vbnRoIiwiU3RyaW5nIiwiZ2V0TW9udGgiLCJwYWRTdGFydCIsImRheSIsImdldERhdGUiLCJjYWxjdWxhdGVCYWxhbmNlVXBUb0RhdGUiLCJhY2NvdW50SWQiLCJ1cFRvRGF0ZSIsInN1cGFiYXNlIiwidXBUb0RhdGVTdHIiLCJkYXRhIiwiZXJyb3IiLCJycGMiLCJwX2FjY291bnRfaWQiLCJwX3VwX3RvX2RhdGUiLCJjb25zb2xlIiwiRXJyb3IiLCJtZXNzYWdlIiwiY291bnQiLCJmcm9tIiwic2VsZWN0IiwiaGVhZCIsImVxIiwibHRlIiwiYWNjb3VudF9pZCIsInVwX3RvX2RhdGUiLCJjYWxjdWxhdGVkX2JhbGFuY2UiLCJ0cmFuc2FjdGlvbl9jb3VudCIsImNyZWF0ZU9yVXBkYXRlQmFsYW5jZUFkanVzdG1lbnRUcmFuc2FjdGlvbiIsImNoZWNrcG9pbnQiLCJjaGVja3BvaW50X2lkIiwiY2hlY2twb2ludF9kYXRlIiwiYWRqdXN0bWVudF9hbW91bnQiLCJhY2NvdW50IiwiYWNjb3VudEVycm9yIiwic2luZ2xlIiwiaXNDcmVkaXRBY2NvdW50IiwiaW5jbHVkZXMiLCJhY2NvdW50X3R5cGUiLCJleGlzdGluZyIsImZldGNoRXJyb3IiLCJtYXliZVNpbmdsZSIsIk1hdGgiLCJhYnMiLCJSRUNPTkNJTElBVElPTl9USFJFU0hPTEQiLCJkZWxldGVFcnJvciIsImRlbGV0ZSIsImNyZWRpdEFtb3VudCIsImRlYml0QW1vdW50IiwidHJhbnNhY3Rpb25EYXRhIiwidHJhbnNhY3Rpb25fZGF0ZSIsImRlc2NyaXB0aW9uIiwiQkFMQU5DRV9BREpVU1RNRU5UX0RFU0NSSVBUSU9OIiwiY3JlZGl0X2Ftb3VudCIsImRlYml0X2Ftb3VudCIsImlzX2JhbGFuY2VfYWRqdXN0bWVudCIsImlzX2ZsYWdnZWQiLCJ1cGRhdGVFcnJvciIsInVwZGF0ZSIsInVwZGF0ZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJyYXdfdHJhbnNhY3Rpb25faWQiLCJpbnNlcnRFcnJvciIsImluc2VydCIsInRyYW5zYWN0aW9uX3NvdXJjZSIsImNyZWF0ZU9yVXBkYXRlQ2hlY2twb2ludCIsInBhcmFtcyIsImRlY2xhcmVkX2JhbGFuY2UiLCJub3RlcyIsImltcG9ydF9iYXRjaF9pZCIsInVzZXJfaWQiLCJjaGVja3BvaW50RGF0ZVN0ciIsImV4aXN0aW5nUXVlcnkiLCJpcyIsInVwZGF0ZWQiLCJjcmVhdGVkIiwiaXNfcmVjb25jaWxlZCIsImNyZWF0ZWRfYnlfdXNlcl9pZCIsInJlY2FsY3VsYXRlQWxsQ2hlY2twb2ludHMiLCJmaW5hbENoZWNrcG9pbnQiLCJmaW5hbEVycm9yIiwidXBkYXRlQWNjb3VudE9wZW5pbmdCYWxhbmNlRGF0ZSIsImZyb21fZGF0ZSIsInRvX2RhdGUiLCJjaGVja3BvaW50X2lkcyIsImFsbENoZWNrcG9pbnRzIiwib3JkZXIiLCJhc2NlbmRpbmciLCJsZW5ndGgiLCJjaGVja3BvaW50c1RvUmVjYWxjdWxhdGUiLCJmaWx0ZXIiLCJjcCIsImNwRGF0ZSIsInJlc3VsdHMiLCJ0b3RhbENyZWRpdHMiLCJ0b3RhbERlYml0cyIsInBhZ2UiLCJwYWdlU2l6ZSIsIm5vbkFkanVzdG1lbnRUeHMiLCJ0eEVycm9yIiwicmFuZ2UiLCJ0eCIsInByZXZpb3VzQ2hlY2twb2ludHMiLCJwcmV2aW91c0NoZWNrcG9pbnRJZHMiLCJtYXAiLCJwcmV2aW91c0FkanVzdG1lbnRzIiwiYWRqRXJyb3IiLCJpbiIsIm5ld0NhbGN1bGF0ZWRCYWxhbmNlIiwibmV3QWRqdXN0bWVudEFtb3VudCIsIm5ld0lzUmVjb25jaWxlZCIsIm9sZENhbGN1bGF0ZWRCYWxhbmNlIiwib2xkQWRqdXN0bWVudEFtb3VudCIsIm9sZElzUmVjb25jaWxlZCIsImZpbmQiLCJwdXNoIiwib2xkX2NhbGN1bGF0ZWRfYmFsYW5jZSIsIm5ld19jYWxjdWxhdGVkX2JhbGFuY2UiLCJvbGRfYWRqdXN0bWVudF9hbW91bnQiLCJuZXdfYWRqdXN0bWVudF9hbW91bnQiLCJvbGRfaXNfcmVjb25jaWxlZCIsIm5ld19pc19yZWNvbmNpbGVkIiwiYWRqdXN0bWVudF90cmFuc2FjdGlvbl91cGRhdGVkIiwiZ2V0QWNjb3VudENoZWNrcG9pbnRzIiwib3B0aW9ucyIsInF1ZXJ5IiwiaW5jbHVkZVJlY29uY2lsZWQiLCJvcmRlckJ5IiwibGltaXQiLCJvZmZzZXQiLCJ0byIsImdldENoZWNrcG9pbnRCeUlkIiwiY2hlY2twb2ludElkIiwiZGVsZXRlQ2hlY2twb2ludCIsInR4RGVsZXRlRXJyb3IiLCJjaGVja3BvaW50RGVsZXRlRXJyb3IiLCJnZXRGbGFnZ2VkVHJhbnNhY3Rpb25zIiwiZ2V0Q2hlY2twb2ludFN1bW1hcnkiLCJ0b3RhbF9jaGVja3BvaW50cyIsInJlY29uY2lsZWRfY2hlY2twb2ludHMiLCJ1bnJlY29uY2lsZWRfY2hlY2twb2ludHMiLCJ0b3RhbF9hZGp1c3RtZW50X2Ftb3VudCIsImVhcmxpZXN0X2NoZWNrcG9pbnRfZGF0ZSIsImxhdGVzdF9jaGVja3BvaW50X2RhdGUiLCJyZWNvbmNpbGVkQ291bnQiLCJ0b3RhbEFkanVzdG1lbnQiLCJyZWR1Y2UiLCJzdW0iLCJkYXRlcyIsInNvcnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/checkpoint-service.ts\n");

/***/ }),

/***/ "(rsc)/./lib/supabase-server.ts":
/*!********************************!*\
  !*** ./lib/supabase-server.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSupabaseServerClient: () => (/* binding */ createSupabaseServerClient),\n/* harmony export */   getCurrentUser: () => (/* binding */ getCurrentUser),\n/* harmony export */   requireAuth: () => (/* binding */ requireAuth)\n/* harmony export */ });\n/* harmony import */ var _supabase_ssr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/ssr */ \"(rsc)/../../node_modules/@supabase/ssr/dist/module/index.js\");\n/* harmony import */ var next_headers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/headers */ \"(rsc)/../../node_modules/next/dist/api/headers.js\");\n\n\nfunction createSupabaseServerClient() {\n    const cookieStore = (0,next_headers__WEBPACK_IMPORTED_MODULE_1__.cookies)();\n    return (0,_supabase_ssr__WEBPACK_IMPORTED_MODULE_0__.createServerClient)(\"https://mflyrbzriksgjutlalkf.supabase.co\", \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1mbHlyYnpyaWtzZ2p1dGxhbGtmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjIyMjQ3MjcsImV4cCI6MjA3NzgwMDcyN30.O9hwKR6Vxb_vJhPrYedwQWkTCvfApcvBfnasSLt1vyY\", {\n        cookies: {\n            get (name) {\n                return cookieStore.get(name)?.value;\n            },\n            set (name, value, options) {\n                try {\n                    cookieStore.set({\n                        name,\n                        value,\n                        ...options\n                    });\n                } catch (error) {\n                // The `set` method was called from a Server Component.\n                // This can be ignored if you have middleware refreshing\n                // user sessions.\n                }\n            },\n            remove (name, options) {\n                try {\n                    cookieStore.set({\n                        name,\n                        value: \"\",\n                        ...options\n                    });\n                } catch (error) {\n                // The `delete` method was called from a Server Component.\n                // This can be ignored if you have middleware refreshing\n                // user sessions.\n                }\n            }\n        }\n    });\n}\n// Helper function to get the current user from server components\nasync function getCurrentUser() {\n    const supabase = createSupabaseServerClient();\n    const { data: { user }, error } = await supabase.auth.getUser();\n    if (error || !user) {\n        return null;\n    }\n    return user;\n}\n// Helper function to check if user is authenticated\nasync function requireAuth() {\n    const user = await getCurrentUser();\n    if (!user) {\n        throw new Error(\"Unauthorized\");\n    }\n    return user;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvc3VwYWJhc2Utc2VydmVyLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXNFO0FBQ2hDO0FBRS9CLFNBQVNFO0lBQ2QsTUFBTUMsY0FBY0YscURBQU9BO0lBRTNCLE9BQU9ELGlFQUFrQkEsQ0FDdkJJLDBDQUFvQyxFQUNwQ0Esa05BQXlDLEVBQ3pDO1FBQ0VILFNBQVM7WUFDUE8sS0FBSUMsSUFBWTtnQkFDZCxPQUFPTixZQUFZSyxHQUFHLENBQUNDLE9BQU9DO1lBQ2hDO1lBQ0FDLEtBQUlGLElBQVksRUFBRUMsS0FBYSxFQUFFRSxPQUFzQjtnQkFDckQsSUFBSTtvQkFDRlQsWUFBWVEsR0FBRyxDQUFDO3dCQUFFRjt3QkFBTUM7d0JBQU8sR0FBR0UsT0FBTztvQkFBQztnQkFDNUMsRUFBRSxPQUFPQyxPQUFPO2dCQUNkLHVEQUF1RDtnQkFDdkQsd0RBQXdEO2dCQUN4RCxpQkFBaUI7Z0JBQ25CO1lBQ0Y7WUFDQUMsUUFBT0wsSUFBWSxFQUFFRyxPQUFzQjtnQkFDekMsSUFBSTtvQkFDRlQsWUFBWVEsR0FBRyxDQUFDO3dCQUFFRjt3QkFBTUMsT0FBTzt3QkFBSSxHQUFHRSxPQUFPO29CQUFDO2dCQUNoRCxFQUFFLE9BQU9DLE9BQU87Z0JBQ2QsMERBQTBEO2dCQUMxRCx3REFBd0Q7Z0JBQ3hELGlCQUFpQjtnQkFDbkI7WUFDRjtRQUNGO0lBQ0Y7QUFFSjtBQUVBLGlFQUFpRTtBQUMxRCxlQUFlRTtJQUNwQixNQUFNQyxXQUFXZDtJQUNqQixNQUFNLEVBQUVlLE1BQU0sRUFBRUMsSUFBSSxFQUFFLEVBQUVMLEtBQUssRUFBRSxHQUFHLE1BQU1HLFNBQVNHLElBQUksQ0FBQ0MsT0FBTztJQUU3RCxJQUFJUCxTQUFTLENBQUNLLE1BQU07UUFDbEIsT0FBTztJQUNUO0lBRUEsT0FBT0E7QUFDVDtBQUVBLG9EQUFvRDtBQUM3QyxlQUFlRztJQUNwQixNQUFNSCxPQUFPLE1BQU1IO0lBRW5CLElBQUksQ0FBQ0csTUFBTTtRQUNULE1BQU0sSUFBSUksTUFBTTtJQUNsQjtJQUVBLE9BQU9KO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZmluYW5jZWFwcC93ZWIvLi9saWIvc3VwYWJhc2Utc2VydmVyLnRzPzA5NGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlU2VydmVyQ2xpZW50LCB0eXBlIENvb2tpZU9wdGlvbnMgfSBmcm9tICdAc3VwYWJhc2Uvc3NyJ1xuaW1wb3J0IHsgY29va2llcyB9IGZyb20gJ25leHQvaGVhZGVycydcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN1cGFiYXNlU2VydmVyQ2xpZW50KCkge1xuICBjb25zdCBjb29raWVTdG9yZSA9IGNvb2tpZXMoKVxuXG4gIHJldHVybiBjcmVhdGVTZXJ2ZXJDbGllbnQoXG4gICAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMISxcbiAgICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSEsXG4gICAge1xuICAgICAgY29va2llczoge1xuICAgICAgICBnZXQobmFtZTogc3RyaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIGNvb2tpZVN0b3JlLmdldChuYW1lKT8udmFsdWVcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZywgb3B0aW9uczogQ29va2llT3B0aW9ucykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb29raWVTdG9yZS5zZXQoeyBuYW1lLCB2YWx1ZSwgLi4ub3B0aW9ucyB9KVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBUaGUgYHNldGAgbWV0aG9kIHdhcyBjYWxsZWQgZnJvbSBhIFNlcnZlciBDb21wb25lbnQuXG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBiZSBpZ25vcmVkIGlmIHlvdSBoYXZlIG1pZGRsZXdhcmUgcmVmcmVzaGluZ1xuICAgICAgICAgICAgLy8gdXNlciBzZXNzaW9ucy5cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZShuYW1lOiBzdHJpbmcsIG9wdGlvbnM6IENvb2tpZU9wdGlvbnMpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29va2llU3RvcmUuc2V0KHsgbmFtZSwgdmFsdWU6ICcnLCAuLi5vcHRpb25zIH0pXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFRoZSBgZGVsZXRlYCBtZXRob2Qgd2FzIGNhbGxlZCBmcm9tIGEgU2VydmVyIENvbXBvbmVudC5cbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIGJlIGlnbm9yZWQgaWYgeW91IGhhdmUgbWlkZGxld2FyZSByZWZyZXNoaW5nXG4gICAgICAgICAgICAvLyB1c2VyIHNlc3Npb25zLlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfVxuICApXG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGN1cnJlbnQgdXNlciBmcm9tIHNlcnZlciBjb21wb25lbnRzXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3VycmVudFVzZXIoKSB7XG4gIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlU3VwYWJhc2VTZXJ2ZXJDbGllbnQoKVxuICBjb25zdCB7IGRhdGE6IHsgdXNlciB9LCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKClcblxuICBpZiAoZXJyb3IgfHwgIXVzZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIHVzZXJcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNoZWNrIGlmIHVzZXIgaXMgYXV0aGVudGljYXRlZFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlcXVpcmVBdXRoKCkge1xuICBjb25zdCB1c2VyID0gYXdhaXQgZ2V0Q3VycmVudFVzZXIoKVxuXG4gIGlmICghdXNlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5hdXRob3JpemVkJylcbiAgfVxuXG4gIHJldHVybiB1c2VyXG59XG4iXSwibmFtZXMiOlsiY3JlYXRlU2VydmVyQ2xpZW50IiwiY29va2llcyIsImNyZWF0ZVN1cGFiYXNlU2VydmVyQ2xpZW50IiwiY29va2llU3RvcmUiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJnZXQiLCJuYW1lIiwidmFsdWUiLCJzZXQiLCJvcHRpb25zIiwiZXJyb3IiLCJyZW1vdmUiLCJnZXRDdXJyZW50VXNlciIsInN1cGFiYXNlIiwiZGF0YSIsInVzZXIiLCJhdXRoIiwiZ2V0VXNlciIsInJlcXVpcmVBdXRoIiwiRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/supabase-server.ts\n");

/***/ }),

/***/ "(rsc)/./types/checkpoint.ts":
/*!*****************************!*\
  !*** ./types/checkpoint.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CHECKPOINT_CONFIG: () => (/* binding */ CHECKPOINT_CONFIG),\n/* harmony export */   CHECKPOINT_VALIDATION: () => (/* binding */ CHECKPOINT_VALIDATION),\n/* harmony export */   formatAdjustmentAmount: () => (/* binding */ formatAdjustmentAmount),\n/* harmony export */   getAdjustmentType: () => (/* binding */ getAdjustmentType),\n/* harmony export */   getCheckpointAlertMessage: () => (/* binding */ getCheckpointAlertMessage),\n/* harmony export */   getCheckpointStatusColor: () => (/* binding */ getCheckpointStatusColor),\n/* harmony export */   isBalanceCheckpoint: () => (/* binding */ isBalanceCheckpoint),\n/* harmony export */   isFlaggedTransaction: () => (/* binding */ isFlaggedTransaction),\n/* harmony export */   isReconciled: () => (/* binding */ isReconciled)\n/* harmony export */ });\n/**\n * TypeScript types for the Balance Checkpoint & Adjustment System\n * Implements \"No money without origin\" principle\n */ // ==============================================================================\n// Core Checkpoint Types\n// ==============================================================================\n// ==============================================================================\n// Constants\n// ==============================================================================\nconst CHECKPOINT_CONFIG = {\n    RECONCILIATION_THRESHOLD: 0.01,\n    MAX_CHECKPOINTS_PER_ACCOUNT: 100,\n    BALANCE_ADJUSTMENT_DESCRIPTION: \"Balance Adjustment (Checkpoint)\"\n};\nconst CHECKPOINT_VALIDATION = {\n    MIN_DECLARED_BALANCE: -999999999999.99,\n    MAX_DECLARED_BALANCE: 999999999999.99,\n    MAX_NOTE_LENGTH: 1000\n};\n// ==============================================================================\n// Type Guards\n// ==============================================================================\nfunction isBalanceCheckpoint(obj) {\n    return typeof obj === \"object\" && obj !== null && typeof obj.checkpoint_id === \"number\" && typeof obj.account_id === \"number\" && typeof obj.declared_balance === \"number\" && typeof obj.calculated_balance === \"number\" && typeof obj.adjustment_amount === \"number\" && typeof obj.is_reconciled === \"boolean\";\n}\nfunction isFlaggedTransaction(obj) {\n    return typeof obj === \"object\" && obj !== null && typeof obj.transaction_id === \"number\" && typeof obj.is_flagged === \"boolean\" && obj.is_flagged === true;\n}\n// ==============================================================================\n// Utility Functions\n// ==============================================================================\nfunction isReconciled(adjustmentAmount, threshold = CHECKPOINT_CONFIG.RECONCILIATION_THRESHOLD) {\n    return Math.abs(adjustmentAmount) < threshold;\n}\nfunction getAdjustmentType(adjustmentAmount) {\n    if (adjustmentAmount > 0.01) return \"credit\";\n    if (adjustmentAmount < -0.01) return \"debit\";\n    return \"none\";\n}\nfunction formatAdjustmentAmount(amount, currency = \"VND\") {\n    const absAmount = Math.abs(amount);\n    const type = getAdjustmentType(amount);\n    if (type === \"none\") return \"Reconciled\";\n    const sign = type === \"credit\" ? \"+\" : \"-\";\n    // Format based on currency\n    if (currency === \"VND\") {\n        return `${sign}${absAmount.toLocaleString(\"vi-VN\")} ₫`;\n    } else if (currency === \"USD\") {\n        return `${sign}$${absAmount.toLocaleString(\"en-US\", {\n            minimumFractionDigits: 2,\n            maximumFractionDigits: 2\n        })}`;\n    } else if (currency === \"EUR\") {\n        return `${sign}€${absAmount.toLocaleString(\"de-DE\", {\n            minimumFractionDigits: 2,\n            maximumFractionDigits: 2\n        })}`;\n    }\n    return `${sign}${absAmount}`;\n}\nfunction getCheckpointStatusColor(checkpoint) {\n    if (checkpoint.is_reconciled) return \"green\";\n    if (Math.abs(checkpoint.adjustment_amount) < 1000000) return \"yellow\" // Less than 1M VND\n    ;\n    return \"red\";\n}\nfunction getCheckpointAlertMessage(checkpoint) {\n    if (checkpoint.is_reconciled) {\n        return \"Fully reconciled - all transactions accounted for\";\n    }\n    const type = getAdjustmentType(checkpoint.adjustment_amount);\n    const absAmount = Math.abs(checkpoint.adjustment_amount);\n    if (type === \"credit\") {\n        return `You have ${absAmount.toLocaleString()} in unexplained income. Add transactions to reconcile.`;\n    } else {\n        return `You have ${absAmount.toLocaleString()} in unexplained expenses. Add transactions to reconcile.`;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFZTixLQUFLQyxHQUFHLENBQUNZLFdBQVdyQixpQkFBaUI7SUFFdkQsSUFBSWUsU0FBUyxVQUFVO1FBQ3JCLE9BQU8sQ0FBQyxTQUFTLEVBQUVELFVBQVVHLGNBQWMsR0FBRyxzREFBc0QsQ0FBQztJQUN2RyxPQUFPO1FBQ0wsT0FBTyxDQUFDLFNBQVMsRUFBRUgsVUFBVUcsY0FBYyxHQUFHLHdEQUF3RCxDQUFDO0lBQ3pHO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZmluYW5jZWFwcC93ZWIvLi90eXBlcy9jaGVja3BvaW50LnRzPzMwMjEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUeXBlU2NyaXB0IHR5cGVzIGZvciB0aGUgQmFsYW5jZSBDaGVja3BvaW50ICYgQWRqdXN0bWVudCBTeXN0ZW1cbiAqIEltcGxlbWVudHMgXCJObyBtb25leSB3aXRob3V0IG9yaWdpblwiIHByaW5jaXBsZVxuICovXG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gQ29yZSBDaGVja3BvaW50IFR5cGVzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGludGVyZmFjZSBCYWxhbmNlQ2hlY2twb2ludCB7XG4gIGNoZWNrcG9pbnRfaWQ6IG51bWJlclxuICBhY2NvdW50X2lkOiBudW1iZXJcbiAgY2hlY2twb2ludF9kYXRlOiBzdHJpbmcgLy8gSVNPIDg2MDEgZm9ybWF0XG4gIGRlY2xhcmVkX2JhbGFuY2U6IG51bWJlclxuICBjYWxjdWxhdGVkX2JhbGFuY2U6IG51bWJlclxuICBhZGp1c3RtZW50X2Ftb3VudDogbnVtYmVyXG4gIGlzX3JlY29uY2lsZWQ6IGJvb2xlYW5cbiAgbm90ZXM6IHN0cmluZyB8IG51bGxcbiAgaW1wb3J0X2JhdGNoX2lkOiBudW1iZXIgfCBudWxsIC8vIExpbmtzIHRvIGltcG9ydF9iYXRjaCwgTlVMTCBmb3IgbWFudWFsIGNoZWNrcG9pbnRzXG4gIGNyZWF0ZWRfYnlfdXNlcl9pZDogbnVtYmVyIHwgbnVsbFxuICBjcmVhdGVkX2F0OiBzdHJpbmdcbiAgdXBkYXRlZF9hdDogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFsYW5jZUNoZWNrcG9pbnRXaXRoQWNjb3VudCBleHRlbmRzIEJhbGFuY2VDaGVja3BvaW50IHtcbiAgYWNjb3VudDoge1xuICAgIGFjY291bnRfaWQ6IG51bWJlclxuICAgIGFjY291bnRfbmFtZTogc3RyaW5nXG4gICAgYWNjb3VudF90eXBlOiBzdHJpbmdcbiAgICBjdXJyZW5jeTogc3RyaW5nXG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBSZXF1ZXN0L1Jlc3BvbnNlIFR5cGVzIGZvciBBUElcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZUNoZWNrcG9pbnRSZXF1ZXN0IHtcbiAgY2hlY2twb2ludF9kYXRlOiBzdHJpbmcgLy8gSVNPIDg2MDEgZm9ybWF0XG4gIGRlY2xhcmVkX2JhbGFuY2U6IG51bWJlclxuICBub3Rlcz86IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZUNoZWNrcG9pbnRSZXF1ZXN0IHtcbiAgZGVjbGFyZWRfYmFsYW5jZT86IG51bWJlclxuICBub3Rlcz86IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZUNoZWNrcG9pbnRSZXNwb25zZSB7XG4gIGNoZWNrcG9pbnQ6IEJhbGFuY2VDaGVja3BvaW50XG4gIGFkanVzdG1lbnRfdHJhbnNhY3Rpb24/OiBGbGFnZ2VkVHJhbnNhY3Rpb25cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGVja3BvaW50TGlzdFF1ZXJ5IHtcbiAgaW5jbHVkZV9yZWNvbmNpbGVkPzogYm9vbGVhblxuICBvcmRlcl9ieT86ICdkYXRlX2FzYycgfCAnZGF0ZV9kZXNjJ1xuICBsaW1pdD86IG51bWJlclxuICBvZmZzZXQ/OiBudW1iZXJcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBGbGFnZ2VkIFRyYW5zYWN0aW9uIFR5cGVzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGludGVyZmFjZSBGbGFnZ2VkVHJhbnNhY3Rpb24ge1xuICB0cmFuc2FjdGlvbl9pZDogbnVtYmVyXG4gIGFjY291bnRfaWQ6IG51bWJlclxuICB0cmFuc2FjdGlvbl9kYXRlOiBzdHJpbmdcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xuICBjcmVkaXRfYW1vdW50OiBudW1iZXJcbiAgZGViaXRfYW1vdW50OiBudW1iZXJcbiAgY2hlY2twb2ludF9pZDogbnVtYmVyIHwgbnVsbFxuICBpc19iYWxhbmNlX2FkanVzdG1lbnQ6IGJvb2xlYW5cbiAgaXNfZmxhZ2dlZDogYm9vbGVhblxuICBjcmVhdGVkX2F0OiBzdHJpbmdcbiAgdXBkYXRlZF9hdDogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmxhZ2dlZFRyYW5zYWN0aW9uV2l0aENoZWNrcG9pbnQgZXh0ZW5kcyBGbGFnZ2VkVHJhbnNhY3Rpb24ge1xuICBjaGVja3BvaW50OiB7XG4gICAgY2hlY2twb2ludF9pZDogbnVtYmVyXG4gICAgY2hlY2twb2ludF9kYXRlOiBzdHJpbmdcbiAgICBkZWNsYXJlZF9iYWxhbmNlOiBudW1iZXJcbiAgICBhZGp1c3RtZW50X2Ftb3VudDogbnVtYmVyXG4gICAgaXNfcmVjb25jaWxlZDogYm9vbGVhblxuICB9IHwgbnVsbFxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIENhbGN1bGF0aW9uIFR5cGVzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGludGVyZmFjZSBCYWxhbmNlQ2FsY3VsYXRpb24ge1xuICBhY2NvdW50X2lkOiBudW1iZXJcbiAgdXBfdG9fZGF0ZTogc3RyaW5nXG4gIGNhbGN1bGF0ZWRfYmFsYW5jZTogbnVtYmVyXG4gIHRyYW5zYWN0aW9uX2NvdW50OiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGVja3BvaW50UmVjYWxjdWxhdGlvblJlc3VsdCB7XG4gIGNoZWNrcG9pbnRfaWQ6IG51bWJlclxuICBvbGRfY2FsY3VsYXRlZF9iYWxhbmNlOiBudW1iZXJcbiAgbmV3X2NhbGN1bGF0ZWRfYmFsYW5jZTogbnVtYmVyXG4gIG9sZF9hZGp1c3RtZW50X2Ftb3VudDogbnVtYmVyXG4gIG5ld19hZGp1c3RtZW50X2Ftb3VudDogbnVtYmVyXG4gIG9sZF9pc19yZWNvbmNpbGVkOiBib29sZWFuXG4gIG5ld19pc19yZWNvbmNpbGVkOiBib29sZWFuXG4gIGFkanVzdG1lbnRfdHJhbnNhY3Rpb25fdXBkYXRlZDogYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFjY291bnRDaGVja3BvaW50U3VtbWFyeSB7XG4gIGFjY291bnRfaWQ6IG51bWJlclxuICBhY2NvdW50X25hbWU6IHN0cmluZ1xuICB0b3RhbF9jaGVja3BvaW50czogbnVtYmVyXG4gIHJlY29uY2lsZWRfY2hlY2twb2ludHM6IG51bWJlclxuICB1bnJlY29uY2lsZWRfY2hlY2twb2ludHM6IG51bWJlclxuICB0b3RhbF9hZGp1c3RtZW50X2Ftb3VudDogbnVtYmVyXG4gIGVhcmxpZXN0X2NoZWNrcG9pbnRfZGF0ZTogc3RyaW5nIHwgbnVsbFxuICBsYXRlc3RfY2hlY2twb2ludF9kYXRlOiBzdHJpbmcgfCBudWxsXG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gVmFsaWRhdGlvbiBUeXBlc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hlY2twb2ludFZhbGlkYXRpb25FcnJvciB7XG4gIGZpZWxkOiBzdHJpbmdcbiAgbWVzc2FnZTogc3RyaW5nXG4gIGNvZGU6IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENoZWNrcG9pbnRDb25mbGljdCB7XG4gIHR5cGU6ICdkYXRlX2NvbmZsaWN0JyB8ICd0cmFuc2FjdGlvbl9jb25mbGljdCcgfCAnZHVwbGljYXRlJ1xuICBtZXNzYWdlOiBzdHJpbmdcbiAgZXhpc3RpbmdfY2hlY2twb2ludD86IEJhbGFuY2VDaGVja3BvaW50XG4gIGNvbmZsaWN0aW5nX3RyYW5zYWN0aW9ucz86IEFycmF5PHtcbiAgICB0cmFuc2FjdGlvbl9pZDogbnVtYmVyXG4gICAgdHJhbnNhY3Rpb25fZGF0ZTogc3RyaW5nXG4gICAgZGVzY3JpcHRpb246IHN0cmluZ1xuICB9PlxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFNlcnZpY2UgRnVuY3Rpb24gVHlwZXNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIENoZWNrcG9pbnRTZXJ2aWNlQ29uZmlnIHtcbiAgcmVjb25jaWxpYXRpb25fdGhyZXNob2xkOiBudW1iZXIgLy8gRGVmYXVsdDogMC4wMSAoMSBjZW50KVxuICBhdXRvX3JlY2FsY3VsYXRlOiBib29sZWFuIC8vIERlZmF1bHQ6IHRydWVcbiAgbm90aWZpY2F0aW9uX2VuYWJsZWQ6IGJvb2xlYW4gLy8gRGVmYXVsdDogdHJ1ZVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZU9yVXBkYXRlQ2hlY2twb2ludFBhcmFtcyB7XG4gIGFjY291bnRfaWQ6IG51bWJlclxuICBjaGVja3BvaW50X2RhdGU6IERhdGVcbiAgZGVjbGFyZWRfYmFsYW5jZTogbnVtYmVyXG4gIG5vdGVzPzogc3RyaW5nIHwgbnVsbFxuICBpbXBvcnRfYmF0Y2hfaWQ/OiBudW1iZXIgfCBudWxsIC8vIEZvciBpbXBvcnQtY3JlYXRlZCBjaGVja3BvaW50c1xuICB1c2VyX2lkPzogbnVtYmVyIHwgbnVsbFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlY2FsY3VsYXRlQ2hlY2twb2ludHNQYXJhbXMge1xuICBhY2NvdW50X2lkOiBudW1iZXJcbiAgZnJvbV9kYXRlPzogRGF0ZVxuICB0b19kYXRlPzogRGF0ZVxuICBjaGVja3BvaW50X2lkcz86IG51bWJlcltdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFsYW5jZUFkanVzdG1lbnRUcmFuc2FjdGlvbkRhdGEge1xuICByYXdfdHJhbnNhY3Rpb25faWQ6IHN0cmluZ1xuICBhY2NvdW50X2lkOiBudW1iZXJcbiAgdHJhbnNhY3Rpb25fZGF0ZTogRGF0ZVxuICBkZXNjcmlwdGlvbjogc3RyaW5nXG4gIGNyZWRpdF9hbW91bnQ6IG51bWJlciB8IG51bGwgIC8vIEVpdGhlciBjcmVkaXQgT1IgZGViaXQgaXMgbnVsbCAoREIgY29uc3RyYWludClcbiAgZGViaXRfYW1vdW50OiBudW1iZXIgfCBudWxsICAgLy8gRWl0aGVyIGNyZWRpdCBPUiBkZWJpdCBpcyBudWxsIChEQiBjb25zdHJhaW50KVxuICB0cmFuc2FjdGlvbl9zb3VyY2U6ICdhdXRvX2FkanVzdG1lbnQnICAvLyBBbHdheXMgYXV0b19hZGp1c3RtZW50IGZvciBiYWxhbmNlIGFkanVzdG1lbnRzXG4gIGNoZWNrcG9pbnRfaWQ6IG51bWJlclxuICBpc19iYWxhbmNlX2FkanVzdG1lbnQ6IGJvb2xlYW5cbiAgaXNfZmxhZ2dlZDogYm9vbGVhblxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERhc2hib2FyZC9VSSBUeXBlc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hlY2twb2ludEFsZXJ0IHtcbiAgc2V2ZXJpdHk6ICdpbmZvJyB8ICd3YXJuaW5nJyB8ICdlcnJvcidcbiAgbWVzc2FnZTogc3RyaW5nXG4gIGNoZWNrcG9pbnRfaWQ6IG51bWJlclxuICBhY2NvdW50X2lkOiBudW1iZXJcbiAgYWRqdXN0bWVudF9hbW91bnQ6IG51bWJlclxuICBhY3Rpb25fdXJsOiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGVja3BvaW50U3RhdHMge1xuICB0b3RhbF91bnJlY29uY2lsZWQ6IG51bWJlclxuICB0b3RhbF9hZGp1c3RtZW50X2Ftb3VudDogbnVtYmVyXG4gIGFjY291bnRzX3dpdGhfZmxhZ3M6IG51bWJlclxuICBvbGRlc3RfdW5yZWNvbmNpbGVkX2RhdGU6IHN0cmluZyB8IG51bGxcbiAgY2hlY2twb2ludHM6IEFycmF5PHtcbiAgICBjaGVja3BvaW50X2lkOiBudW1iZXJcbiAgICBhY2NvdW50X25hbWU6IHN0cmluZ1xuICAgIGNoZWNrcG9pbnRfZGF0ZTogc3RyaW5nXG4gICAgYWRqdXN0bWVudF9hbW91bnQ6IG51bWJlclxuICB9PlxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIENvbnN0YW50c1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBjb25zdCBDSEVDS1BPSU5UX0NPTkZJRyA9IHtcbiAgUkVDT05DSUxJQVRJT05fVEhSRVNIT0xEOiAwLjAxLCAvLyAxIGNlbnRcbiAgTUFYX0NIRUNLUE9JTlRTX1BFUl9BQ0NPVU5UOiAxMDAsXG4gIEJBTEFOQ0VfQURKVVNUTUVOVF9ERVNDUklQVElPTjogJ0JhbGFuY2UgQWRqdXN0bWVudCAoQ2hlY2twb2ludCknLFxufSBhcyBjb25zdFxuXG5leHBvcnQgY29uc3QgQ0hFQ0tQT0lOVF9WQUxJREFUSU9OID0ge1xuICBNSU5fREVDTEFSRURfQkFMQU5DRTogLTk5OTk5OTk5OTk5OS45OSxcbiAgTUFYX0RFQ0xBUkVEX0JBTEFOQ0U6IDk5OTk5OTk5OTk5OS45OSxcbiAgTUFYX05PVEVfTEVOR1RIOiAxMDAwLFxufSBhcyBjb25zdFxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFR5cGUgR3VhcmRzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQmFsYW5jZUNoZWNrcG9pbnQob2JqOiBhbnkpOiBvYmogaXMgQmFsYW5jZUNoZWNrcG9pbnQge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmXG4gICAgb2JqICE9PSBudWxsICYmXG4gICAgdHlwZW9mIG9iai5jaGVja3BvaW50X2lkID09PSAnbnVtYmVyJyAmJlxuICAgIHR5cGVvZiBvYmouYWNjb3VudF9pZCA9PT0gJ251bWJlcicgJiZcbiAgICB0eXBlb2Ygb2JqLmRlY2xhcmVkX2JhbGFuY2UgPT09ICdudW1iZXInICYmXG4gICAgdHlwZW9mIG9iai5jYWxjdWxhdGVkX2JhbGFuY2UgPT09ICdudW1iZXInICYmXG4gICAgdHlwZW9mIG9iai5hZGp1c3RtZW50X2Ftb3VudCA9PT0gJ251bWJlcicgJiZcbiAgICB0eXBlb2Ygb2JqLmlzX3JlY29uY2lsZWQgPT09ICdib29sZWFuJ1xuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ZsYWdnZWRUcmFuc2FjdGlvbihvYmo6IGFueSk6IG9iaiBpcyBGbGFnZ2VkVHJhbnNhY3Rpb24ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmXG4gICAgb2JqICE9PSBudWxsICYmXG4gICAgdHlwZW9mIG9iai50cmFuc2FjdGlvbl9pZCA9PT0gJ251bWJlcicgJiZcbiAgICB0eXBlb2Ygb2JqLmlzX2ZsYWdnZWQgPT09ICdib29sZWFuJyAmJlxuICAgIG9iai5pc19mbGFnZ2VkID09PSB0cnVlXG4gIClcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBVdGlsaXR5IEZ1bmN0aW9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1JlY29uY2lsZWQoYWRqdXN0bWVudEFtb3VudDogbnVtYmVyLCB0aHJlc2hvbGQgPSBDSEVDS1BPSU5UX0NPTkZJRy5SRUNPTkNJTElBVElPTl9USFJFU0hPTEQpOiBib29sZWFuIHtcbiAgcmV0dXJuIE1hdGguYWJzKGFkanVzdG1lbnRBbW91bnQpIDwgdGhyZXNob2xkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBZGp1c3RtZW50VHlwZShhZGp1c3RtZW50QW1vdW50OiBudW1iZXIpOiAnY3JlZGl0JyB8ICdkZWJpdCcgfCAnbm9uZScge1xuICBpZiAoYWRqdXN0bWVudEFtb3VudCA+IDAuMDEpIHJldHVybiAnY3JlZGl0J1xuICBpZiAoYWRqdXN0bWVudEFtb3VudCA8IC0wLjAxKSByZXR1cm4gJ2RlYml0J1xuICByZXR1cm4gJ25vbmUnXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRBZGp1c3RtZW50QW1vdW50KGFtb3VudDogbnVtYmVyLCBjdXJyZW5jeTogc3RyaW5nID0gJ1ZORCcpOiBzdHJpbmcge1xuICBjb25zdCBhYnNBbW91bnQgPSBNYXRoLmFicyhhbW91bnQpXG4gIGNvbnN0IHR5cGUgPSBnZXRBZGp1c3RtZW50VHlwZShhbW91bnQpXG5cbiAgaWYgKHR5cGUgPT09ICdub25lJykgcmV0dXJuICdSZWNvbmNpbGVkJ1xuXG4gIGNvbnN0IHNpZ24gPSB0eXBlID09PSAnY3JlZGl0JyA/ICcrJyA6ICctJ1xuXG4gIC8vIEZvcm1hdCBiYXNlZCBvbiBjdXJyZW5jeVxuICBpZiAoY3VycmVuY3kgPT09ICdWTkQnKSB7XG4gICAgcmV0dXJuIGAke3NpZ259JHthYnNBbW91bnQudG9Mb2NhbGVTdHJpbmcoJ3ZpLVZOJyl9IOKCq2BcbiAgfSBlbHNlIGlmIChjdXJyZW5jeSA9PT0gJ1VTRCcpIHtcbiAgICByZXR1cm4gYCR7c2lnbn0kJHthYnNBbW91bnQudG9Mb2NhbGVTdHJpbmcoJ2VuLVVTJywgeyBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDIsIG1heGltdW1GcmFjdGlvbkRpZ2l0czogMiB9KX1gXG4gIH0gZWxzZSBpZiAoY3VycmVuY3kgPT09ICdFVVInKSB7XG4gICAgcmV0dXJuIGAke3NpZ2594oKsJHthYnNBbW91bnQudG9Mb2NhbGVTdHJpbmcoJ2RlLURFJywgeyBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDIsIG1heGltdW1GcmFjdGlvbkRpZ2l0czogMiB9KX1gXG4gIH1cblxuICByZXR1cm4gYCR7c2lnbn0ke2Fic0Ftb3VudH1gXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaGVja3BvaW50U3RhdHVzQ29sb3IoY2hlY2twb2ludDogQmFsYW5jZUNoZWNrcG9pbnQpOiAnZ3JlZW4nIHwgJ3llbGxvdycgfCAncmVkJyB7XG4gIGlmIChjaGVja3BvaW50LmlzX3JlY29uY2lsZWQpIHJldHVybiAnZ3JlZW4nXG4gIGlmIChNYXRoLmFicyhjaGVja3BvaW50LmFkanVzdG1lbnRfYW1vdW50KSA8IDEwMDAwMDApIHJldHVybiAneWVsbG93JyAvLyBMZXNzIHRoYW4gMU0gVk5EXG4gIHJldHVybiAncmVkJ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2hlY2twb2ludEFsZXJ0TWVzc2FnZShjaGVja3BvaW50OiBCYWxhbmNlQ2hlY2twb2ludCk6IHN0cmluZyB7XG4gIGlmIChjaGVja3BvaW50LmlzX3JlY29uY2lsZWQpIHtcbiAgICByZXR1cm4gJ0Z1bGx5IHJlY29uY2lsZWQgLSBhbGwgdHJhbnNhY3Rpb25zIGFjY291bnRlZCBmb3InXG4gIH1cblxuICBjb25zdCB0eXBlID0gZ2V0QWRqdXN0bWVudFR5cGUoY2hlY2twb2ludC5hZGp1c3RtZW50X2Ftb3VudClcbiAgY29uc3QgYWJzQW1vdW50ID0gTWF0aC5hYnMoY2hlY2twb2ludC5hZGp1c3RtZW50X2Ftb3VudClcblxuICBpZiAodHlwZSA9PT0gJ2NyZWRpdCcpIHtcbiAgICByZXR1cm4gYFlvdSBoYXZlICR7YWJzQW1vdW50LnRvTG9jYWxlU3RyaW5nKCl9IGluIHVuZXhwbGFpbmVkIGluY29tZS4gQWRkIHRyYW5zYWN0aW9ucyB0byByZWNvbmNpbGUuYFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBgWW91IGhhdmUgJHthYnNBbW91bnQudG9Mb2NhbGVTdHJpbmcoKX0gaW4gdW5leHBsYWluZWQgZXhwZW5zZXMuIEFkZCB0cmFuc2FjdGlvbnMgdG8gcmVjb25jaWxlLmBcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkNIRUNLUE9JTlRfQ09ORklHIiwiUkVDT05DSUxJQVRJT05fVEhSRVNIT0xEIiwiTUFYX0NIRUNLUE9JTlRTX1BFUl9BQ0NPVU5UIiwiQkFMQU5DRV9BREpVU1RNRU5UX0RFU0NSSVBUSU9OIiwiQ0hFQ0tQT0lOVF9WQUxJREFUSU9OIiwiTUlOX0RFQ0xBUkVEX0JBTEFOQ0UiLCJNQVhfREVDTEFSRURfQkFMQU5DRSIsIk1BWF9OT1RFX0xFTkdUSCIsImlzQmFsYW5jZUNoZWNrcG9pbnQiLCJvYmoiLCJjaGVja3BvaW50X2lkIiwiYWNjb3VudF9pZCIsImRlY2xhcmVkX2JhbGFuY2UiLCJjYWxjdWxhdGVkX2JhbGFuY2UiLCJhZGp1c3RtZW50X2Ftb3VudCIsImlzX3JlY29uY2lsZWQiLCJpc0ZsYWdnZWRUcmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uX2lkIiwiaXNfZmxhZ2dlZCIsImlzUmVjb25jaWxlZCIsImFkanVzdG1lbnRBbW91bnQiLCJ0aHJlc2hvbGQiLCJNYXRoIiwiYWJzIiwiZ2V0QWRqdXN0bWVudFR5cGUiLCJmb3JtYXRBZGp1c3RtZW50QW1vdW50IiwiYW1vdW50IiwiY3VycmVuY3kiLCJhYnNBbW91bnQiLCJ0eXBlIiwic2lnbiIsInRvTG9jYWxlU3RyaW5nIiwibWluaW11bUZyYWN0aW9uRGlnaXRzIiwibWF4aW11bUZyYWN0aW9uRGlnaXRzIiwiZ2V0Q2hlY2twb2ludFN0YXR1c0NvbG9yIiwiY2hlY2twb2ludCIsImdldENoZWNrcG9pbnRBbGVydE1lc3NhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./types/checkpoint.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/@supabase","vendor-chunks/next","vendor-chunks/tslib","vendor-chunks/iceberg-js","vendor-chunks/cookie"], () => (__webpack_exec__("(rsc)/../../node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Faccounts%2Froute&page=%2Fapi%2Faccounts%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Faccounts%2Froute.ts&appDir=%2FUsers%2Ftrunghuynh%2FDeveloper%2FFinanceapp%2Fapps%2Fweb%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Ftrunghuynh%2FDeveloper%2FFinanceapp%2Fapps%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();